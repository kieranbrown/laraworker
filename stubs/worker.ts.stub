/**
 * Cloudflare Worker entry point for Laravel via php-cgi-wasm.
 *
 * On cold start: initializes PHP, fetches app.tar from Static Assets,
 * unpacks into Emscripten MEMFS, and caches the PHP instance.
 * Each request is routed through php.request(request).
 *
 * Static assets are served by Cloudflare Static Assets (run_worker_first removed)
 * before the worker is invoked, so this worker only handles PHP routing.
 *
 * When Inertia SSR is enabled (INERTIA_SSR=true), HTML responses containing
 * Inertia page data are intercepted and server-side rendered inline using
 * the bundled SSR entry point. This eliminates the need for a separate
 * SSR server — the worker IS the SSR server.
 */

import { renderInertiaSSR, type InertiaRenderFn } from './inertia-ssr';

/**
 * Inertia SSR render function — automatically configured by laraworker:build
 * when `config('laraworker.inertia.ssr')` is enabled. The build command runs
 * `vite build --ssr` and copies the bundle to .laraworker/ssr/ssr.js.
 *
 * IMPORTANT: The SSR import MUST appear before './shims' so that Inertia's
 * module-level `isServer` check (`typeof window === "undefined"`) evaluates
 * to `true`. The shims module defines `window` for Emscripten, so anything
 * imported after it would see a browser-like environment.
 */
let ssrRender: InertiaRenderFn | null = null;
{{SSR_IMPORT}}

// Must be imported before any Emscripten module to shim document/window.
// Intentionally placed AFTER the SSR import — see note above.
import './shims';

import { PhpCgiCloudflare } from './php';
import { untar } from './tar';

interface Env {
  ASSETS: Fetcher;
  /**
   * Set to "true" to enable inline Inertia SSR rendering.
   * Requires an SSR bundle to be imported above.
   */
  INERTIA_SSR?: string;
  /**
   * Set to "true" to enable the /__opcache-status diagnostic endpoint.
   * This endpoint exposes OPcache metrics (hits, misses, memory usage, etc.)
   * and should NOT be enabled in production unless debugging performance issues.
   */
  OPCACHE_DEBUG?: string;
  /**
   * Set to "true" to log WASM heap size and memory metrics on every request.
   * Useful for diagnosing "Worker exceeded resource limits" (Error 1102).
   */
  MEMORY_DEBUG?: string;
  /**
   * Maximum requests before recycling the WASM module to prevent function
   * table corruption. The persistent module patch keeps PHP alive across
   * requests, but internal state (closures, callbacks, function pointers)
   * can accumulate and corrupt the fixed-size WASM function table, causing
   * "table index is out of bounds" crashes. Recycling creates a fresh module.
   * Set to "0" to disable. Default: 50.
   */
  WORKER_MAX_REQUESTS?: string;
}

/**
 * Log WASM heap and memory metrics.
 * Works by inspecting the Emscripten HEAP buffer exposed by PhpCgiCloudflare.
 */
function logMemory(label: string, instance: PhpCgiCloudflare | null): void {
  const parts = [`[mem] ${label}`];
  try {
    // PhpCgiCloudflare inherits from PhpCgiBase which exposes the Emscripten module
    // after initialization. The WASM heap is available as HEAP8.buffer.
    const mod = (instance as any)?._phpModule ?? (instance as any)?.phpModule;
    if (mod?.HEAP8?.buffer) {
      parts.push(`wasm=${(mod.HEAP8.buffer.byteLength / 1024 / 1024).toFixed(1)}MB`);
    }
  } catch {}
  console.log(parts.join(' '));
}

let php: PhpCgiCloudflare | null = null;
let requestCount = 0;

async function ensureInitialized(env: Env): Promise<PhpCgiCloudflare> {
  if (!php) {
    // Build cfd1 bindings object from env — each key is a D1 binding name
    // injected by Cloudflare at runtime (declared in wrangler.jsonc d1_databases)
    const cfd1: Record<string, unknown> = {};
{{D1_BINDINGS}}

    php = new PhpCgiCloudflare({
      docroot: '/app/public',
      prefix: '/',
      entrypoint: 'index.php',
      // Fixed 64 MB WASM linear memory — no growth. Combined with JS heap,
      // this stays comfortably under Cloudflare Workers' 128 MB budget.
      // Memory is baked into the PHP 8.5 WASM binary; no runtime config needed.
      ...(Object.keys(cfd1).length > 0 ? { cfd1 } : {}),
      ini: [
        'auto_prepend_file=/app/php-stubs.php',
{{OPCACHE_INI}}
      ].join('\n'),
    });
  }

  // PhpCgiBase.request() calls refresh() when PHP exits with non-zero code,
  // which creates a brand new Emscripten module with empty MEMFS. This wipes
  // all previously extracted files. Check if MEMFS needs (re-)initialization.
  const FS = await php.getFS();
  if (!FS.analyzePath('/app/public/index.php').exists) {
    await initializeFilesystem(php, env);
  }

  return php;
}

async function initializeFilesystem(
  php: PhpCgiCloudflare,
  env: Env,
): Promise<void> {
  const FS = await php.getFS();

  // Disable MEMFS permission enforcement entirely. Our tar unpacker doesn't
  // set file modes, so permissions depend on the Emscripten umask at creation
  // time. Since we're running in a WASM sandbox with no real users, there's
  // no security benefit to enforcing file permissions.
  FS.ignorePermissions = true;

  // Fetch the compressed Laravel application from Static Assets
  const tarResponse = await env.ASSETS.fetch(
    new Request('http://assets.local/app.tar.gz'),
  );

  if (!tarResponse.ok) {
    throw new Error(`Failed to fetch app.tar.gz: ${tarResponse.status}`);
  }

  // Decompress gzip using Web Streams API (available in Workers)
  const decompressed = tarResponse.body!.pipeThrough(
    new DecompressionStream('gzip'),
  );
  const tarBuffer = await new Response(decompressed).arrayBuffer();
  if ((env as Env).MEMORY_DEBUG === 'true') {
    console.log(`[mem] tar decompressed: ${(tarBuffer.byteLength / 1024 / 1024).toFixed(1)}MB`);
    logMemory('before-untar', php);
  }

  // Unpack into MEMFS at /app
  untar(FS, tarBuffer, '/app');
  if ((env as Env).MEMORY_DEBUG === 'true') {
    logMemory('after-untar', php);
  }

  // Ensure required Laravel directories exist
  const dirs = [
    '/app/storage/framework/sessions',
    '/app/storage/framework/views',
    '/app/storage/framework/cache',
    '/app/storage/framework/cache/data',
    '/app/storage/logs',
    '/app/bootstrap/cache',
  ];

  for (const dir of dirs) {
    mkdirp(FS, dir);
  }

  // Set compiled view mtimes ahead of source views to prevent Blade
  // recompilation. MEMFS gives all files identical timestamps during
  // tar extraction, so isExpired() always returns true without this.
  const viewDir = '/app/storage/framework/views';
  if (FS.analyzePath(viewDir).exists) {
    const futureTime = Date.now() + 86400000; // 1 day ahead in ms
    const entries = FS.readdir(viewDir).filter(
      (e: string) => e !== '.' && e !== '..',
    );
    for (const entry of entries) {
      try {
        FS.utime(`${viewDir}/${entry}`, futureTime, futureTime);
      } catch {}
    }
  }
}

function mkdirp(
  FS: { analyzePath(p: string): { exists: boolean }; mkdir(p: string): void },
  path: string,
): void {
  const parts = path.split('/').filter(Boolean);
  let current = '';
  for (const part of parts) {
    current += '/' + part;
    if (!FS.analyzePath(current).exists) {
      FS.mkdir(current);
    }
  }
}

/**
 * Attempt inline Inertia SSR on an HTML response from PHP.
 *
 * Flow:
 * 1. PHP generates HTML with <div id="app" data-page="..."></div>
 * 2. We extract the Inertia page data from data-page attribute
 * 3. We call renderToString via the SSR bundle to render the component
 * 4. We inject the rendered HTML + head elements back into the response
 * 5. Client-side Vue/React hydrates the pre-rendered DOM
 *
 * Falls back to client-side rendering (CSR) if SSR fails.
 */
async function maybeApplySSR(
  response: Response,
  env: Env,
): Promise<Response> {
  // Skip if SSR is not enabled or no render function available
  if (env.INERTIA_SSR !== 'true' || !ssrRender) {
    return response;
  }

  // Only process HTML responses (not JSON API responses, redirects, etc.)
  const contentType = response.headers.get('content-type') || '';
  if (!contentType.includes('text/html')) {
    return response;
  }

  // Don't SSR Inertia XHR responses (they're JSON, served directly)
  if (response.headers.has('x-inertia')) {
    return response;
  }

  const html = await response.text();
  const ssrHtml = await renderInertiaSSR(html, ssrRender);

  if (ssrHtml === null) {
    // SSR didn't apply (no Inertia data found, or render failed) — return original
    return new Response(html, {
      status: response.status,
      statusText: response.statusText,
      headers: response.headers,
    });
  }

  return new Response(ssrHtml, {
    status: response.status,
    statusText: response.statusText,
    headers: response.headers,
  });
}

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const url = new URL(request.url);

    // Health check — responds without initializing PHP
    if (url.pathname === '/__health') {
      return new Response('OK', { status: 200, headers: { 'Content-Type': 'text/plain' } });
    }

    // Memory diagnostic endpoint — protected by env var
    if (url.pathname === '/__memory-debug' && env.MEMORY_DEBUG === 'true') {
      const info: Record<string, unknown> = { requestCount };
      try {
        const mod = (php as any)?._phpModule ?? (php as any)?.phpModule;
        if (mod?.HEAP8?.buffer) {
          info.wasmHeapBytes = mod.HEAP8.buffer.byteLength;
          info.wasmHeapMB = +(mod.HEAP8.buffer.byteLength / 1024 / 1024).toFixed(1);
        }
      } catch {}
      return new Response(JSON.stringify(info, null, 2), {
        status: 200,
        headers: { 'Content-Type': 'application/json' },
      });
    }

    // OPcache diagnostic endpoint — protected by env var
    if (url.pathname === '/__opcache-status' && env.OPCACHE_DEBUG === 'true') {
      try {
        const instance = await ensureInitialized(env);
        const response = await instance.request(new Request(
          new URL('/__opcache-status.php', request.url),
          { headers: request.headers }
        ));
        return response;
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return new Response(JSON.stringify({ error: message }), {
          status: 500,
          headers: { 'Content-Type': 'application/json' },
        });
      }
    }

    try {
      const t0 = performance.now();
      let instance = await ensureInitialized(env);
      const tInit = performance.now();

      if (env.MEMORY_DEBUG === 'true') {
        logMemory(`req#${requestCount + 1} after-init`, instance);
      }

      // Update globalThis.location to match the actual request URL so that
      // PhpCgiBase sets HTTP_HOST and REQUEST_SCHEME correctly (it reads
      // from globalThis.location). The shim defaults to https://localhost.
      // @ts-expect-error — overriding Location with URL for PhpCgiBase
      globalThis.location = new URL(request.url);

      if (env.MEMORY_DEBUG === 'true') {
        console.log(`[time] init=${(tInit - t0).toFixed(0)}ms, starting PHP for ${url.pathname}`);
      }

      // Clone request for potential retry — body can only be read once
      const retryRequest = request.clone();

      // All requests go through PHP - static assets are served
      // by Cloudflare Static Assets before the worker is invoked
      let response = await instance.request(request);

      // Detect WASM crash: PhpCgiBase catches RuntimeError (e.g. "table index
      // is out of bounds"), returns 500, and calls refresh() which wipes MEMFS.
      // If the filesystem was wiped, the module crashed — re-init and retry once.
      if (response.status === 500) {
        const FS = await instance.getFS();
        if (!FS.analyzePath('/app/public/index.php').exists) {
          console.warn('[wasm] Module crash detected, reinitializing and retrying request');
          await initializeFilesystem(instance, env);
          requestCount = 0;
          // @ts-expect-error — overriding Location with URL for PhpCgiBase
          globalThis.location = new URL(retryRequest.url);
          response = await instance.request(retryRequest);
        }
      }

      const tPhp = performance.now();

      if (env.MEMORY_DEBUG === 'true') {
        // Log PHP stderr when debugging — PhpCgiBase silently discards it on success
        try {
          const stderrBuf = (instance as any).error;
          if (stderrBuf && stderrBuf.length > 0) {
            const stderr = new TextDecoder().decode(new Uint8Array(stderrBuf).buffer);
            if (stderr.trim()) {
              console.log('[php-stderr]', stderr);
            }
          }
        } catch {}
      }

      if (env.MEMORY_DEBUG === 'true') {
        logMemory(`req#${requestCount + 1} after-php`, instance);
      }

      if (!response || typeof response.headers?.get !== 'function') {
        console.error('PHP returned invalid response:', typeof response, response);
        return new Response('PHP returned invalid response', { status: 502 });
      }

      // Optionally apply Inertia SSR to HTML responses
      const ssrResponse = await maybeApplySSR(response, env);
      const tSsr = performance.now();

      if (!ssrResponse || typeof ssrResponse.headers?.get !== 'function') {
        console.error('SSR returned invalid response:', typeof ssrResponse, ssrResponse);
        return new Response('SSR returned invalid response', { status: 502 });
      }

      // Add Server-Timing headers to PHP-routed responses
      const headers = new Headers(ssrResponse.headers);
      headers.set('Server-Timing', [
        `init;dur=${(tInit - t0).toFixed(1)}`,
        `php;dur=${(tPhp - tInit).toFixed(1)}`,
        `ssr;dur=${(tSsr - tPhp).toFixed(1)}`,
        `total;dur=${(tSsr - t0).toFixed(1)}`,
      ].join(', '));
      headers.set('X-Request-Count', String(++requestCount));

      // Proactive module recycling: after N requests, discard the WASM module
      // to prevent function table corruption from accumulated internal state.
      // Analogous to PHP-FPM's pm.max_requests — prevents stale function
      // pointers in the persistent module from causing "table index is out of
      // bounds" crashes on warm isolates.
      const maxRequests = parseInt(env.WORKER_MAX_REQUESTS || '50', 10);
      if (maxRequests > 0 && requestCount >= maxRequests) {
        if (env.MEMORY_DEBUG === 'true') {
          console.log(`[wasm] Recycling module after ${requestCount} requests`);
        }
        php = null;
        requestCount = 0;
      }

      return new Response(ssrResponse.body, {
        status: ssrResponse.status,
        statusText: ssrResponse.statusText,
        headers,
      });
    } catch (error) {
      // WASM RuntimeError may propagate past PhpCgiBase's error handler
      // (e.g. during Asyncify unwind/rewind). Recycle the module for recovery.
      if (error instanceof Error && error.message.includes('table index')) {
        console.error('[wasm] Fatal table corruption, recycling module:', error.message);
        php = null;
        requestCount = 0;
      }

      const message =
        error instanceof Error ? error.message : 'Unknown error';
      console.error('Worker error:', message);
      return new Response(`Internal Server Error: ${message}`, {
        status: 500,
        headers: { 'Content-Type': 'text/plain' },
      });
    }
  },
};
