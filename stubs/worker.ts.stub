/**
 * Cloudflare Worker entry point for Laravel via php-cgi-wasm.
 *
 * On cold start: initializes PHP, fetches app.tar from Static Assets,
 * unpacks into Emscripten MEMFS, and caches the PHP instance.
 * Each request is routed through php.request(request).
 *
 * Static assets are served by Cloudflare Static Assets (run_worker_first removed)
 * before the worker is invoked, so this worker only handles PHP routing.
 *
 * When Inertia SSR is enabled (INERTIA_SSR=true), HTML responses containing
 * Inertia page data are intercepted and server-side rendered inline using
 * the bundled SSR entry point. This eliminates the need for a separate
 * SSR server — the worker IS the SSR server.
 */

import { renderInertiaSSR, type InertiaRenderFn } from './inertia-ssr';

/**
 * Inertia SSR render function — automatically configured by laraworker:build
 * when `config('laraworker.inertia.ssr')` is enabled. The build command runs
 * `vite build --ssr` and copies the bundle to .laraworker/ssr/ssr.js.
 *
 * IMPORTANT: The SSR import MUST appear before './shims' so that Inertia's
 * module-level `isServer` check (`typeof window === "undefined"`) evaluates
 * to `true`. The shims module defines `window` for Emscripten, so anything
 * imported after it would see a browser-like environment.
 */
let ssrRender: InertiaRenderFn | null = null;
{{SSR_IMPORT}}

// Must be imported before any Emscripten module to shim document/window.
// Intentionally placed AFTER the SSR import — see note above.
import './shims';

import { PhpCgiCloudflare } from './php';
import { untar } from './tar';

interface Env {
  ASSETS: Fetcher;
  /**
   * Set to "true" to enable inline Inertia SSR rendering.
   * Requires an SSR bundle to be imported above.
   */
  INERTIA_SSR?: string;
  /**
   * Set to "true" to enable the /__opcache-status diagnostic endpoint.
   * This endpoint exposes OPcache metrics (hits, misses, memory usage, etc.)
   * and should NOT be enabled in production unless debugging performance issues.
   */
  OPCACHE_DEBUG?: string;
  /**
   * Set to "true" to log WASM heap size and memory metrics on every request.
   * Useful for diagnosing "Worker exceeded resource limits" (Error 1102).
   */
  MEMORY_DEBUG?: string;
  /**
   * Maximum requests before recycling the WASM module. When set, the WASM
   * module is destroyed and recreated after this many requests, clearing all
   * OPcache and internal state. This forces a cold start (tar extraction +
   * PHP recompilation) which is expensive and can trigger Error 1102.
   *
   * The CGI persistent module patch (cgi-persistent-module.sh) keeps the PHP
   * module alive across requests without needing table growth, so recycling
   * is disabled by default. Set to "0" to disable (recommended). Default: 0.
   */
  WORKER_MAX_REQUESTS?: string;
}

/**
 * Log WASM heap and memory metrics.
 * Works by inspecting the Emscripten HEAP buffer exposed by PhpCgiCloudflare.
 */
function logMemory(label: string, instance: PhpCgiCloudflare | null): void {
  const parts = [`[mem] ${label}`];
  try {
    // PhpCgiCloudflare inherits from PhpCgiBase which exposes the Emscripten module
    // after initialization. The WASM heap is available as HEAP8.buffer.
    const mod = (instance as any)?._phpModule ?? (instance as any)?.phpModule;
    if (mod?.HEAP8?.buffer) {
      parts.push(`wasm=${(mod.HEAP8.buffer.byteLength / 1024 / 1024).toFixed(1)}MB`);
    }
  } catch {}
  console.log(parts.join(' '));
}

/**
 * Get WASM linear memory size in bytes from the Emscripten module.
 */
function getWasmHeapBytes(instance: PhpCgiCloudflare | null): number | null {
  try {
    const mod = (instance as any)?._phpModule ?? (instance as any)?.phpModule;
    if (mod?.HEAP8?.buffer) {
      return mod.HEAP8.buffer.byteLength;
    }
  } catch {}
  return null;
}

/**
 * Walk MEMFS under /app and sum file sizes to estimate memory filesystem usage.
 */
function getMemfsSize(FS: any): number {
  let total = 0;
  function walk(path: string): void {
    try {
      const entries = FS.readdir(path).filter((e: string) => e !== '.' && e !== '..');
      for (const entry of entries) {
        const full = `${path}/${entry}`;
        try {
          const stat = FS.stat(full);
          // Check if directory: S_IFDIR = 0o040000 = 16384
          if ((stat.mode & 61440) === 16384) {
            walk(full);
          } else {
            total += stat.size;
          }
        } catch {}
      }
    } catch {}
  }
  walk('/app');
  return total;
}

let php: PhpCgiCloudflare | null = null;
let requestCount = 0;
let refreshCount = 0;

async function ensureInitialized(env: Env): Promise<PhpCgiCloudflare> {
  if (!php) {
    // Build cfd1 bindings object from env — each key is a D1 binding name
    // injected by Cloudflare at runtime (declared in wrangler.jsonc d1_databases)
    const cfd1: Record<string, unknown> = {};
{{D1_BINDINGS}}

    php = new PhpCgiCloudflare({
      docroot: '/app/public',
      prefix: '/',
      entrypoint: 'index.php',
      // Fixed 64 MB WASM linear memory — no growth. Combined with JS heap,
      // this stays comfortably under Cloudflare Workers' 128 MB budget.
      // Memory is baked into the PHP 8.5 WASM binary; no runtime config needed.
      ...(Object.keys(cfd1).length > 0 ? { cfd1 } : {}),
      ini: [
        'auto_prepend_file=/app/php-stubs.php',
{{OPCACHE_INI}}
      ].join('\n'),
    });
  }

  // PhpCgiCloudflare.refresh() is a no-op (guards against unnecessary module
  // rebuilds). MEMFS only needs init on first boot or after the worker discards
  // a corrupted instance (php=null) and creates a fresh one.
  const FS = await php.getFS();
  if (!FS.analyzePath('/app/public/index.php').exists) {
    await initializeFilesystem(php, env);
  }

  return php;
}

async function initializeFilesystem(
  php: PhpCgiCloudflare,
  env: Env,
): Promise<void> {
  refreshCount++;
  const FS = await php.getFS();

  // Disable MEMFS permission enforcement entirely. Our tar unpacker doesn't
  // set file modes, so permissions depend on the Emscripten umask at creation
  // time. Since we're running in a WASM sandbox with no real users, there's
  // no security benefit to enforcing file permissions.
  FS.ignorePermissions = true;

  // Fetch the compressed Laravel application from Static Assets
  const tarResponse = await env.ASSETS.fetch(
    new Request('http://assets.local/app.tar.gz'),
  );

  if (!tarResponse.ok) {
    throw new Error(`Failed to fetch app.tar.gz: ${tarResponse.status}`);
  }

  // Decompress gzip using Web Streams API (available in Workers)
  const decompressed = tarResponse.body!.pipeThrough(
    new DecompressionStream('gzip'),
  );
  const tarBuffer = await new Response(decompressed).arrayBuffer();
  if ((env as Env).MEMORY_DEBUG === 'true') {
    console.log(`[mem] tar decompressed: ${(tarBuffer.byteLength / 1024 / 1024).toFixed(1)}MB`);
    logMemory('before-untar', php);
  }

  // Unpack into MEMFS at /app
  untar(FS, tarBuffer, '/app');
  if ((env as Env).MEMORY_DEBUG === 'true') {
    logMemory('after-untar', php);
  }

  // Ensure required Laravel directories exist
  const dirs = [
    '/app/storage/framework/sessions',
    '/app/storage/framework/views',
    '/app/storage/framework/cache',
    '/app/storage/framework/cache/data',
    '/app/storage/logs',
    '/app/bootstrap/cache',
  ];

  for (const dir of dirs) {
    mkdirp(FS, dir);
  }

  // Set compiled view mtimes ahead of source views to prevent Blade
  // recompilation. MEMFS gives all files identical timestamps during
  // tar extraction, so isExpired() always returns true without this.
  const viewDir = '/app/storage/framework/views';
  if (FS.analyzePath(viewDir).exists) {
    const futureTime = Date.now() + 86400000; // 1 day ahead in ms
    const entries = FS.readdir(viewDir).filter(
      (e: string) => e !== '.' && e !== '..',
    );
    for (const entry of entries) {
      try {
        FS.utime(`${viewDir}/${entry}`, futureTime, futureTime);
      } catch {}
    }
  }

  // Write lightweight diagnostic PHP script for OPcache/memory stats.
  // Used by /__memory-report endpoint and memory debug headers.
  FS.writeFile(
    '/app/public/__lw-diag.php',
    new TextEncoder().encode(
      '<?php header("Content-Type: application/json");'
      + '$oc=function_exists("opcache_get_status")?opcache_get_status(false):null;'
      + 'echo json_encode(["opcache"=>$oc,"memory_peak"=>memory_get_peak_usage(true),'
      + '"memory_current"=>memory_get_usage(true)]);',
    ),
  );
}

function mkdirp(
  FS: { analyzePath(p: string): { exists: boolean }; mkdir(p: string): void },
  path: string,
): void {
  const parts = path.split('/').filter(Boolean);
  let current = '';
  for (const part of parts) {
    current += '/' + part;
    if (!FS.analyzePath(current).exists) {
      FS.mkdir(current);
    }
  }
}

/**
 * Attempt inline Inertia SSR on an HTML response from PHP.
 *
 * Flow:
 * 1. PHP generates HTML with <div id="app" data-page="..."></div>
 * 2. We extract the Inertia page data from data-page attribute
 * 3. We call renderToString via the SSR bundle to render the component
 * 4. We inject the rendered HTML + head elements back into the response
 * 5. Client-side Vue/React hydrates the pre-rendered DOM
 *
 * Falls back to client-side rendering (CSR) if SSR fails.
 */
async function maybeApplySSR(
  response: Response,
  env: Env,
): Promise<Response> {
  // Skip if SSR is not enabled or no render function available
  if (env.INERTIA_SSR !== 'true' || !ssrRender) {
    return response;
  }

  // Only process HTML responses (not JSON API responses, redirects, etc.)
  const contentType = response.headers.get('content-type') || '';
  if (!contentType.includes('text/html')) {
    return response;
  }

  // Don't SSR Inertia XHR responses (they're JSON, served directly)
  if (response.headers.has('x-inertia')) {
    return response;
  }

  const html = await response.text();
  const ssrHtml = await renderInertiaSSR(html, ssrRender);

  if (ssrHtml === null) {
    // SSR didn't apply (no Inertia data found, or render failed) — return original
    return new Response(html, {
      status: response.status,
      statusText: response.statusText,
      headers: response.headers,
    });
  }

  return new Response(ssrHtml, {
    status: response.status,
    statusText: response.statusText,
    headers: response.headers,
  });
}

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const url = new URL(request.url);

    // Health check — responds without initializing PHP
    if (url.pathname === '/__health') {
      return new Response('OK', { status: 200, headers: { 'Content-Type': 'text/plain' } });
    }

    // Memory diagnostic endpoint — protected by env var
    if (url.pathname === '/__memory-debug' && env.MEMORY_DEBUG === 'true') {
      const info: Record<string, unknown> = { requestCount };
      try {
        const mod = (php as any)?._phpModule ?? (php as any)?.phpModule;
        if (mod?.HEAP8?.buffer) {
          info.wasmHeapBytes = mod.HEAP8.buffer.byteLength;
          info.wasmHeapMB = +(mod.HEAP8.buffer.byteLength / 1024 / 1024).toFixed(1);
        }
      } catch {}
      return new Response(JSON.stringify(info, null, 2), {
        status: 200,
        headers: { 'Content-Type': 'application/json' },
      });
    }

    // Full memory report endpoint — protected by env var
    if (url.pathname === '/__memory-report' && env.MEMORY_DEBUG === 'true') {
      const report: Record<string, unknown> = { requestCount, refreshCount };

      const heapBytes = getWasmHeapBytes(php);
      if (heapBytes !== null) {
        report.wasmHeap = { bytes: heapBytes, mb: +(heapBytes / 1024 / 1024).toFixed(1) };
      }

      try {
        const instance = await ensureInitialized(env);
        const FS = await instance.getFS();
        const memfsBytes = getMemfsSize(FS);
        report.memfs = { bytes: memfsBytes, mb: +(memfsBytes / 1024 / 1024).toFixed(1) };
      } catch {}

      // OPcache + PHP memory stats via internal PHP request
      try {
        const instance = await ensureInitialized(env);
        const diagResponse = await instance.request(
          new Request(new URL('/__lw-diag.php', request.url)),
        );
        if (diagResponse.ok) {
          const phpData: any = await diagResponse.json();
          if (phpData?.opcache?.memory_usage) {
            const mem = phpData.opcache.memory_usage;
            const used = mem.used_memory ?? 0;
            const free = mem.free_memory ?? 0;
            const wasted = mem.wasted_memory ?? 0;
            report.opcache = {
              usedBytes: used,
              totalBytes: used + free + wasted,
              hitRate: phpData.opcache.opcache_statistics?.opcache_hit_rate ?? 0,
              scripts: phpData.opcache.opcache_statistics?.num_cached_scripts ?? 0,
            };
          }
          report.phpMemory = {
            currentBytes: phpData.memory_current ?? 0,
            peakBytes: phpData.memory_peak ?? 0,
          };
        }
      } catch {}

      return new Response(JSON.stringify(report, null, 2), {
        status: 200,
        headers: { 'Content-Type': 'application/json' },
      });
    }

    // OPcache diagnostic endpoint — protected by env var
    if (url.pathname === '/__opcache-status' && env.OPCACHE_DEBUG === 'true') {
      try {
        const instance = await ensureInitialized(env);
        const response = await instance.request(new Request(
          new URL('/__opcache-status.php', request.url),
          { headers: request.headers }
        ));
        return response;
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return new Response(JSON.stringify({ error: message }), {
          status: 500,
          headers: { 'Content-Type': 'application/json' },
        });
      }
    }

    try {
      const t0 = performance.now();
      let instance = await ensureInitialized(env);
      const tInit = performance.now();

      if (env.MEMORY_DEBUG === 'true') {
        logMemory(`req#${requestCount + 1} after-init`, instance);
      }

      // Update globalThis.location to match the actual request URL so that
      // PhpCgiBase sets HTTP_HOST and REQUEST_SCHEME correctly (it reads
      // from globalThis.location). The shim defaults to https://localhost.
      // @ts-expect-error — overriding Location with URL for PhpCgiBase
      globalThis.location = new URL(request.url);

      if (env.MEMORY_DEBUG === 'true') {
        console.log(`[time] init=${(tInit - t0).toFixed(0)}ms, starting PHP for ${url.pathname}`);
      }

      // Clone request for potential retry — body can only be read once
      const retryRequest = request.clone();

      // Capture state before request to detect refresh/exit code issues.
      // PhpCgiBase.count only increments on exitCode === 0; refresh() is
      // called on non-zero exit code (intercepted by PhpCgiCloudflare).
      const countBefore = (instance as any).count ?? 0;
      const refreshesBefore = instance.refreshCount;

      // All requests go through PHP - static assets are served
      // by Cloudflare Static Assets before the worker is invoked
      let response = await instance.request(request);

      // Detect non-zero exit code or module refresh after request
      const countAfter = (instance as any).count ?? 0;
      const refreshesAfter = instance.refreshCount;
      const lastExitCode: number = (instance as any).lastExitCode ?? -1;
      const refreshRequested = refreshesAfter > refreshesBefore;

      if (refreshRequested) {
        const level = instance.needsRestart ? 'error' : 'warn';
        console[level](
          `[php-wasm] ${instance.needsRestart ? 'WASM crash' : 'PHP non-zero exit'} ` +
          `on ${url.pathname}. exitCode=${lastExitCode}, ` +
          `refreshes=${refreshesBefore}→${refreshesAfter}, ` +
          `phpCount=${countBefore}→${countAfter}, ` +
          `needsRestart=${instance.needsRestart}`
        );
        // Capture stderr — still available until next request clears it
        try {
          const stderrBuf = (instance as any).error;
          if (stderrBuf && stderrBuf.length > 0) {
            const stderr = new TextDecoder().decode(new Uint8Array(stderrBuf).buffer);
            if (stderr.trim()) {
              console.warn('[php-wasm] stderr:', stderr.substring(0, 4000));
            }
          }
        } catch {}
      }

      // Detect WASM crash: PhpCgiCloudflare.refresh() intercepts PhpCgiBase's
      // refresh calls. count >= 2 means both catch (RuntimeError) and finally
      // (non-zero exit) fired — genuine module corruption. count === 1 means
      // only PHP exited non-zero (app error) — module is fine, OPcache preserved.
      if (instance.needsRestart) {
        console.warn('[wasm] WASM crash detected, recycling module and retrying request');
        php = null;
        requestCount = 0;
        instance = await ensureInitialized(env);
        // @ts-expect-error — overriding Location with URL for PhpCgiBase
        globalThis.location = new URL(retryRequest.url);
        response = await instance.request(retryRequest);
      }

      const tPhp = performance.now();

      if (env.MEMORY_DEBUG === 'true') {
        // Log PHP stderr when debugging — PhpCgiBase silently discards it on success
        try {
          const stderrBuf = (instance as any).error;
          if (stderrBuf && stderrBuf.length > 0) {
            const stderr = new TextDecoder().decode(new Uint8Array(stderrBuf).buffer);
            if (stderr.trim()) {
              console.log('[php-stderr]', stderr);
            }
          }
        } catch {}
      }

      if (env.MEMORY_DEBUG === 'true') {
        logMemory(`req#${requestCount + 1} after-php`, instance);
      }

      if (!response || typeof response.headers?.get !== 'function') {
        console.error('PHP returned invalid response:', typeof response, response);
        return new Response('PHP returned invalid response', { status: 502 });
      }

      // Optionally apply Inertia SSR to HTML responses
      const ssrResponse = await maybeApplySSR(response, env);
      const tSsr = performance.now();

      if (!ssrResponse || typeof ssrResponse.headers?.get !== 'function') {
        console.error('SSR returned invalid response:', typeof ssrResponse, ssrResponse);
        return new Response('SSR returned invalid response', { status: 502 });
      }

      // Add Server-Timing headers to PHP-routed responses
      const headers = new Headers(ssrResponse.headers);
      headers.set('Server-Timing', [
        `init;dur=${(tInit - t0).toFixed(1)}`,
        `php;dur=${(tPhp - tInit).toFixed(1)}`,
        `ssr;dur=${(tSsr - tPhp).toFixed(1)}`,
        `total;dur=${(tSsr - t0).toFixed(1)}`,
      ].join(', '));
      headers.set('X-Request-Count', String(++requestCount));
      headers.set('X-Php-Exit-Code', String(lastExitCode));
      if (refreshRequested) {
        headers.set('X-Refresh-Requested', instance.needsRestart ? 'crash' : 'php-error');
      }

      // Memory profiling headers — only when MEMORY_DEBUG is enabled
      if (env.MEMORY_DEBUG === 'true') {
        const heapBytes = getWasmHeapBytes(instance);
        if (heapBytes !== null) {
          headers.set('X-Wasm-Heap-Used', String(heapBytes));
        }
        headers.set('X-Module-Refreshes', String(refreshCount));

        try {
          const FS = await instance.getFS();
          headers.set('X-Memfs-Size', String(getMemfsSize(FS)));
        } catch {}

        // OPcache memory stats via lightweight internal PHP request
        try {
          const diagResponse = await instance.request(
            new Request(new URL('/__lw-diag.php', request.url)),
          );
          if (diagResponse.ok) {
            const phpData: any = await diagResponse.json();
            if (phpData?.opcache?.memory_usage) {
              const mem = phpData.opcache.memory_usage;
              headers.set('X-OPcache-Memory-Used', String(mem.used_memory ?? 0));
              headers.set('X-OPcache-Memory-Total', String(
                (mem.used_memory ?? 0) + (mem.free_memory ?? 0) + (mem.wasted_memory ?? 0),
              ));
            }
          }
        } catch {}
      }

      // Optional module recycling: discard the WASM module after N requests.
      // Disabled by default (0) — the CGI persistent module patch keeps PHP
      // alive across requests without needing table growth, so recycling is unnecessary.
      // Each recycle forces a full cold start (tar extraction + OPcache rebuild).
      const maxRequests = parseInt(env.WORKER_MAX_REQUESTS || '0', 10);
      if (maxRequests > 0 && requestCount >= maxRequests) {
        if (env.MEMORY_DEBUG === 'true') {
          console.log(`[wasm] Recycling module after ${requestCount} requests`);
        }
        php = null;
        requestCount = 0;
      }

      return new Response(ssrResponse.body, {
        status: ssrResponse.status,
        statusText: ssrResponse.statusText,
        headers,
      });
    } catch (error) {
      // WASM RuntimeError may propagate past PhpCgiBase's error handler
      // (e.g. during Asyncify unwind/rewind). Recycle the module for recovery.
      if (error instanceof Error && error.message.includes('table index')) {
        console.error('[wasm] Fatal table corruption, recycling module:', error.message);
        php = null;
        requestCount = 0;
      }

      const message =
        error instanceof Error ? error.message : 'Unknown error';
      console.error('Worker error:', message);
      return new Response(`Internal Server Error: ${message}`, {
        status: 500,
        headers: { 'Content-Type': 'text/plain' },
      });
    }
  },
};
