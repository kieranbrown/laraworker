/**
 * Build script: packages Laravel application files into a .tar for Cloudflare Static Assets.
 *
 * Usage: node .laraworker/build-app.mjs
 *
 * Output: .laraworker/dist/assets/app.tar.gz
 *
 * Configuration is read from .laraworker/build-config.json (generated by laraworker:build).
 */

import { readdirSync, statSync, readFileSync, mkdirSync, writeFileSync, copyFileSync, existsSync, rmSync } from 'node:fs';
import { gzipSync } from 'node:zlib';
import { join, relative, resolve } from 'node:path';
import { execSync, execFile } from 'node:child_process';
import { promisify } from 'node:util';
import { createHash } from 'node:crypto';
import { cpus } from 'node:os';

const execFileAsync = promisify(execFile);

const ROOT = resolve(import.meta.dirname, '..');
const DIST_DIR = resolve(import.meta.dirname, 'dist', 'assets');
const OUTPUT = join(DIST_DIR, 'app.tar.gz');

// Read build config (generated by php artisan laraworker:build)
const configPath = join(import.meta.dirname, 'build-config.json');
let config = {};
if (existsSync(configPath)) {
  config = JSON.parse(readFileSync(configPath, 'utf8'));
}

const VENDOR_STAGING_DIR = config.vendor_staging_dir;

let INCLUDE_DIRS = config.include_dirs ?? [
  'app', 'bootstrap', 'config', 'database',
  'routes', 'resources/views', 'vendor',
];

// Use staging vendor if available (production-only, no-dev)
if (VENDOR_STAGING_DIR && existsSync(VENDOR_STAGING_DIR)) {
  console.log('  Using staging vendor (production-only, no-dev)...');
  // Filter out vendor from include_dirs - we'll add staging vendor separately
  INCLUDE_DIRS = INCLUDE_DIRS.filter(d => d !== 'vendor');
} else {
  console.warn('  Warning: No staging vendor found, using main vendor (may include dev packages)');
}

const INCLUDE_FILES = config.include_files ?? [
  'public/index.php', 'artisan', 'composer.json',
];

// Default exclude patterns — always applied. User config patterns merge with these.
const DEFAULT_EXCLUDE_PATTERNS = [
  // VCS & CI
  '/\\.git\\//',
  '/\\.github\\//',
  '/\\/node_modules\\//',
  '/\\/\\.DS_Store$/',

  // Vendor tests, examples, benchmarks, fixtures (dev-only)
  '/vendor\\/[^/]+\\/[^/]+\\/tests\\//',
  '/vendor\\/[^/]+\\/[^/]+\\/Tests\\//',
  '/vendor\\/[^/]+\\/[^/]+\\/test\\//',
  '/vendor\\/[^/]+\\/[^/]+\\/examples?\\//',
  '/vendor\\/[^/]+\\/[^/]+\\/benchmarks?\\//',
  '/vendor\\/[^/]+\\/[^/]+\\/fixtures?\\//',

  // Vendor docs & metadata
  '/vendor\\/[^/]+\\/[^/]+\\/docs\\//',
  '/vendor\\/[^/]+\\/[^/]+\\/[^/]+\\.md$/',
  '/vendor\\/[^/]+\\/[^/]+\\/CHANGELOG/',
  '/vendor\\/[^/]+\\/[^/]+\\/UPGRADE/',

  // Metadata files not needed at runtime
  '/vendor\\/[^/]+\\/[^/]+\\/LICENSE/',
  '/vendor\\/[^/]+\\/[^/]+\\/CREDITS/',
  '/vendor\\/[^/]+\\/[^/]+\\/NOTICE/',
  '/vendor\\/[^/]+\\/[^/]+\\/README/',
  '/vendor\\/[^/]+\\/[^/]+\\/AUTHORS/',
  '/vendor\\/[^/]+\\/[^/]+\\/CONTRIBUTORS/',
  '/vendor\\/[^/]+\\/[^/]+\\/BACKERS/',

  // Vendor tooling configs
  '/vendor\\/[^/]+\\/[^/]+\\/phpunit\\.xml/',
  '/vendor\\/[^/]+\\/[^/]+\\/\\.editorconfig$/',
  '/vendor\\/[^/]+\\/[^/]+\\/\\.gitattributes$/',
  '/vendor\\/[^/]+\\/[^/]+\\/\\.gitignore$/',
  '/vendor\\/[^/]+\\/[^/]+\\/phpstan/',
  '/vendor\\/[^/]+\\/[^/]+\\/psalm/',
  '/vendor\\/[^/]+\\/[^/]+\\/\\.php-cs-fixer/',
  '/vendor\\/[^/]+\\/[^/]+\\/\\.php_cs/',
  '/vendor\\/[^/]+\\/[^/]+\\/Makefile$/',
  '/vendor\\/[^/]+\\/[^/]+\\/\\.styleci\\.yml$/',
  '/vendor\\/[^/]+\\/[^/]+\\/docker-compose/',
  '/vendor\\/[^/]+\\/[^/]+\\/Dockerfile$/',
  '/vendor\\/[^/]+\\/[^/]+\\/rector\\.php$/',
  '/vendor\\/[^/]+\\/[^/]+\\/pint\\.json$/',
  '/vendor\\/[^/]+\\/[^/]+\\/infection\\.json/',
  '/vendor\\/[^/]+\\/[^/]+\\/box\\.json/',
  '/vendor\\/[^/]+\\/[^/]+\\/phpbench\\.json/',
  '/vendor\\/[^/]+\\/[^/]+\\/\\.phpunit\\.result\\.cache$/',
  '/vendor\\/[^/]+\\/[^/]+\\/\\.phpunit\\.cache\\//',

  // CI service configs
  '/vendor\\/[^/]+\\/[^/]+\\/\\.scrutinizer\\.yml$/',
  '/vendor\\/[^/]+\\/[^/]+\\/codecov\\.ya?ml$/',
  '/vendor\\/[^/]+\\/[^/]+\\/\\.coveralls\\.yml$/',
  '/vendor\\/[^/]+\\/[^/]+\\/\\.gitlab-ci\\.yml$/',
  '/vendor\\/[^/]+\\/[^/]+\\/crowdin\\.ya?ml$/',

  // Vendor CLI scripts (not useful in Workers)
  '/vendor\\/bin\\//',
  '/vendor\\/[^/]+\\/[^/]+\\/bin\\//',

  // Schema and validation files (not needed at runtime)
  '/vendor\\/.*\\.xsd$/',
  '/vendor\\/.*\\.dtd$/',

  // Composer metadata (autoloader doesn't need installed.json at runtime)
  '/vendor\\/composer\\/installed\\.json$/',

  // Package manager files in vendor (PHP packages don't need these)
  '/vendor\\/.*\\/package-lock\\.json$/',
  '/vendor\\/[^/]+\\/[^/]+\\/package\\.json$/',
  '/vendor\\/[^/]+\\/[^/]+\\/yarn\\.lock$/',
  '/vendor\\/[^/]+\\/[^/]+\\/bun\\.lock$/',

  // Stub/template files (artisan make:* commands don't work in Workers)
  '/vendor\\/.*\\.stub$/',

  // Symfony translation/locale resources (large, unused in typical Workers apps)
  '/vendor\\/symfony\\/[^/]+\\/Resources\\/translations\\//',

  // Symfony Resources not needed at runtime
  '/vendor\\/symfony\\/[^/]+\\/Resources\\/schemas\\//',
  '/vendor\\/symfony\\/[^/]+\\/Resources\\/bin\\//',
  '/vendor\\/symfony\\/http-kernel\\/Resources\\/welcome/',

  // Symfony polyfill stubs for PHP ≤ 8.4 (target runtime is PHP 8.5; native classes exist)
  '/vendor\\/symfony\\/polyfill-php[0-9]+\\/Resources\\/stubs\\//',

  // Laravel framework exception renderer build artifacts (APP_DEBUG=false in production)
  '/vendor\\/laravel\\/framework\\/src\\/Illuminate\\/Foundation\\/resources\\/exceptions\\/renderer\\/dist\\//',
  '/vendor\\/laravel\\/framework\\/src\\/Illuminate\\/Foundation\\/resources\\/exceptions\\/renderer\\/package/',
  '/vendor\\/laravel\\/framework\\/src\\/Illuminate\\/Foundation\\/resources\\/exceptions\\/renderer\\/vite/',

  // NOTE: Illuminate/Testing/ is NOT excluded — FoundationServiceProvider
  // unconditionally registers ParallelTestingServiceProvider at boot.

  // Laravel framework fixtures & stubs (dev-only)
  '/vendor\\/laravel\\/framework\\/src\\/Illuminate\\/Foundation\\/Console\\/stubs\\//',

  // Misc dev files in vendor
  '/vendor\\/[^/]+\\/[^/]+\\/\\.github\\//',
  '/vendor\\/[^/]+\\/[^/]+\\/\\.travis\\.yml$/',
  '/vendor\\/[^/]+\\/[^/]+\\/appveyor\\.yml$/',
  '/vendor\\/[^/]+\\/[^/]+\\/CONTRIBUTING/',
  '/vendor\\/[^/]+\\/[^/]+\\/SECURITY\\.md$/',
];

const toRegExp = p => new RegExp(p.replace(/^\//, '').replace(/\/$/, ''));
const defaultPatterns = DEFAULT_EXCLUDE_PATTERNS.map(toRegExp);
const userPatterns = (config.exclude_patterns ?? []).map(toRegExp);
const EXCLUDE_PATTERNS = [...defaultPatterns, ...userPatterns];

const EXTENSIONS = config.extensions ?? { mbstring: true, openssl: true };
// Default to false for initial build to avoid timeout - user can enable in build-config.json
const STRIP_WHITESPACE = config.strip_whitespace ?? false;
const STRIP_PROVIDERS = config.strip_providers ?? [];

/**
 * Generate PHP stub functions for missing extensions.
 * These stubs provide minimal implementations when extensions are not enabled.
 */
function generatePhpStubs(extensions) {
  const stubs = [];

  // Enable error reporting so PHP errors appear in Cloudflare logs (stderr).
  // display_errors sends output to stderr in CGI mode, not to the HTTP response body.
  stubs.push(`
// Report PHP errors to stderr (visible in Cloudflare Workers logs)
error_reporting(E_ALL);
ini_set('display_errors', 'stderr');
ini_set('display_startup_errors', '1');`);

  // umask fix for MEMFS - always needed
  stubs.push(`
// Fix for MEMFS umask issue
if (!function_exists('umask')) {
    function umask($mask = null) {
        return 0022;
    }
}`);

  // iconv stubs - only if iconv extension is not enabled
  if (!extensions.iconv) {
    stubs.push(`
// iconv stub functions
if (!function_exists('iconv')) {
    function iconv($from_encoding, $to_encoding, $string) {
        return $string;
    }
}
if (!function_exists('iconv_strlen')) {
    function iconv_strlen($string, $encoding = null) {
        return strlen($string);
    }
}
if (!function_exists('iconv_substr')) {
    function iconv_substr($string, $offset, $length = null, $encoding = null) {
        return substr($string, $offset, $length);
    }
}
if (!function_exists('iconv_strpos')) {
    function iconv_strpos($haystack, $needle, $offset = 0, $encoding = null) {
        return strpos($haystack, $needle, $offset);
    }
}`);
  }

  // mbstring stubs - only if mbstring extension is not enabled
  if (!extensions.mbstring) {
    stubs.push(`
// mbstring stub functions
if (!function_exists('mb_split')) {
    function mb_split($pattern, $string, $limit = -1) {
        return preg_split('/' . $pattern . '/', $string, $limit);
    }
}
if (!function_exists('mb_strlen')) {
    function mb_strlen($string, $encoding = null) {
        return strlen($string);
    }
}
if (!function_exists('mb_substr')) {
    function mb_substr($string, $start, $length = null, $encoding = null) {
        return substr($string, $start, $length);
    }
}
if (!function_exists('mb_strpos')) {
    function mb_strpos($haystack, $needle, $offset = 0, $encoding = null) {
        return strpos($haystack, $needle, $offset);
    }
}`);
  }

  // filter stubs - only if filter extension is not enabled
  if (!extensions.filter) {
    stubs.push(`
// filter extension constants
if (!defined('FILTER_VALIDATE_INT')) {
    define('FILTER_VALIDATE_INT', 257);
    define('FILTER_VALIDATE_BOOLEAN', 258);
    define('FILTER_VALIDATE_FLOAT', 259);
    define('FILTER_VALIDATE_EMAIL', 274);
    define('FILTER_VALIDATE_URL', 273);
    define('FILTER_VALIDATE_IP', 275);
    define('FILTER_VALIDATE_MAC', 281);
    define('FILTER_VALIDATE_DOMAIN', 277);
    define('FILTER_VALIDATE_REGEXP', 272);
    define('FILTER_DEFAULT', 516);
    define('FILTER_UNSAFE_RAW', 516);
    define('FILTER_SANITIZE_STRING', 513);
    define('FILTER_SANITIZE_STRIPPED', 513);
    define('FILTER_SANITIZE_ENCODED', 514);
    define('FILTER_SANITIZE_SPECIAL_CHARS', 515);
    define('FILTER_SANITIZE_NUMBER_INT', 519);
    define('FILTER_SANITIZE_NUMBER_FLOAT', 520);
    define('FILTER_SANITIZE_URL', 518);
    define('FILTER_SANITIZE_EMAIL', 517);
    define('FILTER_SANITIZE_ADD_SLASHES', 523);
    define('FILTER_SANITIZE_FULL_SPECIAL_CHARS', 522);
    define('FILTER_CALLBACK', 1024);
    define('FILTER_FLAG_NONE', 0);
    define('FILTER_FLAG_ALLOW_OCTAL', 1);
    define('FILTER_FLAG_ALLOW_HEX', 2);
    define('FILTER_FLAG_STRIP_LOW', 4);
    define('FILTER_FLAG_STRIP_HIGH', 8);
    define('FILTER_FLAG_ENCODE_LOW', 16);
    define('FILTER_FLAG_ENCODE_HIGH', 32);
    define('FILTER_FLAG_ENCODE_AMP', 64);
    define('FILTER_FLAG_NO_ENCODE_QUOTES', 128);
    define('FILTER_FLAG_EMPTY_STRING_NULL', 256);
    define('FILTER_FLAG_STRIP_BACKTICK', 512);
    define('FILTER_FLAG_ALLOW_FRACTION', 1024);
    define('FILTER_FLAG_ALLOW_THOUSAND', 2048);
    define('FILTER_FLAG_ALLOW_SCIENTIFIC', 4096);
    define('FILTER_FLAG_PATH_REQUIRED', 262144);
    define('FILTER_FLAG_QUERY_REQUIRED', 524288);
    define('FILTER_FLAG_IPV4', 1048576);
    define('FILTER_FLAG_IPV6', 2097152);
    define('FILTER_FLAG_NO_RES_RANGE', 4194304);
    define('FILTER_FLAG_NO_PRIV_RANGE', 8388608);
    define('FILTER_FLAG_HOSTNAME', 1048576);
    define('FILTER_FLAG_EMAIL_UNICODE', 1048576);
    define('FILTER_REQUIRE_SCALAR', 33554432);
    define('FILTER_REQUIRE_ARRAY', 16777216);
    define('FILTER_FORCE_ARRAY', 67108864);
    define('FILTER_NULL_ON_FAILURE', 134217728);
    define('INPUT_GET', 1);
    define('INPUT_POST', 2);
    define('INPUT_COOKIE', 4);
    define('INPUT_SERVER', 5);
    define('INPUT_ENV', 16);
}
if (!function_exists('filter_var')) {
    function filter_var($value, $filter = 516, $options = 0) {
        if (is_array($options)) {
            $flags = $options['flags'] ?? 0;
            $opts = $options['options'] ?? [];
        } else {
            $flags = $options;
            $opts = [];
        }
        switch ($filter) {
            case 257: // FILTER_VALIDATE_INT
                $min = $opts['min_range'] ?? null;
                $max = $opts['max_range'] ?? null;
                if (is_int($value)) { $v = $value; }
                elseif (is_string($value) && preg_match('/^[+-]?\\d+$/', trim($value))) { $v = (int) trim($value); }
                else { return false; }
                if ($min !== null && $v < $min) return false;
                if ($max !== null && $v > $max) return false;
                return $v;
            case 259: // FILTER_VALIDATE_FLOAT
                if (is_float($value) || is_int($value)) return (float) $value;
                if (is_string($value) && is_numeric(trim($value))) return (float) trim($value);
                return false;
            case 258: // FILTER_VALIDATE_BOOLEAN
                if ($value === true || $value === 1 || $value === '1' || strtolower((string)$value) === 'true' || strtolower((string)$value) === 'on' || strtolower((string)$value) === 'yes') return true;
                if ($value === false || $value === 0 || $value === '0' || $value === '' || strtolower((string)$value) === 'false' || strtolower((string)$value) === 'off' || strtolower((string)$value) === 'no') return false;
                if ($flags & 134217728) return null;
                return false;
            case 274: // FILTER_VALIDATE_EMAIL
                return preg_match('/^[^@\\s]+@[^@\\s]+\\.[^@\\s]+$/', (string) $value) ? (string) $value : false;
            case 273: // FILTER_VALIDATE_URL
                return preg_match('/^https?:\\/\\/.+/i', (string) $value) ? (string) $value : false;
            case 275: // FILTER_VALIDATE_IP
                $v = (string) $value;
                if (($flags & 1048576) && filter_var_ipv4($v)) return $v;
                if (($flags & 2097152) && filter_var_ipv6($v)) return $v;
                if (!$flags || ($flags & ~(4194304|8388608|1048576|2097152)) === 0) {
                    if (filter_var_ipv4($v) || filter_var_ipv6($v)) return $v;
                }
                return false;
            case 272: // FILTER_VALIDATE_REGEXP
                $regexp = $opts['regexp'] ?? '';
                return preg_match($regexp, (string) $value) ? (string) $value : false;
            case 519: // FILTER_SANITIZE_NUMBER_INT
                return preg_replace('/[^0-9+\\-]/', '', (string) $value);
            case 520: // FILTER_SANITIZE_NUMBER_FLOAT
                $allow = '';
                if ($flags & 1024) $allow .= '.';
                if ($flags & 2048) $allow .= ',';
                if ($flags & 4096) $allow .= 'eE';
                return preg_replace('/[^0-9+\\-' . preg_quote($allow, '/') . ']/', '', (string) $value);
            case 515: // FILTER_SANITIZE_SPECIAL_CHARS
            case 522: // FILTER_SANITIZE_FULL_SPECIAL_CHARS
                return htmlspecialchars((string) $value, ENT_QUOTES | ENT_SUBSTITUTE, 'UTF-8');
            case 518: // FILTER_SANITIZE_URL
                return (string) $value;
            case 517: // FILTER_SANITIZE_EMAIL
                return (string) $value;
            case 514: // FILTER_SANITIZE_ENCODED
                return rawurlencode((string) $value);
            case 523: // FILTER_SANITIZE_ADD_SLASHES
                return addslashes((string) $value);
            case 513: // FILTER_SANITIZE_STRING
                return strip_tags((string) $value);
            case 1024: // FILTER_CALLBACK
                $callback = $opts['callback'] ?? $opts ?? null;
                return is_callable($callback) ? $callback($value) : $value;
            default: // FILTER_DEFAULT
                return (string) $value;
        }
    }
    function filter_var_ipv4($ip) { return preg_match('/^(\\d{1,3}\\.){3}\\d{1,3}$/', $ip) && !preg_match('/\\d{4,}/', $ip); }
    function filter_var_ipv6($ip) { return strpos($ip, ':') !== false && preg_match('/^[0-9a-fA-F:]+$/', str_replace(['[', ']'], '', $ip)); }
}
if (!function_exists('filter_input')) {
    function filter_input($type, $var_name, $filter = 516, $options = 0) {
        switch ($type) {
            case 1: $source = $_GET ?? []; break;
            case 2: $source = $_POST ?? []; break;
            case 4: $source = $_COOKIE ?? []; break;
            case 5: $source = $_SERVER ?? []; break;
            case 16: $source = $_ENV ?? []; break;
            default: return null;
        }
        if (!isset($source[$var_name])) return null;
        return filter_var($source[$var_name], $filter, $options);
    }
}
if (!function_exists('filter_has_var')) {
    function filter_has_var($type, $var_name) {
        switch ($type) {
            case 1: return isset($_GET[$var_name]);
            case 2: return isset($_POST[$var_name]);
            case 4: return isset($_COOKIE[$var_name]);
            case 5: return isset($_SERVER[$var_name]);
            case 16: return isset($_ENV[$var_name]);
            default: return false;
        }
    }
}
if (!function_exists('filter_input_array')) {
    function filter_input_array($type, $options = null, $add_empty = true) {
        switch ($type) {
            case 1: $source = $_GET ?? []; break;
            case 2: $source = $_POST ?? []; break;
            case 4: $source = $_COOKIE ?? []; break;
            case 5: $source = $_SERVER ?? []; break;
            case 16: $source = $_ENV ?? []; break;
            default: return null;
        }
        if ($options === null || is_int($options)) {
            $result = [];
            foreach ($source as $k => $v) {
                $result[$k] = is_int($options) ? filter_var($v, $options) : $v;
            }
            return $result;
        }
        return $source;
    }
}
if (!function_exists('filter_var_array')) {
    function filter_var_array($array, $options = null, $add_empty = true) {
        if ($options === null || is_int($options)) {
            $result = [];
            foreach ($array as $k => $v) {
                $result[$k] = is_int($options) ? filter_var($v, $options) : $v;
            }
            return $result;
        }
        return $array;
    }
}
if (!function_exists('filter_list')) {
    function filter_list() {
        return ['int', 'boolean', 'float', 'validate_regexp', 'validate_domain', 'validate_url', 'validate_email', 'validate_ip', 'validate_mac', 'string', 'stripped', 'encoded', 'special_chars', 'full_special_chars', 'unsafe_raw', 'email', 'url', 'number_int', 'number_float', 'add_slashes', 'callback'];
    }
}
if (!function_exists('filter_id')) {
    function filter_id($name) {
        $map = ['int' => 257, 'boolean' => 258, 'float' => 259, 'validate_regexp' => 272, 'validate_url' => 273, 'validate_email' => 274, 'validate_ip' => 275, 'string' => 513, 'stripped' => 513, 'encoded' => 514, 'special_chars' => 515, 'unsafe_raw' => 516, 'email' => 517, 'url' => 518, 'number_int' => 519, 'number_float' => 520, 'full_special_chars' => 522, 'add_slashes' => 523, 'callback' => 1024];
        return $map[$name] ?? false;
    }
}`);
  }

  // ctype stubs - only if ctype extension is not enabled
  if (!extensions.ctype) {
    stubs.push(`
// ctype stub functions
if (!function_exists('ctype_alnum')) {
    function ctype_alnum($text) { return is_string($text) && $text !== '' && preg_match('/^[a-zA-Z0-9]+$/', $text); }
    function ctype_alpha($text) { return is_string($text) && $text !== '' && preg_match('/^[a-zA-Z]+$/', $text); }
    function ctype_cntrl($text) { return is_string($text) && $text !== '' && preg_match('/^[\\x00-\\x1f\\x7f]+$/', $text); }
    function ctype_digit($text) { return is_string($text) && $text !== '' && preg_match('/^[0-9]+$/', $text); }
    function ctype_graph($text) { return is_string($text) && $text !== '' && preg_match('/^[\\x21-\\x7e]+$/', $text); }
    function ctype_lower($text) { return is_string($text) && $text !== '' && preg_match('/^[a-z]+$/', $text); }
    function ctype_print($text) { return is_string($text) && $text !== '' && preg_match('/^[\\x20-\\x7e]+$/', $text); }
    function ctype_punct($text) { return is_string($text) && $text !== '' && preg_match('/^[^a-zA-Z0-9\\s]+$/', $text); }
    function ctype_space($text) { return is_string($text) && $text !== '' && preg_match('/^[\\s]+$/', $text); }
    function ctype_upper($text) { return is_string($text) && $text !== '' && preg_match('/^[A-Z]+$/', $text); }
    function ctype_xdigit($text) { return is_string($text) && $text !== '' && preg_match('/^[0-9a-fA-F]+$/', $text); }
}`);
  }

  // tokenizer stubs - only if tokenizer extension is not enabled
  if (!extensions.tokenizer) {
    stubs.push(`
// tokenizer stub constants
if (!defined('T_OPEN_TAG')) {
    define('T_OPEN_TAG', 379);
    define('T_OPEN_TAG_WITH_ECHO', 380);
    define('T_CLOSE_TAG', 381);
    define('T_WHITESPACE', 396);
    define('T_COMMENT', 397);
    define('T_DOC_COMMENT', 398);
    define('T_STRING', 319);
    define('T_VARIABLE', 320);
    define('T_INLINE_HTML', 323);
    define('T_ECHO', 328);
    define('T_CONSTANT_ENCAPSED_STRING', 323);
    define('T_LNUMBER', 311);
    define('T_DNUMBER', 312);
    define('TOKEN_PARSE', 1);
}
if (!function_exists('token_get_all')) {
    /**
     * Minimal tokenizer that splits PHP open/close tags from inline HTML.
     * Required by Blade compiler which tokenizes compiled templates to
     * separate T_INLINE_HTML (for Blade directives) from PHP code blocks.
     */
    function token_get_all($code, $flags = 0) {
        $tokens = [];
        $line = 1;
        $pos = 0;
        $len = strlen($code);
        while ($pos < $len) {
            $nextOpen = strpos($code, '<?', $pos);
            if ($nextOpen === false) {
                $html = substr($code, $pos);
                if ($html !== '') {
                    $tokens[] = [T_INLINE_HTML, $html, $line];
                    $line += substr_count($html, "\\n");
                }
                break;
            }
            if ($nextOpen > $pos) {
                $html = substr($code, $pos, $nextOpen - $pos);
                $tokens[] = [T_INLINE_HTML, $html, $line];
                $line += substr_count($html, "\\n");
            }
            if (substr($code, $nextOpen, 5) === '<?php' && ($nextOpen + 5 >= $len || !ctype_alnum($code[$nextOpen + 5]))) {
                $tagEnd = $nextOpen + 5;
                if ($tagEnd < $len && ($code[$tagEnd] === ' ' || $code[$tagEnd] === "\\n" || $code[$tagEnd] === "\\r" || $code[$tagEnd] === "\\t")) {
                    $tagEnd++;
                }
                $tokens[] = [T_OPEN_TAG, substr($code, $nextOpen, $tagEnd - $nextOpen), $line];
                $pos = $tagEnd;
            } elseif (substr($code, $nextOpen, 3) === '<?=') {
                $tokens[] = [T_OPEN_TAG_WITH_ECHO, '<?= ', $line];
                $pos = $nextOpen + 3;
                if ($pos < $len && $code[$pos] === ' ') $pos++;
            } else {
                $tokens[] = [T_INLINE_HTML, '<?', $line];
                $pos = $nextOpen + 2;
                continue;
            }
            $closePos = strpos($code, '?>', $pos);
            if ($closePos === false) {
                $phpCode = substr($code, $pos);
                if ($phpCode !== '') {
                    $tokens[] = [T_STRING, $phpCode, $line];
                    $line += substr_count($phpCode, "\\n");
                }
                break;
            }
            $phpCode = substr($code, $pos, $closePos - $pos);
            if ($phpCode !== '') {
                $tokens[] = [T_STRING, $phpCode, $line];
                $line += substr_count($phpCode, "\\n");
            }
            $closeEnd = $closePos + 2;
            if ($closeEnd < $len && $code[$closeEnd] === "\\n") $closeEnd++;
            $closeTag = substr($code, $closePos, $closeEnd - $closePos);
            $tokens[] = [T_CLOSE_TAG, $closeTag, $line];
            $line += substr_count($closeTag, "\\n");
            $pos = $closeEnd;
        }
        return $tokens;
    }
}
if (!function_exists('token_name')) {
    function token_name($id) {
        $names = [379 => 'T_OPEN_TAG', 380 => 'T_OPEN_TAG_WITH_ECHO', 381 => 'T_CLOSE_TAG', 396 => 'T_WHITESPACE', 397 => 'T_COMMENT', 398 => 'T_DOC_COMMENT', 319 => 'T_STRING', 320 => 'T_VARIABLE', 323 => 'T_INLINE_HTML', 328 => 'T_ECHO'];
        return $names[$id] ?? 'UNKNOWN';
    }
}`);
  }

  // openssl stubs - only if openssl extension is not enabled
  if (!extensions.openssl) {
    stubs.push(`
// openssl stub functions (NOT SECURE - for development only)
if (!function_exists('openssl_encrypt')) {
    function openssl_encrypt($data, $cipher_algo, $passphrase, $options = 0, $iv = '', &$tag = null, $aad = '', $tag_length = 16) {
        // Simple XOR encryption - NOT secure, only for testing
        $key = substr($passphrase, 0, 32);
        $result = '';
        for ($i = 0; $i < strlen($data); $i++) {
            $result .= $data[$i] ^ $key[$i % strlen($key)];
        }
        return base64_encode($result);
    }
}
if (!function_exists('openssl_decrypt')) {
    function openssl_decrypt($data, $cipher_algo, $passphrase, $options = 0, $iv = '', $tag = null, $aad = '') {
        // Simple XOR decryption - NOT secure, only for testing
        $key = substr($passphrase, 0, 32);
        $decoded = base64_decode($data);
        $result = '';
        for ($i = 0; $i < strlen($decoded); $i++) {
            $result .= $decoded[$i] ^ $key[$i % strlen($key)];
        }
        return $result;
    }
}
if (!function_exists('openssl_random_pseudo_bytes')) {
    function openssl_random_pseudo_bytes($length, &$strong_result = null) {
        $strong_result = false;
        return random_bytes($length);
    }
}
if (!function_exists('openssl_cipher_iv_length')) {
    function openssl_cipher_iv_length($cipher_algo) {
        return 16;
    }
}`);
  }

  // Include class preloader if it exists (generated by laraworker:build)
  stubs.push(`
// Class preloader — eliminates per-class autoloader lookups in WASM
if (file_exists('/app/bootstrap/preload.php')) {
    require_once '/app/bootstrap/preload.php';
}`);

  return '<?php\n// Auto-generated PHP stubs for missing extensions\n// Extensions enabled: ' + JSON.stringify(extensions) + '\n' + stubs.join('\n');
}

// Cache directory for stripped PHP files — persists between builds
const STRIP_CACHE_DIR = join(import.meta.dirname, '.strip-cache');
// Number of parallel php -w workers
const STRIP_CONCURRENCY = Math.max(4, cpus().length);

/**
 * Run async tasks with a bounded concurrency pool.
 */
async function mapConcurrent(items, fn, concurrency) {
  const results = new Array(items.length);
  let index = 0;
  async function worker() {
    while (index < items.length) {
      const i = index++;
      results[i] = await fn(items[i], i);
    }
  }
  await Promise.all(Array.from({ length: concurrency }, worker));
  return results;
}

/**
 * Strip whitespace from a single PHP file asynchronously.
 * Uses a content-hash cache to skip unchanged files.
 * Returns stripped Buffer or null on failure.
 */
async function stripPhpFileAsync(filePath, originalContent) {
  const hash = createHash('sha256').update(originalContent).digest('hex');
  const cachePath = join(STRIP_CACHE_DIR, hash);

  // Cache hit — return without spawning a PHP process
  if (existsSync(cachePath)) {
    return { content: readFileSync(cachePath), fromCache: true };
  }

  try {
    const { stdout } = await execFileAsync('php', ['-w', filePath], {
      encoding: 'buffer',
      timeout: 30_000,
      maxBuffer: 10 * 1024 * 1024,
    });

    if (stdout && stdout.length > 0) {
      mkdirSync(STRIP_CACHE_DIR, { recursive: true });
      writeFileSync(cachePath, stdout);
      return { content: stdout, fromCache: false };
    }
  } catch {
    // php -w failed — skip this file
  }

  return null;
}

/**
 * Pre-process all PHP files in parallel.
 * Returns a Map of fullPath → stripped Buffer.
 */
async function stripPhpFilesParallel(files) {
  const phpFiles = files.filter(
    f => !f.isDir && f.path.endsWith('.php') && !f.path.startsWith('php-stubs'),
  );

  const startTime = Date.now();
  let cacheHits = 0;
  const strippedMap = new Map();

  await mapConcurrent(phpFiles, async (file) => {
    const original = readFileSync(file.fullPath);
    const result = await stripPhpFileAsync(file.fullPath, original);

    if (result) {
      const saved = original.length - result.content.length;
      if (saved > 0) {
        strippedMap.set(file.fullPath, result.content);
        if (result.fromCache) {
          cacheHits++;
        }
      }
    }
  }, STRIP_CONCURRENCY);

  const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
  console.log(`    Done in ${elapsed}s (${cacheHits}/${phpFiles.length} cache hits, ${strippedMap.size} files reduced)`);

  return strippedMap;
}

/**
 * Collect all files from a directory recursively.
 */
function collectFiles(dir, basePath = '') {
  const results = [];
  const entries = readdirSync(dir, { withFileTypes: true });

  for (const entry of entries) {
    const fullPath = join(dir, entry.name);
    const relPath = basePath ? `${basePath}/${entry.name}` : entry.name;

    const testPath = '/' + relPath;
    if (EXCLUDE_PATTERNS.some(p => p.test(testPath))) {
      continue;
    }

    if (entry.isDirectory()) {
      results.push({ path: relPath + '/', isDir: true });
      results.push(...collectFiles(fullPath, relPath));
    } else if (entry.isFile()) {
      results.push({ path: relPath, isDir: false, fullPath });
    }
  }

  return results;
}

/**
 * Create a 512-byte tar header for a file or directory.
 */
function createTarHeader(path, size, isDir) {
  const header = new Uint8Array(512);
  const encoder = new TextEncoder();

  let name = path;
  let ustarPrefix = '';

  if (name.length > 100) {
    const splitAt = name.lastIndexOf('/', 155);
    if (splitAt > 0) {
      ustarPrefix = name.substring(0, splitAt);
      name = name.substring(splitAt + 1);
    }
  }

  header.set(encoder.encode(name.substring(0, 100)), 0);

  const mode = isDir ? '0000755' : '0000644';
  header.set(encoder.encode(mode + '\0'), 100);

  header.set(encoder.encode('0001000\0'), 108);
  header.set(encoder.encode('0001000\0'), 116);

  const sizeStr = size.toString(8).padStart(11, '0');
  header.set(encoder.encode(sizeStr + '\0'), 124);

  const mtime = Math.floor(Date.now() / 1000).toString(8).padStart(11, '0');
  header.set(encoder.encode(mtime + '\0'), 136);

  header.set(encoder.encode('        '), 148);

  header[156] = isDir ? 53 : 48;

  header.set(encoder.encode('ustar\0'), 257);
  header.set(encoder.encode('00'), 263);

  if (ustarPrefix) {
    header.set(encoder.encode(ustarPrefix.substring(0, 155)), 345);
  }

  let checksum = 0;
  for (let i = 0; i < 512; i++) {
    checksum += header[i];
  }
  const checksumStr = checksum.toString(8).padStart(6, '0') + '\0 ';
  header.set(encoder.encode(checksumStr), 148);

  return header;
}

/**
 * Create a tar archive from collected files.
 * When strippedContents is provided, pre-stripped PHP content is used directly.
 */
function createTar(files, { stripWhitespace = false, strippedContents = new Map() } = {}) {
  const chunks = [];
  let strippedCount = 0;
  let bytesSaved = 0;

  for (const file of files) {
    if (file.isDir) {
      chunks.push(createTarHeader(file.path, 0, true));
    } else {
      let content = readFileSync(file.fullPath);

      // Use pre-stripped content if available
      if (stripWhitespace && file.path.endsWith('.php') && !file.path.startsWith('php-stubs')) {
        const stripped = strippedContents.get(file.fullPath);
        if (stripped && stripped.length > 0) {
          const saved = content.length - stripped.length;
          if (saved > 0) {
            bytesSaved += saved;
            strippedCount++;
            content = stripped;
          }
        }
      }

      chunks.push(createTarHeader(file.path, content.length, false));
      chunks.push(new Uint8Array(content));

      const remainder = content.length % 512;
      if (remainder > 0) {
        chunks.push(new Uint8Array(512 - remainder));
      }
    }
  }

  chunks.push(new Uint8Array(1024));

  const totalSize = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
  const result = new Uint8Array(totalSize);
  let offset = 0;
  for (const chunk of chunks) {
    result.set(chunk, offset);
    offset += chunk.length;
  }

  return { tar: result, strippedCount, bytesSaved };
}

const fmt = (bytes) => {
  if (bytes >= 1024 * 1024) return (bytes / 1024 / 1024).toFixed(2) + ' MB';
  return (bytes / 1024).toFixed(0) + ' KB';
};

// --- Main ---

console.log('  Starting build-app.mjs...');
console.log(`  ROOT: ${ROOT}`);
console.log(`  DIST_DIR: ${DIST_DIR}`);

if (existsSync(DIST_DIR)) {
  console.log('  Cleaning dist directory...');
  rmSync(DIST_DIR, { recursive: true });
}

console.log('Building Laravel app tar...');

const allFiles = [];

for (const dir of INCLUDE_DIRS) {
  const fullDir = join(ROOT, dir);
  if (existsSync(fullDir)) {
    allFiles.push({ path: dir + '/', isDir: true });
    allFiles.push(...collectFiles(fullDir, dir));
  } else {
    console.warn(`  Warning: ${dir} not found, skipping`);
  }
}

for (const file of INCLUDE_FILES) {
  const fullPath = join(ROOT, file);
  if (existsSync(fullPath)) {
    const parts = file.split('/');
    if (parts.length > 1) {
      let dirPath = '';
      for (let i = 0; i < parts.length - 1; i++) {
        dirPath += (dirPath ? '/' : '') + parts[i];
        if (!allFiles.some(f => f.path === dirPath + '/')) {
          allFiles.push({ path: dirPath + '/', isDir: true });
        }
      }
    }
    allFiles.push({ path: file, isDir: false, fullPath });
  } else {
    console.warn(`  Warning: ${file} not found, skipping`);
  }
}

// Add staging vendor files if available
if (VENDOR_STAGING_DIR && existsSync(VENDOR_STAGING_DIR)) {
  const stagingVendorDir = join(VENDOR_STAGING_DIR, 'vendor');
  if (existsSync(stagingVendorDir)) {
    allFiles.push({ path: 'vendor/', isDir: true });
    allFiles.push(...collectFiles(stagingVendorDir, 'vendor'));
  }
}

// Copy .env.production as .env
const envSource = join(import.meta.dirname, '.env.production');
if (existsSync(envSource)) {
  allFiles.push({ path: '.env', isDir: false, fullPath: envSource });
} else {
  console.warn('  Warning: .laraworker/.env.production not found, no .env will be included');
}

// Add empty storage directory structure
const storageDirs = [
  'storage/',
  'storage/app/',
  'storage/framework/',
  'storage/framework/cache/',
  'storage/framework/cache/data/',
  'storage/framework/sessions/',
  'storage/framework/testing/',
  'storage/framework/views/',
  'storage/logs/',
];

for (const dir of storageDirs) {
  if (!allFiles.some(f => f.path === dir)) {
    allFiles.push({ path: dir, isDir: true });
  }
}

// Include Vite manifest in the tar so PHP can read it for @vite() Blade directive.
// The actual JS/CSS assets are served by Cloudflare Static Assets (copied later),
// but PHP needs the manifest to generate <link> and <script> tags.
const viteManifestDir = join(ROOT, 'public', 'build', '.vite');
if (existsSync(viteManifestDir)) {
  const manifestPath = join(viteManifestDir, 'manifest.json');
  if (existsSync(manifestPath)) {
    allFiles.push({ path: 'public/', isDir: true });
    allFiles.push({ path: 'public/build/', isDir: true });
    allFiles.push({ path: 'public/build/.vite/', isDir: true });
    allFiles.push({ path: 'public/build/.vite/manifest.json', isDir: false, fullPath: manifestPath });
    console.log('  ✓ Vite manifest included in tar');
  }
}

// Strip Carbon locale files (keep only en.php — no regional variants like en_AU, en_GB)
const carbonLangPrefix = 'vendor/nesbot/carbon/src/Carbon/Lang/';
const carbonRemoved = [];
for (let i = allFiles.length - 1; i >= 0; i--) {
  const f = allFiles[i];
  if (!f.path.startsWith(carbonLangPrefix) || f.isDir) continue;
  const filename = f.path.substring(carbonLangPrefix.length);
  if (filename !== 'en.php') {
    carbonRemoved.push(f.path);
    allFiles.splice(i, 1);
  }
}
if (carbonRemoved.length > 0) {
  console.log(`  Stripped ${carbonRemoved.length} Carbon locale files (kept en.php only)`);
}

// Verify no dev packages in the final bundle
// These are packages that should ONLY be in require-dev, not transitive deps
const DEV_PACKAGE_PATTERNS = [
  /vendor\/fakerphp\/faker/,
  /vendor\/phpunit\/phpunit/,
  /vendor\/pestphp\/pest/,
  /vendor\/mockery\/mockery/,
  /vendor\/laravel\/sail/,
  /vendor\/laravel\/pint/,
  /vendor\/laravel\/dusk/,
  /vendor\/spatie\/laravel-ignition/,
];

const devPackagesFound = [];
for (const file of allFiles) {
  for (const pattern of DEV_PACKAGE_PATTERNS) {
    if (pattern.test(file.path)) {
      devPackagesFound.push(file.path);
      break;
    }
  }
}

if (devPackagesFound.length > 0) {
  console.error('  ERROR: Dev packages found in bundle:');
  for (const pkg of devPackagesFound.slice(0, 10)) {
    console.error(`    - ${pkg}`);
  }
  if (devPackagesFound.length > 10) {
    console.error(`    ... and ${devPackagesFound.length - 10} more`);
  }
  process.exit(1);
} else {
  console.log('  ✓ No dev packages found in bundle');
}

// Override Composer platform check — php-cgi-wasm currently provides PHP 8.3.11
// but Laravel 12 requires >= 8.4.0. Remove this override once a custom PHP 8.4+
// WASM binary is built (see php-wasm-build/.php-wasm-rc).
const platformCheckPath = 'vendor/composer/platform_check.php';
const idx = allFiles.findIndex(f => f.path === platformCheckPath);
if (idx >= 0) {
  const tmpFile = join(DIST_DIR, '__platform_check_noop.php');
  mkdirSync(DIST_DIR, { recursive: true });
  writeFileSync(tmpFile, '<?php\n// Platform check disabled for WASM runtime\n');
  allFiles[idx] = { path: platformCheckPath, isDir: false, fullPath: tmpFile };
  console.log('  Disabled Composer platform check');
}

// Generate PHP stubs for missing extensions
console.log('  Generating PHP stubs for extensions...');
const stubsContent = generatePhpStubs(EXTENSIONS);
const stubsFile = join(DIST_DIR, '__php_stubs.php');
mkdirSync(DIST_DIR, { recursive: true });
writeFileSync(stubsFile, stubsContent);
allFiles.push({ path: 'php-stubs.php', isDir: false, fullPath: stubsFile });
console.log(`    iconv: ${EXTENSIONS.iconv ? 'enabled (no stubs)' : 'disabled (stubs added)'}`);
console.log(`    mbstring: ${EXTENSIONS.mbstring ? 'enabled (no stubs)' : 'disabled (stubs added)'}`);
console.log(`    openssl: ${EXTENSIONS.openssl ? 'enabled (no stubs)' : 'disabled (stubs added)'}`);

// Compute per-category stats before creating tar
let vendorFileCount = 0;
let vendorUncompressedSize = 0;
let appFileCount = 0;
let appUncompressedSize = 0;

for (const f of allFiles) {
  if (f.isDir) continue;
  const size = statSync(f.fullPath).size;
  if (f.path.startsWith('vendor/')) {
    vendorFileCount++;
    vendorUncompressedSize += size;
  } else {
    appFileCount++;
    appUncompressedSize += size;
  }
}

console.log(`  Collected ${allFiles.length} entries (${vendorFileCount + appFileCount} files)`);

// Strip PHP whitespace in parallel (with content-hash cache for incremental builds)
let strippedContents = new Map();
if (STRIP_WHITESPACE) {
  console.log(`  Stripping PHP whitespace and comments (${STRIP_CONCURRENCY} parallel workers)...`);
  strippedContents = await stripPhpFilesParallel(allFiles);
}

const { tar, strippedCount, bytesSaved } = createTar(allFiles, { stripWhitespace: STRIP_WHITESPACE, strippedContents });

if (STRIP_WHITESPACE && strippedCount > 0) {
  console.log(`  Stripped whitespace from ${strippedCount} PHP files (saved ${fmt(bytesSaved)} uncompressed)`);
}

const gzipped = gzipSync(tar, { level: 9 });

mkdirSync(DIST_DIR, { recursive: true });
writeFileSync(OUTPUT, gzipped);

// Compute compressed sizes per category for report
const vendorOnlyFiles = allFiles.filter(f => !f.isDir && f.path.startsWith('vendor/'));
const appOnlyFiles = allFiles.filter(f => !f.isDir && !f.path.startsWith('vendor/'));
const { tar: vendorTar } = createTar(vendorOnlyFiles, { stripWhitespace: STRIP_WHITESPACE, strippedContents });
const vendorGz = gzipSync(vendorTar, { level: 9 });
const { tar: appTar } = createTar(appOnlyFiles, { stripWhitespace: STRIP_WHITESPACE, strippedContents });
const appGz = gzipSync(appTar, { level: 9 });

const totalCompressed = gzipped.length;
// PHP 8.5 WASM binary (gzipped). Measured from PHP 8.5.2 build: 3.27 MB gz.
// PHP WASM is loaded as a separate Cloudflare Workers binding (not bundled in script).
const WASM_ESTIMATE_BYTES = 3.4 * 1024 * 1024;
const totalWithWasm = totalCompressed + WASM_ESTIMATE_BYTES;
// App bundle budget: app.tar.gz should fit in Cloudflare Workers KV (25 MB limit).
// WASM is deployed as a separate Workers binding, not counted here.
const appFitsBudget = totalCompressed < 25 * 1024 * 1024;

console.log('');
console.log('  ┌─────────────────────────────────────────────────┐');
console.log('  │              Build Report                       │');
console.log('  ├──────────────────────┬──────────┬───────────────┤');
console.log('  │ Category             │ Files    │ Compressed    │');
console.log('  ├──────────────────────┼──────────┼───────────────┤');
console.log(`  │ vendor/              │ ${String(vendorFileCount).padStart(6)} │ ${fmt(vendorGz.length).padStart(13)} │`);
console.log(`  │ app (non-vendor)     │ ${String(appFileCount).padStart(6)} │ ${fmt(appGz.length).padStart(13)} │`);
console.log('  ├──────────────────────┼──────────┼───────────────┤');
console.log(`  │ Total tar entries    │ ${String(allFiles.length).padStart(6)} │ ${fmt(totalCompressed).padStart(13)} │`);
console.log(`  │ + WASM (~3.4 MB gz)  │        │ ${fmt(totalWithWasm).padStart(13)} │`);
console.log('  ├──────────────────────┴──────────┴───────────────┤');
console.log(`  │ App bundle (< 25 MB): ${appFitsBudget ? '✅ FITS' : '❌ EXCEEDS'}${' '.repeat(24)}│`);
console.log('  └─────────────────────────────────────────────────┘');
console.log('');

// Copy Vite build assets if they exist
const viteBuildDir = join(ROOT, 'public', 'build');
if (existsSync(viteBuildDir)) {
  console.log('  Copying Vite build assets...');
  copyDirRecursive(viteBuildDir, join(DIST_DIR, 'build'));
  console.log('  Done.');
}

// Verify custom PHP 8.5 WASM binary and helper modules are present.
// These are copied into the build directory by the PHP BuildCommand
// (BuildDirectory::copyWasmBinary) before build-app.mjs runs.
console.log('  Verifying custom PHP 8.5 WASM binary...');

const requiredFiles = ['php-cgi.mjs', 'php-cgi.wasm', 'PhpCgiBase.mjs', 'breakoutRequest.mjs', 'parseResponse.mjs', 'fsOps.mjs', 'resolveDependencies.mjs'];
for (const file of requiredFiles) {
  const filePath = join(import.meta.dirname, file);
  if (!existsSync(filePath)) {
    console.error(`  ERROR: ${file} not found in build directory`);
    console.error('  Ensure BuildDirectory::copyWasmBinary() ran successfully.');
    console.error('  To rebuild WASM: bash php-wasm-build/build.sh');
    process.exit(1);
  }
}

const wasmSize = statSync(join(import.meta.dirname, 'php-cgi.wasm')).size;
console.log(`  ✓ php-cgi.wasm (${fmt(wasmSize)})`);
console.log(`  ✓ php-cgi.mjs + ${requiredFiles.length - 2} helper modules`);

console.log('Build complete.');

function copyDirRecursive(src, dest) {
  mkdirSync(dest, { recursive: true });
  const entries = readdirSync(src, { withFileTypes: true });
  for (const entry of entries) {
    const srcPath = join(src, entry.name);
    const destPath = join(dest, entry.name);
    if (entry.isDirectory()) {
      copyDirRecursive(srcPath, destPath);
    } else {
      copyFileSync(srcPath, destPath);
    }
  }
}
