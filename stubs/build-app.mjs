/**
 * Build script: packages Laravel application files into a .tar for Cloudflare Static Assets.
 *
 * Usage: node .laraworker/build-app.mjs
 *
 * Output: .laraworker/dist/assets/app.tar.gz
 *
 * Configuration is read from .laraworker/build-config.json (generated by laraworker:build).
 */

import {
  readdirSync,
  statSync,
  readFileSync,
  mkdirSync,
  writeFileSync,
  copyFileSync,
  existsSync,
  rmSync,
} from "node:fs";
import { gzipSync } from "node:zlib";
import { join, resolve } from "node:path";
import { execFile } from "node:child_process";
import { promisify } from "node:util";
import { createHash } from "node:crypto";
import { cpus } from "node:os";

const execFileAsync = promisify(execFile);

const ROOT = resolve(import.meta.dirname, "..");
const DIST_DIR = resolve(import.meta.dirname, "dist", "assets");
const OUTPUT = join(DIST_DIR, "app.tar.gz");

// Read build config (generated by php artisan laraworker:build)
const configPath = join(import.meta.dirname, "build-config.json");
let config = {};
if (existsSync(configPath)) {
  config = JSON.parse(readFileSync(configPath, "utf8"));
}

const VENDOR_STAGING_DIR = config.vendor_staging_dir;

let INCLUDE_DIRS = config.include_dirs ?? [
  "app",
  "bootstrap",
  "config",
  "database",
  "routes",
  "resources/views",
  "vendor",
];

// Use staging vendor if available (production-only, no-dev)
if (VENDOR_STAGING_DIR && existsSync(VENDOR_STAGING_DIR)) {
  console.log("  Using staging vendor (production-only, no-dev)...");
  // Filter out vendor from include_dirs - we'll add staging vendor separately
  INCLUDE_DIRS = INCLUDE_DIRS.filter((d) => d !== "vendor");
} else {
  console.warn("  Warning: No staging vendor found, using main vendor (may include dev packages)");
}

const INCLUDE_FILES = config.include_files ?? ["public/index.php", "artisan", "composer.json"];

// Default exclude patterns — always applied. User config patterns merge with these.
const DEFAULT_EXCLUDE_PATTERNS = [
  // VCS & CI
  "/\\.git\\//",
  "/\\.github\\//",
  "/\\/node_modules\\//",
  "/\\/\\.DS_Store$/",

  // Vendor tests, examples, benchmarks, fixtures (dev-only)
  "/vendor\\/[^/]+\\/[^/]+\\/tests\\//",
  "/vendor\\/[^/]+\\/[^/]+\\/Tests\\//",
  "/vendor\\/[^/]+\\/[^/]+\\/test\\//",
  "/vendor\\/[^/]+\\/[^/]+\\/examples?\\//",
  "/vendor\\/[^/]+\\/[^/]+\\/benchmarks?\\//",
  "/vendor\\/[^/]+\\/[^/]+\\/fixtures?\\//",

  // Vendor docs & metadata
  "/vendor\\/[^/]+\\/[^/]+\\/docs\\//",
  "/vendor\\/[^/]+\\/[^/]+\\/doc\\//",
  "/vendor\\/[^/]+\\/[^/]+\\/documentation\\//",
  "/vendor\\/[^/]+\\/[^/]+\\/[^/]+\\.md$/",
  "/vendor\\/[^/]+\\/[^/]+\\/CHANGELOG/",
  "/vendor\\/[^/]+\\/[^/]+\\/UPGRADE/",

  // Metadata files not needed at runtime
  "/vendor\\/[^/]+\\/[^/]+\\/LICENSE/",
  "/vendor\\/[^/]+\\/[^/]+\\/CREDITS/",
  "/vendor\\/[^/]+\\/[^/]+\\/NOTICE/",
  "/vendor\\/[^/]+\\/[^/]+\\/README/",
  "/vendor\\/[^/]+\\/[^/]+\\/AUTHORS/",
  "/vendor\\/[^/]+\\/[^/]+\\/CONTRIBUTORS/",
  "/vendor\\/[^/]+\\/[^/]+\\/BACKERS/",

  // Vendor tooling configs
  "/vendor\\/[^/]+\\/[^/]+\\/phpunit\\.xml/",
  "/vendor\\/[^/]+\\/[^/]+\\/\\.editorconfig$/",
  "/vendor\\/[^/]+\\/[^/]+\\/\\.gitattributes$/",
  "/vendor\\/[^/]+\\/[^/]+\\/\\.gitignore$/",
  "/vendor\\/[^/]+\\/[^/]+\\/phpstan/",
  "/vendor\\/[^/]+\\/[^/]+\\/psalm/",
  "/vendor\\/[^/]+\\/[^/]+\\/\\.phpcs/",
  "/vendor\\/[^/]+\\/[^/]+\\/\\.php-cs-fixer/",
  "/vendor\\/[^/]+\\/[^/]+\\/\\.php_cs/",
  "/vendor\\/[^/]+\\/[^/]+\\/Makefile$/",
  "/vendor\\/[^/]+\\/[^/]+\\/\\.styleci\\.yml$/",
  "/vendor\\/[^/]+\\/[^/]+\\/docker-compose/",
  "/vendor\\/[^/]+\\/[^/]+\\/Dockerfile$/",
  "/vendor\\/[^/]+\\/[^/]+\\/rector\\.php$/",
  "/vendor\\/[^/]+\\/[^/]+\\/pint\\.json$/",
  "/vendor\\/[^/]+\\/[^/]+\\/infection\\.json/",
  "/vendor\\/[^/]+\\/[^/]+\\/box\\.json/",
  "/vendor\\/[^/]+\\/[^/]+\\/phpbench\\.json/",
  "/vendor\\/[^/]+\\/[^/]+\\/\\.phpunit\\.result\\.cache$/",
  "/vendor\\/[^/]+\\/[^/]+\\/\\.phpunit\\.cache\\//",

  // CI service configs
  "/vendor\\/[^/]+\\/[^/]+\\/\\.scrutinizer\\.yml$/",
  "/vendor\\/[^/]+\\/[^/]+\\/codecov\\.ya?ml$/",
  "/vendor\\/[^/]+\\/[^/]+\\/\\.coveralls\\.yml$/",
  "/vendor\\/[^/]+\\/[^/]+\\/\\.gitlab-ci\\.yml$/",
  "/vendor\\/[^/]+\\/[^/]+\\/crowdin\\.ya?ml$/",

  // Nested vendor directories (e.g. path-repository packages with their own vendor/)
  "/vendor\/.*\/vendor\//",

  // Laraworker package internals — PHP never needs these at runtime (~15 MB savings)
  // Only keep: src/, config/, routes/, resources/, composer.json, LICENSE
  "/vendor\/kieranbrown\/laraworker\/php-wasm-build\//",
  "/vendor\/kieranbrown\/laraworker\/playground\//",
  "/vendor\/kieranbrown\/laraworker\/stubs\//",
  "/vendor\/kieranbrown\/laraworker\/dist\//",
  "/vendor\/kieranbrown\/laraworker\/scripts\//",
  "/vendor\/kieranbrown\/laraworker\/node_modules\//",
  "/vendor\/kieranbrown\/laraworker\/vendor\//",
  "/vendor\/kieranbrown\/laraworker\/\\./",
  "/vendor\/kieranbrown\/laraworker\/composer\.lock$/",
  "/vendor\/kieranbrown\/laraworker\/[^/]+\.wasm$/",
  "/vendor\/kieranbrown\/laraworker\/[^/]+\.mjs$/",

  // NOTE: blade-ui-kit SVG files are NOT excluded. Blade-icons resolves @svg()
  // directives at runtime by reading SVG files from disk via Filesystem::get().
  // view:cache does NOT inline SVG content into compiled views.

  // ──── Vendor frontend assets already served by Cloudflare Static Assets ────
  // Compiled JS/CSS/fonts are published to public/ via vendor:publish and served from
  // CF edge before the Worker is invoked. The vendor source copies waste MEMFS space.
  // PHP references these through Vite manifests and public URLs, not vendor paths.

  // Filament compiled JS/CSS — published to public/vendor/filament/ for edge serving.
  // Filament's asset system resolves URLs via Vite manifests (included in tar separately).
  "/vendor\\/filament\\/[^/]+\\/resources\\/dist\\//",

  // Livewire source maps — development-only, never needed in production.
  // NOTE: Livewire JS files are kept because Livewire serves them via a PHP route
  // handler (FrontendAssets::returnJavaScriptAsFile) that reads from dist/ at runtime.
  "/vendor\\/livewire\\/[^/]+\\/dist\\/.*\\.map$/",

  // Generic vendor compiled frontend assets in resources/dist/ directories.
  // Convention: resources/dist/ contains publishable compiled assets (JS/CSS/fonts)
  // that packages copy to public/ via vendor:publish. PHP reads manifests (JSON) at
  // runtime but never reads JS/CSS/font files directly from vendor.
  "/vendor\\/[^/]+\\/[^/]+\\/resources\\/dist\\/.*\\.(js|css|woff2?|ttf|eot)$/",

  // Source map files in vendor (development-only, never needed at runtime)
  "/vendor\\/.*\\.js\\.map$/",
  "/vendor\\/.*\\.css\\.map$/",

  // Vendor CLI scripts (not useful in Workers)
  "/vendor\\/bin\\//",
  "/vendor\\/[^/]+\\/[^/]+\\/bin\\//",

  // Schema and validation files (not needed at runtime)
  "/vendor\\/.*\\.xsd$/",
  "/vendor\\/.*\\.dtd$/",

  // Composer metadata (autoloader doesn't need installed.json at runtime)
  "/vendor\\/composer\\/installed\\.json$/",

  // Package manager files in vendor (PHP packages don't need these)
  "/vendor\\/[^/]+\\/[^/]+\\/composer\\.lock$/",
  "/vendor\\/.*\\/package-lock\\.json$/",
  "/vendor\\/[^/]+\\/[^/]+\\/package\\.json$/",
  "/vendor\\/[^/]+\\/[^/]+\\/yarn\\.lock$/",
  "/vendor\\/[^/]+\\/[^/]+\\/bun\\.lock$/",

  // Stub/template files (artisan make:* commands don't work in Workers)
  "/vendor\\/.*\\.stub$/",

  // Symfony translation/locale resources (large, unused in typical Workers apps)
  "/vendor\\/symfony\\/[^/]+\\/Resources\\/translations\\//",

  // Symfony Resources not needed at runtime
  "/vendor\\/symfony\\/[^/]+\\/Resources\\/schemas\\//",
  "/vendor\\/symfony\\/[^/]+\\/Resources\\/bin\\//",
  "/vendor\\/symfony\\/http-kernel\\/Resources\\/welcome/",

  // Symfony polyfill stubs for PHP ≤ 8.4 (target runtime is PHP 8.5; native classes exist)
  "/vendor\\/symfony\\/polyfill-php[0-9]+\\/Resources\\/stubs\\//",

  // Laravel framework exception renderer build tooling (not needed at runtime)
  "/vendor\\/laravel\\/framework\\/src\\/Illuminate\\/Foundation\\/resources\\/exceptions\\/renderer\\/package/",
  "/vendor\\/laravel\\/framework\\/src\\/Illuminate\\/Foundation\\/resources\\/exceptions\\/renderer\\/vite/",

  // NOTE: Illuminate/Testing/ is NOT excluded — FoundationServiceProvider
  // unconditionally registers ParallelTestingServiceProvider at boot.

  // Laravel framework fixtures & stubs (dev-only)
  "/vendor\\/laravel\\/framework\\/src\\/Illuminate\\/Foundation\\/Console\\/stubs\\//",

  // Misc dev files in vendor
  "/vendor\\/[^/]+\\/[^/]+\\/\\.github\\//",
  "/vendor\\/[^/]+\\/[^/]+\\/\\.travis\\.yml$/",
  "/vendor\\/[^/]+\\/[^/]+\\/appveyor\\.yml$/",
  "/vendor\\/[^/]+\\/[^/]+\\/CONTRIBUTING/",
  "/vendor\\/[^/]+\\/[^/]+\\/SECURITY\\.md$/",
];

const toRegExp = (p) => new RegExp(p.replace(/^\//, "").replace(/\/$/, ""));
const defaultPatterns = DEFAULT_EXCLUDE_PATTERNS.map(toRegExp);
const userPatterns = (config.exclude_patterns ?? []).map(toRegExp);
const EXCLUDE_PATTERNS = [...defaultPatterns, ...userPatterns];

const EXTENSIONS = config.extensions ?? { mbstring: true, openssl: true };
// Default to false for initial build to avoid timeout - user can enable in build-config.json
const STRIP_WHITESPACE = config.strip_whitespace ?? false;

/**
 * Generate PHP stub functions for missing extensions.
 * These stubs provide minimal implementations when extensions are not enabled.
 */
function generatePhpStubs(extensions) {
  const stubs = [];

  // Enable error reporting so PHP errors appear in Cloudflare logs (stderr).
  // display_errors sends output to stderr in CGI mode, not to the HTTP response body.
  stubs.push(`
// Report PHP errors to stderr (visible in Cloudflare Workers logs)
error_reporting(E_ALL);
ini_set('display_errors', 'stderr');
ini_set('display_startup_errors', '1');

// PHP-side request profiling — logs timing of key bootstrap phases
\$_SERVER['__PHP_T0'] = microtime(true);
\$_SERVER['__PHP_LAST_MILESTONE'] = 0;
register_shutdown_function(function() {
    \$elapsed = (microtime(true) - \$_SERVER['__PHP_T0']) * 1000;
    error_log(sprintf('[php-time] total=%.0fms uri=%s', \$elapsed, \$_SERVER['REQUEST_URI'] ?? '?'));
});

// Diagnostic endpoints flag — checked after stubs are defined
\$_SERVER['__DIAG_URI'] = \$_SERVER['REQUEST_URI'] ?? '';

// Output buffer to detect when PHP starts generating response
ob_start(function(\$buffer) {
    static \$started = false;
    if (!\$started) {
        \$started = true;
        \$elapsed = (microtime(true) - \$_SERVER['__PHP_T0']) * 1000;
        error_log(sprintf('[php-output] first output at %.0fms (%d bytes)', \$elapsed, strlen(\$buffer)));
    }
    return \$buffer;
}, 4096);

// Track milestones when key classes are loaded
spl_autoload_register(function(\$class) {
    \$milestones = [
        'Illuminate\\\\Foundation\\\\Application' => 'Laravel Application',
        'Illuminate\\\\Routing\\\\Router' => 'Laravel Router',
        'Illuminate\\\\View\\\\View' => 'View class',
        'Livewire\\\\LivewireManager' => 'Livewire Manager',
        'Livewire\\\\Mechanisms\\\\HandleComponents\\\\HandleComponents' => 'Livewire HandleComponents',
        'Filament\\\\Panel' => 'Filament Panel',
        'Filament\\\\Http\\\\Middleware\\\\SetUpPanel' => 'SetUpPanel middleware',
        'Filament\\\\Auth\\\\Pages\\\\Login' => 'Filament Login page',
        'Illuminate\\\\Session\\\\Middleware\\\\StartSession' => 'StartSession middleware',
        'Illuminate\\\\Cookie\\\\Middleware\\\\EncryptCookies' => 'EncryptCookies middleware',
        'Illuminate\\\\Foundation\\\\Http\\\\Middleware\\\\VerifyCsrfToken' => 'VerifyCsrfToken middleware',
    ];
    if (isset(\$milestones[\$class])) {
        \$elapsed = (microtime(true) - \$_SERVER['__PHP_T0']) * 1000;
        error_log(sprintf('[php-milestone] %s at %.0fms', \$milestones[\$class], \$elapsed));
    }
}, true, true);`);

  // umask fix for MEMFS - always needed
  stubs.push(`
// Fix for MEMFS umask issue
if (!function_exists('umask')) {
    function umask($mask = null) {
        return 0022;
    }
}`);

  // iconv stubs - only if iconv extension is not enabled
  if (!extensions.iconv) {
    stubs.push(`
// iconv stub functions
if (!function_exists('iconv')) {
    function iconv($from_encoding, $to_encoding, $string) {
        return $string;
    }
}
if (!function_exists('iconv_strlen')) {
    function iconv_strlen($string, $encoding = null) {
        return strlen($string);
    }
}
if (!function_exists('iconv_substr')) {
    function iconv_substr($string, $offset, $length = null, $encoding = null) {
        return substr($string, $offset, $length);
    }
}
if (!function_exists('iconv_strpos')) {
    function iconv_strpos($haystack, $needle, $offset = 0, $encoding = null) {
        return strpos($haystack, $needle, $offset);
    }
}`);
  }

  // mbstring stubs - only if mbstring extension is not enabled
  if (!extensions.mbstring) {
    stubs.push(`
// mbstring stub functions
if (!function_exists('mb_split')) {
    function mb_split($pattern, $string, $limit = -1) {
        return preg_split('/' . $pattern . '/', $string, $limit);
    }
}
if (!function_exists('mb_strlen')) {
    function mb_strlen($string, $encoding = null) {
        return strlen($string);
    }
}
if (!function_exists('mb_substr')) {
    function mb_substr($string, $start, $length = null, $encoding = null) {
        return substr($string, $start, $length);
    }
}
if (!function_exists('mb_strpos')) {
    function mb_strpos($haystack, $needle, $offset = 0, $encoding = null) {
        return strpos($haystack, $needle, $offset);
    }
}`);
  }

  // filter stubs - only if filter extension is not enabled
  if (!extensions.filter) {
    stubs.push(`
// filter extension constants
if (!defined('FILTER_VALIDATE_INT')) {
    define('FILTER_VALIDATE_INT', 257);
    define('FILTER_VALIDATE_BOOLEAN', 258);
    define('FILTER_VALIDATE_FLOAT', 259);
    define('FILTER_VALIDATE_EMAIL', 274);
    define('FILTER_VALIDATE_URL', 273);
    define('FILTER_VALIDATE_IP', 275);
    define('FILTER_VALIDATE_MAC', 281);
    define('FILTER_VALIDATE_DOMAIN', 277);
    define('FILTER_VALIDATE_REGEXP', 272);
    define('FILTER_DEFAULT', 516);
    define('FILTER_UNSAFE_RAW', 516);
    define('FILTER_SANITIZE_STRING', 513);
    define('FILTER_SANITIZE_STRIPPED', 513);
    define('FILTER_SANITIZE_ENCODED', 514);
    define('FILTER_SANITIZE_SPECIAL_CHARS', 515);
    define('FILTER_SANITIZE_NUMBER_INT', 519);
    define('FILTER_SANITIZE_NUMBER_FLOAT', 520);
    define('FILTER_SANITIZE_URL', 518);
    define('FILTER_SANITIZE_EMAIL', 517);
    define('FILTER_SANITIZE_ADD_SLASHES', 523);
    define('FILTER_SANITIZE_FULL_SPECIAL_CHARS', 522);
    define('FILTER_CALLBACK', 1024);
    define('FILTER_FLAG_NONE', 0);
    define('FILTER_FLAG_ALLOW_OCTAL', 1);
    define('FILTER_FLAG_ALLOW_HEX', 2);
    define('FILTER_FLAG_STRIP_LOW', 4);
    define('FILTER_FLAG_STRIP_HIGH', 8);
    define('FILTER_FLAG_ENCODE_LOW', 16);
    define('FILTER_FLAG_ENCODE_HIGH', 32);
    define('FILTER_FLAG_ENCODE_AMP', 64);
    define('FILTER_FLAG_NO_ENCODE_QUOTES', 128);
    define('FILTER_FLAG_EMPTY_STRING_NULL', 256);
    define('FILTER_FLAG_STRIP_BACKTICK', 512);
    define('FILTER_FLAG_ALLOW_FRACTION', 1024);
    define('FILTER_FLAG_ALLOW_THOUSAND', 2048);
    define('FILTER_FLAG_ALLOW_SCIENTIFIC', 4096);
    define('FILTER_FLAG_PATH_REQUIRED', 262144);
    define('FILTER_FLAG_QUERY_REQUIRED', 524288);
    define('FILTER_FLAG_IPV4', 1048576);
    define('FILTER_FLAG_IPV6', 2097152);
    define('FILTER_FLAG_NO_RES_RANGE', 4194304);
    define('FILTER_FLAG_NO_PRIV_RANGE', 8388608);
    define('FILTER_FLAG_HOSTNAME', 1048576);
    define('FILTER_FLAG_EMAIL_UNICODE', 1048576);
    define('FILTER_REQUIRE_SCALAR', 33554432);
    define('FILTER_REQUIRE_ARRAY', 16777216);
    define('FILTER_FORCE_ARRAY', 67108864);
    define('FILTER_NULL_ON_FAILURE', 134217728);
    define('INPUT_GET', 1);
    define('INPUT_POST', 2);
    define('INPUT_COOKIE', 4);
    define('INPUT_SERVER', 5);
    define('INPUT_ENV', 16);
}
if (!function_exists('filter_var')) {
    function filter_var($value, $filter = 516, $options = 0) {
        if (is_array($options)) {
            $flags = $options['flags'] ?? 0;
            $opts = $options['options'] ?? [];
        } else {
            $flags = $options;
            $opts = [];
        }
        switch ($filter) {
            case 257: // FILTER_VALIDATE_INT
                $min = $opts['min_range'] ?? null;
                $max = $opts['max_range'] ?? null;
                if (is_int($value)) { $v = $value; }
                elseif (is_string($value) && preg_match('/^[+-]?\\d+$/', trim($value))) { $v = (int) trim($value); }
                else { return false; }
                if ($min !== null && $v < $min) return false;
                if ($max !== null && $v > $max) return false;
                return $v;
            case 259: // FILTER_VALIDATE_FLOAT
                if (is_float($value) || is_int($value)) return (float) $value;
                if (is_string($value) && is_numeric(trim($value))) return (float) trim($value);
                return false;
            case 258: // FILTER_VALIDATE_BOOLEAN
                if ($value === true || $value === 1 || $value === '1' || strtolower((string)$value) === 'true' || strtolower((string)$value) === 'on' || strtolower((string)$value) === 'yes') return true;
                if ($value === false || $value === 0 || $value === '0' || $value === '' || strtolower((string)$value) === 'false' || strtolower((string)$value) === 'off' || strtolower((string)$value) === 'no') return false;
                if ($flags & 134217728) return null;
                return false;
            case 274: // FILTER_VALIDATE_EMAIL
                return preg_match('/^[^@\\s]+@[^@\\s]+\\.[^@\\s]+$/', (string) $value) ? (string) $value : false;
            case 273: // FILTER_VALIDATE_URL
                return preg_match('/^https?:\\/\\/.+/i', (string) $value) ? (string) $value : false;
            case 275: // FILTER_VALIDATE_IP
                $v = (string) $value;
                if (($flags & 1048576) && filter_var_ipv4($v)) return $v;
                if (($flags & 2097152) && filter_var_ipv6($v)) return $v;
                if (!$flags || ($flags & ~(4194304|8388608|1048576|2097152)) === 0) {
                    if (filter_var_ipv4($v) || filter_var_ipv6($v)) return $v;
                }
                return false;
            case 272: // FILTER_VALIDATE_REGEXP
                $regexp = $opts['regexp'] ?? '';
                return preg_match($regexp, (string) $value) ? (string) $value : false;
            case 519: // FILTER_SANITIZE_NUMBER_INT
                return preg_replace('/[^0-9+\\-]/', '', (string) $value);
            case 520: // FILTER_SANITIZE_NUMBER_FLOAT
                $allow = '';
                if ($flags & 1024) $allow .= '.';
                if ($flags & 2048) $allow .= ',';
                if ($flags & 4096) $allow .= 'eE';
                return preg_replace('/[^0-9+\\-' . preg_quote($allow, '/') . ']/', '', (string) $value);
            case 515: // FILTER_SANITIZE_SPECIAL_CHARS
            case 522: // FILTER_SANITIZE_FULL_SPECIAL_CHARS
                return htmlspecialchars((string) $value, ENT_QUOTES | ENT_SUBSTITUTE, 'UTF-8');
            case 518: // FILTER_SANITIZE_URL
                return (string) $value;
            case 517: // FILTER_SANITIZE_EMAIL
                return (string) $value;
            case 514: // FILTER_SANITIZE_ENCODED
                return rawurlencode((string) $value);
            case 523: // FILTER_SANITIZE_ADD_SLASHES
                return addslashes((string) $value);
            case 513: // FILTER_SANITIZE_STRING
                return strip_tags((string) $value);
            case 1024: // FILTER_CALLBACK
                $callback = $opts['callback'] ?? $opts ?? null;
                return is_callable($callback) ? $callback($value) : $value;
            default: // FILTER_DEFAULT
                return (string) $value;
        }
    }
    function filter_var_ipv4($ip) { return preg_match('/^(\\d{1,3}\\.){3}\\d{1,3}$/', $ip) && !preg_match('/\\d{4,}/', $ip); }
    function filter_var_ipv6($ip) { return strpos($ip, ':') !== false && preg_match('/^[0-9a-fA-F:]+$/', str_replace(['[', ']'], '', $ip)); }
}
if (!function_exists('filter_input')) {
    function filter_input($type, $var_name, $filter = 516, $options = 0) {
        switch ($type) {
            case 1: $source = $_GET ?? []; break;
            case 2: $source = $_POST ?? []; break;
            case 4: $source = $_COOKIE ?? []; break;
            case 5: $source = $_SERVER ?? []; break;
            case 16: $source = $_ENV ?? []; break;
            default: return null;
        }
        if (!isset($source[$var_name])) return null;
        return filter_var($source[$var_name], $filter, $options);
    }
}
if (!function_exists('filter_has_var')) {
    function filter_has_var($type, $var_name) {
        switch ($type) {
            case 1: return isset($_GET[$var_name]);
            case 2: return isset($_POST[$var_name]);
            case 4: return isset($_COOKIE[$var_name]);
            case 5: return isset($_SERVER[$var_name]);
            case 16: return isset($_ENV[$var_name]);
            default: return false;
        }
    }
}
if (!function_exists('filter_input_array')) {
    function filter_input_array($type, $options = null, $add_empty = true) {
        switch ($type) {
            case 1: $source = $_GET ?? []; break;
            case 2: $source = $_POST ?? []; break;
            case 4: $source = $_COOKIE ?? []; break;
            case 5: $source = $_SERVER ?? []; break;
            case 16: $source = $_ENV ?? []; break;
            default: return null;
        }
        if ($options === null || is_int($options)) {
            $result = [];
            foreach ($source as $k => $v) {
                $result[$k] = is_int($options) ? filter_var($v, $options) : $v;
            }
            return $result;
        }
        return $source;
    }
}
if (!function_exists('filter_var_array')) {
    function filter_var_array($array, $options = null, $add_empty = true) {
        if ($options === null || is_int($options)) {
            $result = [];
            foreach ($array as $k => $v) {
                $result[$k] = is_int($options) ? filter_var($v, $options) : $v;
            }
            return $result;
        }
        return $array;
    }
}
if (!function_exists('filter_list')) {
    function filter_list() {
        return ['int', 'boolean', 'float', 'validate_regexp', 'validate_domain', 'validate_url', 'validate_email', 'validate_ip', 'validate_mac', 'string', 'stripped', 'encoded', 'special_chars', 'full_special_chars', 'unsafe_raw', 'email', 'url', 'number_int', 'number_float', 'add_slashes', 'callback'];
    }
}
if (!function_exists('filter_id')) {
    function filter_id($name) {
        $map = ['int' => 257, 'boolean' => 258, 'float' => 259, 'validate_regexp' => 272, 'validate_url' => 273, 'validate_email' => 274, 'validate_ip' => 275, 'string' => 513, 'stripped' => 513, 'encoded' => 514, 'special_chars' => 515, 'unsafe_raw' => 516, 'email' => 517, 'url' => 518, 'number_int' => 519, 'number_float' => 520, 'full_special_chars' => 522, 'add_slashes' => 523, 'callback' => 1024];
        return $map[$name] ?? false;
    }
}`);
  }

  // ctype stubs - only if ctype extension is not enabled
  if (!extensions.ctype) {
    stubs.push(`
// ctype stub functions
if (!function_exists('ctype_alnum')) {
    function ctype_alnum($text) { return is_string($text) && $text !== '' && preg_match('/^[a-zA-Z0-9]+$/', $text); }
    function ctype_alpha($text) { return is_string($text) && $text !== '' && preg_match('/^[a-zA-Z]+$/', $text); }
    function ctype_cntrl($text) { return is_string($text) && $text !== '' && preg_match('/^[\\x00-\\x1f\\x7f]+$/', $text); }
    function ctype_digit($text) { return is_string($text) && $text !== '' && preg_match('/^[0-9]+$/', $text); }
    function ctype_graph($text) { return is_string($text) && $text !== '' && preg_match('/^[\\x21-\\x7e]+$/', $text); }
    function ctype_lower($text) { return is_string($text) && $text !== '' && preg_match('/^[a-z]+$/', $text); }
    function ctype_print($text) { return is_string($text) && $text !== '' && preg_match('/^[\\x20-\\x7e]+$/', $text); }
    function ctype_punct($text) { return is_string($text) && $text !== '' && preg_match('/^[^a-zA-Z0-9\\s]+$/', $text); }
    function ctype_space($text) { return is_string($text) && $text !== '' && preg_match('/^[\\s]+$/', $text); }
    function ctype_upper($text) { return is_string($text) && $text !== '' && preg_match('/^[A-Z]+$/', $text); }
    function ctype_xdigit($text) { return is_string($text) && $text !== '' && preg_match('/^[0-9a-fA-F]+$/', $text); }
}`);
  }

  // tokenizer stubs - only if tokenizer extension is not enabled
  if (!extensions.tokenizer) {
    stubs.push(`
// tokenizer stub constants
if (!defined('T_OPEN_TAG')) {
    define('T_OPEN_TAG', 379);
    define('T_OPEN_TAG_WITH_ECHO', 380);
    define('T_CLOSE_TAG', 381);
    define('T_WHITESPACE', 396);
    define('T_COMMENT', 397);
    define('T_DOC_COMMENT', 398);
    define('T_STRING', 319);
    define('T_VARIABLE', 320);
    define('T_INLINE_HTML', 323);
    define('T_ECHO', 328);
    define('T_CONSTANT_ENCAPSED_STRING', 321);
    define('T_LNUMBER', 311);
    define('T_DNUMBER', 312);
    define('TOKEN_PARSE', 1);
}
if (!function_exists('token_get_all')) {
    /**
     * String-aware PHP tokenizer stub for WASM (tokenizer extension disabled).
     * Properly handles strings, parentheses, and close tags inside strings.
     * Used by Livewire, phpdocumentor, serializable-closure, and other packages
     * that call token_get_all() at runtime.
     */
    function token_get_all($code, $flags = 0) {
        $tokens = [];
        $len = strlen($code);
        $pos = 0;
        $line = 1;

        while ($pos < $len) {
            $nextOpen = strpos($code, '<?', $pos);

            if ($nextOpen === false) {
                $html = substr($code, $pos);
                if ($html !== '') {
                    $tokens[] = [T_INLINE_HTML, $html, $line];
                }
                break;
            }

            if ($nextOpen > $pos) {
                $html = substr($code, $pos, $nextOpen - $pos);
                $tokens[] = [T_INLINE_HTML, $html, $line];
                $line += substr_count($html, "\\n");
            }

            if (substr($code, $nextOpen, 5) === '<?php' && ($nextOpen + 5 >= $len || !ctype_alnum($code[$nextOpen + 5]))) {
                $tagEnd = $nextOpen + 5;
                if ($tagEnd < $len && ($code[$tagEnd] === ' ' || $code[$tagEnd] === "\\n" || $code[$tagEnd] === "\\r" || $code[$tagEnd] === "\\t")) {
                    $tagEnd++;
                }
                $openTag = substr($code, $nextOpen, $tagEnd - $nextOpen);
                $tokens[] = [T_OPEN_TAG, $openTag, $line];
                $line += substr_count($openTag, "\\n");
                $pos = $tagEnd;
            } elseif (substr($code, $nextOpen, 3) === '<?=') {
                $tokens[] = [T_OPEN_TAG_WITH_ECHO, '<?= ', $line];
                $pos = $nextOpen + 3;
                if ($pos < $len && $code[$pos] === ' ') $pos++;
            } else {
                $tokens[] = [T_INLINE_HTML, '<?', $line];
                $pos = $nextOpen + 2;
                continue;
            }

            // Character-by-character PHP block parsing — handles strings and parens
            $current = '';
            $inPhp = true;
            while ($pos < $len && $inPhp) {
                $char = $code[$pos];

                if ($char === '?' && $pos + 1 < $len && $code[$pos + 1] === '>') {
                    if ($current !== '') {
                        $tokens[] = [T_STRING, $current, $line];
                        $current = '';
                    }
                    $closeEnd = $pos + 2;
                    if ($closeEnd < $len && $code[$closeEnd] === "\\n") $closeEnd++;
                    $closeTag = substr($code, $pos, $closeEnd - $pos);
                    $tokens[] = [T_CLOSE_TAG, $closeTag, $line];
                    $line += substr_count($closeTag, "\\n");
                    $pos = $closeEnd;
                    $inPhp = false;
                    continue;
                }

                if ($char === '"' || $char === "'") {
                    if ($current !== '') {
                        $tokens[] = [T_STRING, $current, $line];
                        $current = '';
                    }
                    $quote = $char;
                    $str = $char;
                    $pos++;
                    while ($pos < $len && $code[$pos] !== $quote) {
                        if ($code[$pos] === '\\\\' && $pos + 1 < $len) {
                            $str .= $code[$pos] . $code[$pos + 1];
                            $pos += 2;
                            continue;
                        }
                        if ($code[$pos] === "\\n") $line++;
                        $str .= $code[$pos];
                        $pos++;
                    }
                    if ($pos < $len) {
                        $str .= $code[$pos];
                        $pos++;
                    }
                    $tokens[] = [T_CONSTANT_ENCAPSED_STRING, $str, $line];
                    continue;
                }

                if ($char === '(' || $char === ')') {
                    if ($current !== '') {
                        $tokens[] = [T_STRING, $current, $line];
                        $current = '';
                    }
                    $tokens[] = $char;
                    $pos++;
                    continue;
                }

                if ($char === "\\n") $line++;
                $current .= $char;
                $pos++;
            }

            if ($inPhp && $current !== '') {
                $tokens[] = [T_STRING, $current, $line];
            }
        }

        return $tokens;
    }
}
if (!function_exists('token_name')) {
    function token_name($id) {
        $names = [379 => 'T_OPEN_TAG', 380 => 'T_OPEN_TAG_WITH_ECHO', 381 => 'T_CLOSE_TAG', 396 => 'T_WHITESPACE', 397 => 'T_COMMENT', 398 => 'T_DOC_COMMENT', 319 => 'T_STRING', 320 => 'T_VARIABLE', 321 => 'T_CONSTANT_ENCAPSED_STRING', 323 => 'T_INLINE_HTML', 328 => 'T_ECHO'];
        return $names[$id] ?? 'UNKNOWN';
    }
}`);
  }

  // openssl stubs - only if openssl extension is not enabled
  if (!extensions.openssl) {
    stubs.push(`
// openssl stub functions (NOT SECURE - for development only)
if (!function_exists('openssl_encrypt')) {
    function openssl_encrypt($data, $cipher_algo, $passphrase, $options = 0, $iv = '', &$tag = null, $aad = '', $tag_length = 16) {
        // Simple XOR encryption - NOT secure, only for testing
        $key = substr($passphrase, 0, 32);
        $result = '';
        for ($i = 0; $i < strlen($data); $i++) {
            $result .= $data[$i] ^ $key[$i % strlen($key)];
        }
        return base64_encode($result);
    }
}
if (!function_exists('openssl_decrypt')) {
    function openssl_decrypt($data, $cipher_algo, $passphrase, $options = 0, $iv = '', $tag = null, $aad = '') {
        // Simple XOR decryption - NOT secure, only for testing
        $key = substr($passphrase, 0, 32);
        $decoded = base64_decode($data);
        $result = '';
        for ($i = 0; $i < strlen($decoded); $i++) {
            $result .= $decoded[$i] ^ $key[$i % strlen($key)];
        }
        return $result;
    }
}
if (!function_exists('openssl_random_pseudo_bytes')) {
    function openssl_random_pseudo_bytes($length, &$strong_result = null) {
        $strong_result = false;
        return random_bytes($length);
    }
}
if (!function_exists('openssl_cipher_iv_length')) {
    function openssl_cipher_iv_length($cipher_algo) {
        return 16;
    }
}`);
  }

  // === Diagnostic endpoints — run AFTER all stubs are defined, BEFORE Laravel boots ===
  stubs.push(`
if (str_starts_with(\$_SERVER['__DIAG_URI'] ?? '', '/__diag/')) {
    header('Content-Type: text/plain');
    \$diag = substr(\$_SERVER['__DIAG_URI'], 8);

    if (\$diag === 'openssl') {
        \$sizes = [64, 256, 1024, 4096, 16384];
        \$key = str_repeat('K', 32);
        \$iv = str_repeat("\\0", 16);
        foreach (\$sizes as \$size) {
            \$data = str_repeat('A', \$size);
            \$t = microtime(true);
            for (\$i = 0; \$i < 100; \$i++) {
                \$enc = openssl_encrypt(\$data, 'aes-256-cbc', \$key, 0, \$iv);
            }
            \$encTime = (microtime(true) - \$t) * 1000;
            \$t = microtime(true);
            for (\$i = 0; \$i < 100; \$i++) {
                openssl_decrypt(\$enc, 'aes-256-cbc', \$key, 0, \$iv);
            }
            \$decTime = (microtime(true) - \$t) * 1000;
            echo sprintf("openssl %dB: encrypt=%.1fms/100, decrypt=%.1fms/100\\n", \$size, \$encTime, \$decTime);
        }
        exit(0);
    }
    if (\$diag === 'token') {
        \$code = '<?php namespace App; use Illuminate\\\\Support\\\\Facades\\\\Route; class Test { public function handle(\\$request, \\$next) { return \\$next(\\$request); } public function render() { return view("test", ["items" => \\$this->items, "user" => auth()->user()]); } }';
        \$t = microtime(true);
        for (\$i = 0; \$i < 100; \$i++) { token_get_all(\$code); }
        \$elapsed = (microtime(true) - \$t) * 1000;
        echo sprintf("token_get_all 100x on %dB: %.1fms\\n", strlen(\$code), \$elapsed);
        \$large = str_repeat(\$code, 20);
        \$t = microtime(true);
        for (\$i = 0; \$i < 10; \$i++) { token_get_all(\$large); }
        \$elapsed = (microtime(true) - \$t) * 1000;
        echo sprintf("token_get_all 10x on %dB: %.1fms\\n", strlen(\$large), \$elapsed);
        exit(0);
    }
    if (\$diag === 'filter') {
        \$t = microtime(true);
        for (\$i = 0; \$i < 1000; \$i++) {
            filter_var('test@example.com', FILTER_VALIDATE_EMAIL);
            filter_var('https://example.com/path?q=1', FILTER_VALIDATE_URL);
            filter_var('192.168.1.1', FILTER_VALIDATE_IP);
            filter_var('42', FILTER_VALIDATE_INT);
        }
        \$elapsed = (microtime(true) - \$t) * 1000;
        echo sprintf("filter_var 4000 calls: %.1fms\\n", \$elapsed);
        exit(0);
    }
    if (\$diag === 'ctype') {
        \$t = microtime(true);
        for (\$i = 0; \$i < 10000; \$i++) {
            ctype_alnum('hello123');
            ctype_alpha('hello');
            ctype_digit('12345');
        }
        \$elapsed = (microtime(true) - \$t) * 1000;
        echo sprintf("ctype 30000 calls: %.1fms\\n", \$elapsed);
        exit(0);
    }
    if (\$diag === 'boot') {
        // Boot Laravel through the Kernel (proper bootstrapping)
        require '/app/vendor/autoload.php';
        \$t0 = microtime(true);
        \$app = require '/app/bootstrap/app.php';
        \$tApp = microtime(true);
        echo sprintf("App created: %.0fms\\n", (\$tApp - \$t0) * 1000);

        \$kernel = \$app->make(\\Illuminate\\Contracts\\Http\\Kernel::class);
        \$tKernel = microtime(true);
        echo sprintf("Kernel resolved: %.0fms\\n", (\$tKernel - \$tApp) * 1000);

        // Handle a simple request to / (main page) to bootstrap everything
        \$request = \\Illuminate\\Http\\Request::create('/', 'GET');
        \$tBeforeHandle = microtime(true);
        try {
            \$response = \$kernel->handle(\$request);
            \$tHandle = microtime(true);
            echo sprintf("Main page handled: %.0fms, status=%d\\n", (\$tHandle - \$tBeforeHandle) * 1000, \$response->getStatusCode());
            \$kernel->terminate(\$request, \$response);
        } catch (\\Throwable \$e) {
            \$tHandle = microtime(true);
            echo sprintf("Main page error at %.0fms: %s\\n", (\$tHandle - \$tBeforeHandle) * 1000, \$e->getMessage());
        }

        // Now try the dashboard with the app already booted
        \$dashRequest = \\Illuminate\\Http\\Request::create('/dashboard/login', 'GET');
        \$tBeforeDash = microtime(true);
        try {
            \$response = \$kernel->handle(\$dashRequest);
            \$tDash = microtime(true);
            echo sprintf("Dashboard handled: %.0fms, status=%d\\n", (\$tDash - \$tBeforeDash) * 1000, \$response->getStatusCode());
        } catch (\\Throwable \$e) {
            \$tDash = microtime(true);
            echo sprintf("Dashboard error at %.0fms: %s\\n", (\$tDash - \$tBeforeDash) * 1000, \$e->getMessage());
            echo "  " . \$e->getFile() . ":" . \$e->getLine() . "\\n";
        }

        echo sprintf("\\nTotal: %.0fms\\n", (microtime(true) - \$t0) * 1000);
        exit(0);
    }
    if (\$diag === 'middleware') {
        // Full request through the Kernel — handles bootstrapping automatically
        require '/app/vendor/autoload.php';
        \$app = require '/app/bootstrap/app.php';
        \$kernel = \$app->make(\\Illuminate\\Contracts\\Http\\Kernel::class);
        \$request = \\Illuminate\\Http\\Request::create('/dashboard/login', 'GET');
        \$t = microtime(true);
        try {
            \$response = \$kernel->handle(\$request);
            \$elapsed = (microtime(true) - \$t) * 1000;
            echo sprintf("Full request: %.0fms, status=%d\\n", \$elapsed, \$response->getStatusCode());
        } catch (\\Throwable \$e) {
            \$elapsed = (microtime(true) - \$t) * 1000;
            echo sprintf("Request failed at %.0fms: %s\\n", \$elapsed, \$e->getMessage());
            echo "  " . \$e->getFile() . ":" . \$e->getLine() . "\\n";
        }
        echo sprintf("Total: %.0fms\\n", (microtime(true) - \$_SERVER['__PHP_T0']) * 1000);
        exit(0);
    }
    if (\$diag === 'step') {
        // Step-by-step isolation of what hangs
        require '/app/vendor/autoload.php';
        \$t0 = microtime(true);

        // Step 1: Create app
        \$app = require '/app/bootstrap/app.php';
        echo sprintf("1. App created: %.0fms\\n", (microtime(true) - \$t0) * 1000);

        // Step 2: Resolve kernel
        \$kernel = \$app->make(\\Illuminate\\Contracts\\Http\\Kernel::class);
        echo sprintf("2. Kernel resolved: %.0fms\\n", (microtime(true) - \$t0) * 1000);

        // Step 3: Bootstrap the app (this registers providers, boots them, etc.)
        \$bootstrappers = [
            \\Illuminate\\Foundation\\Bootstrap\\LoadEnvironmentVariables::class,
            \\Illuminate\\Foundation\\Bootstrap\\LoadConfiguration::class,
            \\Illuminate\\Foundation\\Bootstrap\\HandleExceptions::class,
            \\Illuminate\\Foundation\\Bootstrap\\RegisterFacades::class,
            \\Illuminate\\Foundation\\Bootstrap\\RegisterProviders::class,
            \\Illuminate\\Foundation\\Bootstrap\\BootProviders::class,
        ];
        foreach (\$bootstrappers as \$bootstrapper) {
            \$tStep = microtime(true);
            try {
                \$app->bootstrapWith([\$bootstrapper]);
                echo sprintf("3. %s: %.0fms (total %.0fms)\\n",
                    class_basename(\$bootstrapper),
                    (microtime(true) - \$tStep) * 1000,
                    (microtime(true) - \$t0) * 1000);
            } catch (\\Throwable \$e) {
                echo sprintf("3. %s FAILED at %.0fms: %s\\n",
                    class_basename(\$bootstrapper),
                    (microtime(true) - \$t0) * 1000,
                    \$e->getMessage());
            }
        }

        // Step 4: Match the route
        \$tRoute = microtime(true);
        try {
            \$router = \$app->make('router');
            \$request = \\Illuminate\\Http\\Request::create('/dashboard/login', 'GET');
            \$route = \$router->getRoutes()->match(\$request);
            echo sprintf("4. Route matched: %.0fms (action: %s)\\n",
                (microtime(true) - \$tRoute) * 1000,
                \$route->getActionName());
            echo sprintf("   Middleware: %s\\n", implode(', ', \$route->gatherMiddleware()));
        } catch (\\Throwable \$e) {
            echo sprintf("4. Route match FAILED at %.0fms: %s\\n",
                (microtime(true) - \$t0) * 1000,
                \$e->getMessage());
        }

        // Step 5: Try booting the Filament panel
        \$tPanel = microtime(true);
        try {
            \$filament = \$app->make(\\Filament\\FilamentManager::class);
            \$panel = \$filament->getPanel('cachet');
            \$filament->setCurrentPanel(\$panel);
            echo sprintf("5a. Panel set: %.0fms\\n", (microtime(true) - \$tPanel) * 1000);

            \$tBoot = microtime(true);
            \$filament->bootCurrentPanel();
            echo sprintf("5b. Panel booted: %.0fms\\n", (microtime(true) - \$tBoot) * 1000);
        } catch (\\Throwable \$e) {
            echo sprintf("5. Panel boot FAILED at %.0fms: %s\\n",
                (microtime(true) - \$t0) * 1000,
                \$e->getMessage());
        }

        // Step 6: Try creating the Login component
        \$tLogin = microtime(true);
        try {
            \$loginClass = \\Filament\\Auth\\Pages\\Login::class;
            echo sprintf("6a. Login class exists: %.0fms\\n", (microtime(true) - \$tLogin) * 1000);

            // Resolve a minimal Livewire instance
            \$livewire = \$app->make(\\Livewire\\LivewireManager::class);
            echo sprintf("6b. Livewire manager: %.0fms\\n", (microtime(true) - \$tLogin) * 1000);
        } catch (\\Throwable \$e) {
            echo sprintf("6. Login FAILED at %.0fms: %s\\n",
                (microtime(true) - \$t0) * 1000,
                \$e->getMessage());
        }

        echo sprintf("\\nTotal: %.0fms\\n", (microtime(true) - \$t0) * 1000);
        exit(0);
    }
    if (\$diag === 'render') {
        // Test Livewire component rendering without HTTP middleware
        require '/app/vendor/autoload.php';
        \$app = require '/app/bootstrap/app.php';
        \$kernel = \$app->make(\\Illuminate\\Contracts\\Http\\Kernel::class);

        // Bootstrap via a simple request
        \$request = \\Illuminate\\Http\\Request::create('/dashboard/login', 'GET');
        \$app->instance('request', \$request);

        // Bootstrap the application
        \$app->bootstrapWith([
            \\Illuminate\\Foundation\\Bootstrap\\LoadEnvironmentVariables::class,
            \\Illuminate\\Foundation\\Bootstrap\\LoadConfiguration::class,
            \\Illuminate\\Foundation\\Bootstrap\\HandleExceptions::class,
            \\Illuminate\\Foundation\\Bootstrap\\RegisterFacades::class,
            \\Illuminate\\Foundation\\Bootstrap\\RegisterProviders::class,
            \\Illuminate\\Foundation\\Bootstrap\\BootProviders::class,
        ]);

        \$t0 = microtime(true);

        // Boot the Filament panel (as SetUpPanel middleware would)
        \$filament = \$app->make(\\Filament\\FilamentManager::class);
        \$panel = \$filament->getPanel('cachet');
        \$filament->setCurrentPanel(\$panel);
        \$filament->bootCurrentPanel();
        echo sprintf("Panel booted: %.0fms\\n", (microtime(true) - \$t0) * 1000);

        // Try to mount the Login component directly via Livewire
        \$tMount = microtime(true);
        try {
            \$livewire = \$app->make(\\Livewire\\LivewireManager::class);
            echo sprintf("Livewire manager: %.0fms\\n", (microtime(true) - \$tMount) * 1000);

            // Use Livewire's mount mechanism
            \$tComp = microtime(true);
            \$component = new (\\Filament\\Auth\\Pages\\Login::class)();
            echo sprintf("Login instantiated: %.0fms\\n", (microtime(true) - \$tComp) * 1000);

            // Try to render the component view
            \$tRender = microtime(true);
            \$view = \$component->render();
            echo sprintf("Login rendered: %.0fms\\n", (microtime(true) - \$tRender) * 1000);

            if (\$view instanceof \\Illuminate\\Contracts\\View\\View) {
                \$tEval = microtime(true);
                \$html = \$view->render();
                echo sprintf("View evaluated: %.0fms (%d bytes)\\n",
                    (microtime(true) - \$tEval) * 1000, strlen(\$html));
            }
        } catch (\\Throwable \$e) {
            echo sprintf("Error at %.0fms: %s\\n",
                (microtime(true) - \$t0) * 1000, \$e->getMessage());
            echo "  " . \$e->getFile() . ":" . \$e->getLine() . "\\n";
        }

        echo sprintf("\\nTotal: %.0fms\\n", (microtime(true) - \$t0) * 1000);
        exit(0);
    }
    if (\$diag === 'pipe') {
        // Test middleware pipeline step by step
        require '/app/vendor/autoload.php';
        \$app = require '/app/bootstrap/app.php';
        \$kernel = \$app->make(\\Illuminate\\Contracts\\Http\\Kernel::class);

        \$request = \\Illuminate\\Http\\Request::create('/dashboard/login', 'GET');
        \$app->instance('request', \$request);

        \$app->bootstrapWith([
            \\Illuminate\\Foundation\\Bootstrap\\LoadEnvironmentVariables::class,
            \\Illuminate\\Foundation\\Bootstrap\\LoadConfiguration::class,
            \\Illuminate\\Foundation\\Bootstrap\\HandleExceptions::class,
            \\Illuminate\\Foundation\\Bootstrap\\RegisterFacades::class,
            \\Illuminate\\Foundation\\Bootstrap\\RegisterProviders::class,
            \\Illuminate\\Foundation\\Bootstrap\\BootProviders::class,
        ]);

        \$t0 = microtime(true);

        // Run each middleware individually
        \$middlewares = [
            'panel:cachet' => \\Filament\\Http\\Middleware\\SetUpPanel::class,
            'EncryptCookies' => \\Illuminate\\Cookie\\Middleware\\EncryptCookies::class,
            'AddQueuedCookies' => \\Illuminate\\Cookie\\Middleware\\AddQueuedCookiesToResponse::class,
            'StartSession' => \\Illuminate\\Session\\Middleware\\StartSession::class,
            'AuthenticateSession' => \\Illuminate\\Session\\Middleware\\AuthenticateSession::class,
            'ShareErrors' => \\Illuminate\\View\\Middleware\\ShareErrorsFromSession::class,
            'VerifyCsrfToken' => \\Illuminate\\Foundation\\Http\\Middleware\\VerifyCsrfToken::class,
            'SubstituteBindings' => \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class,
            'DisableBladeIcons' => \\Filament\\Http\\Middleware\\DisableBladeIconComponents::class,
            'DispatchServing' => \\Filament\\Http\\Middleware\\DispatchServingFilamentEvent::class,
        ];

        foreach (\$middlewares as \$name => \$class) {
            \$tMw = microtime(true);
            try {
                \$instance = \$app->make(\$class);
                // Call handle() with a passthrough next closure
                \$params = [\$request, function(\$req) { return new \\Illuminate\\Http\\Response('OK'); }];
                // SetUpPanel needs the panel ID
                if (\$name === 'panel:cachet') {
                    \$params[] = 'cachet';
                }
                \$response = \$instance->handle(...\$params);
                echo sprintf("%-20s: %.0fms (status %d)\\n",
                    \$name, (microtime(true) - \$tMw) * 1000,
                    \$response->getStatusCode());
            } catch (\\Throwable \$e) {
                echo sprintf("%-20s: FAILED at %.0fms: %s\\n",
                    \$name, (microtime(true) - \$tMw) * 1000,
                    substr(\$e->getMessage(), 0, 100));
            }
        }

        echo sprintf("\\nTotal: %.0fms\\n", (microtime(true) - \$t0) * 1000);
        exit(0);
    }
    if (\$diag === 'livewire') {
        // Test Livewire's full component mount lifecycle
        require '/app/vendor/autoload.php';
        \$app = require '/app/bootstrap/app.php';
        \$kernel = \$app->make(\\Illuminate\\Contracts\\Http\\Kernel::class);

        \$request = \\Illuminate\\Http\\Request::create('/dashboard/login', 'GET');
        \$app->instance('request', \$request);

        \$app->bootstrapWith([
            \\Illuminate\\Foundation\\Bootstrap\\LoadEnvironmentVariables::class,
            \\Illuminate\\Foundation\\Bootstrap\\LoadConfiguration::class,
            \\Illuminate\\Foundation\\Bootstrap\\HandleExceptions::class,
            \\Illuminate\\Foundation\\Bootstrap\\RegisterFacades::class,
            \\Illuminate\\Foundation\\Bootstrap\\RegisterProviders::class,
            \\Illuminate\\Foundation\\Bootstrap\\BootProviders::class,
        ]);

        // Boot Filament panel
        \$filament = \$app->make(\\Filament\\FilamentManager::class);
        \$filament->setCurrentPanel(\$filament->getPanel('cachet'));
        \$filament->bootCurrentPanel();
        echo sprintf("Bootstrap + panel boot: %.0fms\\n", (microtime(true) - \$_SERVER['__PHP_T0']) * 1000);

        // Try mounting via Livewire's HandleComponents
        \$t0 = microtime(true);
        try {
            \$hc = \$app->make(\\Livewire\\Mechanisms\\HandleComponents\\HandleComponents::class);
            echo sprintf("HandleComponents resolved: %.0fms\\n", (microtime(true) - \$t0) * 1000);

            \$tMount = microtime(true);
            [\$html, \$snapshot, \$effects, \$key, \$component] = \$hc->mount(
                'filament.auth.pages.login',
                [],
                'login-key'
            );
            echo sprintf("Livewire mount: %.0fms (%d bytes HTML)\\n",
                (microtime(true) - \$tMount) * 1000, strlen(\$html));
        } catch (\\Throwable \$e) {
            echo sprintf("Mount FAILED at %.0fms: %s\\n",
                (microtime(true) - \$t0) * 1000, \$e->getMessage());
            echo "  " . \$e->getFile() . ":" . \$e->getLine() . "\\n";
            // Try a simpler component
            echo "\\nTrying a simpler Livewire component...\\n";
            \$tSimple = microtime(true);
            try {
                [\$html] = \$hc->mount('filament.auth.pages.login', [], 'test');
                echo sprintf("Simple mount: %.0fms\\n", (microtime(true) - \$tSimple) * 1000);
            } catch (\\Throwable \$e2) {
                echo sprintf("Simple mount FAILED: %s\\n", \$e2->getMessage());
            }
        }

        echo sprintf("\\nTotal: %.0fms\\n", (microtime(true) - \$_SERVER['__PHP_T0']) * 1000);
        exit(0);
    }
    if (\$diag === 'view-eval') {
        // Test Blade view evaluation for the Filament login page
        require '/app/vendor/autoload.php';
        \$app = require '/app/bootstrap/app.php';
        \$kernel = \$app->make(\\Illuminate\\Contracts\\Http\\Kernel::class);

        \$request = \\Illuminate\\Http\\Request::create('/dashboard/login', 'GET');
        \$app->instance('request', \$request);

        \$app->bootstrapWith([
            \\Illuminate\\Foundation\\Bootstrap\\LoadEnvironmentVariables::class,
            \\Illuminate\\Foundation\\Bootstrap\\LoadConfiguration::class,
            \\Illuminate\\Foundation\\Bootstrap\\HandleExceptions::class,
            \\Illuminate\\Foundation\\Bootstrap\\RegisterFacades::class,
            \\Illuminate\\Foundation\\Bootstrap\\RegisterProviders::class,
            \\Illuminate\\Foundation\\Bootstrap\\BootProviders::class,
        ]);

        \$filament = \$app->make(\\Filament\\FilamentManager::class);
        \$filament->setCurrentPanel(\$filament->getPanel('cachet'));
        \$filament->bootCurrentPanel();
        echo sprintf("Bootstrap: %.0fms\\n", (microtime(true) - \$_SERVER['__PHP_T0']) * 1000);

        // Try rendering just the simple.blade.php layout
        \$t0 = microtime(true);
        try {
            \$view = view('filament-panels::pages.simple');
            echo sprintf("View resolved: %.0fms\\n", (microtime(true) - \$t0) * 1000);
        } catch (\\Throwable \$e) {
            echo sprintf("View resolve FAILED: %s\\n", \$e->getMessage());
        }

        // List all compiled views
        \$viewDir = '/app/storage/framework/views';
        if (is_dir(\$viewDir)) {
            \$files = glob(\$viewDir . '/*.php');
            echo sprintf("\\nCompiled views: %d files\\n", count(\$files));
        }

        echo sprintf("\\nTotal: %.0fms\\n", (microtime(true) - \$_SERVER['__PHP_T0']) * 1000);
        exit(0);
    }
    if (\$diag === 'reflect') {
        // Test PHP Reflection performance — Livewire uses this heavily
        require '/app/vendor/autoload.php';
        \$app = require '/app/bootstrap/app.php';
        \$app->bootstrapWith([
            \\Illuminate\\Foundation\\Bootstrap\\LoadEnvironmentVariables::class,
            \\Illuminate\\Foundation\\Bootstrap\\LoadConfiguration::class,
            \\Illuminate\\Foundation\\Bootstrap\\HandleExceptions::class,
            \\Illuminate\\Foundation\\Bootstrap\\RegisterFacades::class,
            \\Illuminate\\Foundation\\Bootstrap\\RegisterProviders::class,
            \\Illuminate\\Foundation\\Bootstrap\\BootProviders::class,
        ]);
        echo sprintf("Bootstrap: %.0fms\\n", (microtime(true) - \$_SERVER['__PHP_T0']) * 1000);

        // Test ReflectionClass on the Login component
        \$t0 = microtime(true);
        \$ref = new \\ReflectionClass(\\Filament\\Auth\\Pages\\Login::class);
        echo sprintf("ReflectionClass: %.0fms\\n", (microtime(true) - \$t0) * 1000);

        \$t = microtime(true);
        \$methods = \$ref->getMethods();
        echo sprintf("getMethods: %.0fms (%d methods)\\n", (microtime(true) - \$t) * 1000, count(\$methods));

        \$t = microtime(true);
        \$props = \$ref->getProperties();
        echo sprintf("getProperties: %.0fms (%d properties)\\n", (microtime(true) - \$t) * 1000, count(\$props));

        // Test attribute scanning (what SupportAttributes does)
        \$t = microtime(true);
        \$attrCount = 0;
        foreach (\$methods as \$method) {
            \$attrs = \$method->getAttributes();
            \$attrCount += count(\$attrs);
        }
        echo sprintf("Method attributes: %.0fms (%d attrs across %d methods)\\n",
            (microtime(true) - \$t) * 1000, \$attrCount, count(\$methods));

        \$t = microtime(true);
        \$attrCount = 0;
        foreach (\$props as \$prop) {
            \$attrs = \$prop->getAttributes();
            \$attrCount += count(\$attrs);
        }
        echo sprintf("Property attributes: %.0fms (%d attrs across %d props)\\n",
            (microtime(true) - \$t) * 1000, \$attrCount, count(\$props));

        // Test class_uses_recursive (what SupportLifecycleHooks does)
        \$t = microtime(true);
        \$traits = class_uses_recursive(\\Filament\\Auth\\Pages\\Login::class);
        echo sprintf("class_uses_recursive: %.0fms (%d traits)\\n",
            (microtime(true) - \$t) * 1000, count(\$traits));

        // Test instantiating Livewire Attribute objects
        \$t = microtime(true);
        \$attrInstances = 0;
        foreach (\$methods as \$method) {
            foreach (\$method->getAttributes(\\Livewire\\Attributes\\Attribute::class, \\ReflectionAttribute::IS_INSTANCEOF) as \$attr) {
                try { \$attr->newInstance(); \$attrInstances++; } catch (\\Throwable \$e) {}
            }
        }
        foreach (\$props as \$prop) {
            foreach (\$prop->getAttributes(\\Livewire\\Attributes\\Attribute::class, \\ReflectionAttribute::IS_INSTANCEOF) as \$attr) {
                try { \$attr->newInstance(); \$attrInstances++; } catch (\\Throwable \$e) {}
            }
        }
        echo sprintf("Attribute instances: %.0fms (%d instances)\\n",
            (microtime(true) - \$t) * 1000, \$attrInstances);

        // Test heavy reflection loop (100x)
        \$t = microtime(true);
        for (\$i = 0; \$i < 100; \$i++) {
            \$r = new \\ReflectionClass(\\Filament\\Auth\\Pages\\Login::class);
            \$r->getMethods();
            \$r->getProperties();
        }
        echo sprintf("100x full reflection: %.0fms\\n", (microtime(true) - \$t) * 1000);

        echo sprintf("\\nTotal: %.0fms\\n", (microtime(true) - \$_SERVER['__PHP_T0']) * 1000);
        exit(0);
    }
    if (\$diag === 'mount-steps') {
        // Break down HandleComponents::mount() into individual steps
        require '/app/vendor/autoload.php';
        \$app = require '/app/bootstrap/app.php';
        \$kernel = \$app->make(\\Illuminate\\Contracts\\Http\\Kernel::class);
        \$request = \\Illuminate\\Http\\Request::create('/dashboard/login', 'GET');
        \$app->instance('request', \$request);
        \$app->bootstrapWith([
            \\Illuminate\\Foundation\\Bootstrap\\LoadEnvironmentVariables::class,
            \\Illuminate\\Foundation\\Bootstrap\\LoadConfiguration::class,
            \\Illuminate\\Foundation\\Bootstrap\\HandleExceptions::class,
            \\Illuminate\\Foundation\\Bootstrap\\RegisterFacades::class,
            \\Illuminate\\Foundation\\Bootstrap\\RegisterProviders::class,
            \\Illuminate\\Foundation\\Bootstrap\\BootProviders::class,
        ]);
        \$filament = \$app->make(\\Filament\\FilamentManager::class);
        \$filament->setCurrentPanel(\$filament->getPanel('cachet'));
        \$filament->bootCurrentPanel();
        echo sprintf("Bootstrap: %.0fms\\n", (microtime(true) - \$_SERVER['__PHP_T0']) * 1000);

        // Step 1: Create component through ComponentRegistry
        \$t = microtime(true);
        try {
            \$registry = \$app->make(\\Livewire\\Mechanisms\\ComponentRegistry::class);
            echo sprintf("1. Registry resolved: %.0fms\\n", (microtime(true) - \$t) * 1000);

            \$t = microtime(true);
            \$component = \$registry->new('filament.auth.pages.login');
            echo sprintf("2. Component created: %.0fms\\n", (microtime(true) - \$t) * 1000);

            // Step 2: Manually trigger what mount event does
            \$t = microtime(true);
            \$component->setId('test-id');
            echo sprintf("3. ID set: %.0fms\\n", (microtime(true) - \$t) * 1000);

            // Step 3: Test the EventBus trigger for 'mount'
            \$t = microtime(true);
            // Get the Livewire event bus and trigger mount
            \$finish = \\Livewire\\trigger('mount', \$component, [], 'test-key', null);
            echo sprintf("4. Mount trigger: %.0fms\\n", (microtime(true) - \$t) * 1000);

            // Step 4: Call the component's mount method
            \$t = microtime(true);
            if (method_exists(\$component, 'mount')) {
                \$component->mount();
            }
            echo sprintf("5. Component mount(): %.0fms\\n", (microtime(true) - \$t) * 1000);

            // Step 5: Try rendering
            \$t = microtime(true);
            \$hc = \$app->make(\\Livewire\\Mechanisms\\HandleComponents\\HandleComponents::class);
            \$renderMethod = new \\ReflectionMethod(\$hc, 'render');
            \$renderMethod->setAccessible(true);
            [\$html] = \$renderMethod->invoke(\$hc, \$component, '<div></div>');
            echo sprintf("6. Render: %.0fms (%d bytes)\\n",
                (microtime(true) - \$t) * 1000, strlen(\$html));

            // Step 6: Finish hooks
            \$t = microtime(true);
            \$finish(\$component, \$html);
            echo sprintf("7. Finish hooks: %.0fms\\n", (microtime(true) - \$t) * 1000);
        } catch (\\Throwable \$e) {
            echo sprintf("FAILED at %.0fms: %s\\n",
                (microtime(true) - \$_SERVER['__PHP_T0']) * 1000, \$e->getMessage());
            echo "  " . \$e->getFile() . ":" . \$e->getLine() . "\\n";
        }

        echo sprintf("\\nTotal: %.0fms\\n", (microtime(true) - \$_SERVER['__PHP_T0']) * 1000);
        exit(0);
    }
    // mount-N: test individual mount steps (binary search for hang)
    if (preg_match('/^mount-(\\d+)$/', \$diag, \$m)) {
        \$stopAt = (int)\$m[1];
        require '/app/vendor/autoload.php';
        \$app = require '/app/bootstrap/app.php';
        \$request = \\Illuminate\\Http\\Request::create('/dashboard/login', 'GET');
        \$app->instance('request', \$request);
        \$app->bootstrapWith([
            \\Illuminate\\Foundation\\Bootstrap\\LoadEnvironmentVariables::class,
            \\Illuminate\\Foundation\\Bootstrap\\LoadConfiguration::class,
            \\Illuminate\\Foundation\\Bootstrap\\HandleExceptions::class,
            \\Illuminate\\Foundation\\Bootstrap\\RegisterFacades::class,
            \\Illuminate\\Foundation\\Bootstrap\\RegisterProviders::class,
            \\Illuminate\\Foundation\\Bootstrap\\BootProviders::class,
        ]);
        \$filament = \$app->make(\\Filament\\FilamentManager::class);
        \$filament->setCurrentPanel(\$filament->getPanel('cachet'));
        \$filament->bootCurrentPanel();
        echo sprintf("Bootstrap: %.0fms\\n", (microtime(true) - \$_SERVER['__PHP_T0']) * 1000);

        try {
            // Step 1: Resolve ComponentRegistry
            if (\$stopAt >= 1) {
                \$t = microtime(true);
                \$registry = \$app->make(\\Livewire\\Mechanisms\\ComponentRegistry::class);
                echo sprintf("Step 1 - Registry: %.0fms\\n", (microtime(true) - \$t) * 1000);
            }

            // Step 2: Create component instance
            if (\$stopAt >= 2) {
                \$t = microtime(true);
                \$component = \$registry->new('filament.auth.pages.login');
                echo sprintf("Step 2 - Component new(): %.0fms\\n", (microtime(true) - \$t) * 1000);
            }

            // Step 3: Set component ID
            if (\$stopAt >= 3) {
                \$t = microtime(true);
                \$component->setId('test-id');
                echo sprintf("Step 3 - setId: %.0fms\\n", (microtime(true) - \$t) * 1000);
            }

            // Step 4: Trigger 'mount' event (fires all 23+ component hooks)
            if (\$stopAt >= 4) {
                \$t = microtime(true);
                \$finish = \\Livewire\\trigger('mount', \$component, [], 'test-key', null);
                echo sprintf("Step 4 - trigger(mount): %.0fms\\n", (microtime(true) - \$t) * 1000);
            }

            // Step 5: Call component mount()
            if (\$stopAt >= 5) {
                \$t = microtime(true);
                if (method_exists(\$component, 'mount')) {
                    \$component->mount();
                }
                echo sprintf("Step 5 - mount(): %.0fms\\n", (microtime(true) - \$t) * 1000);
            }

            // Step 6: Render the component
            if (\$stopAt >= 6) {
                \$t = microtime(true);
                \$hc = \$app->make(\\Livewire\\Mechanisms\\HandleComponents\\HandleComponents::class);
                \$renderMethod = new \\ReflectionMethod(\$hc, 'render');
                \$renderMethod->setAccessible(true);
                [\$html] = \$renderMethod->invoke(\$hc, \$component, '<div></div>');
                echo sprintf("Step 6 - render: %.0fms (%d bytes)\\n",
                    (microtime(true) - \$t) * 1000, strlen(\$html));
            }

            // Step 7: Finish hooks
            if (\$stopAt >= 7 && isset(\$finish)) {
                \$t = microtime(true);
                \$finish(\$component, \$html ?? '');
                echo sprintf("Step 7 - finish: %.0fms\\n", (microtime(true) - \$t) * 1000);
            }
        } catch (\\Throwable \$e) {
            echo sprintf("FAILED: %s\\n", \$e->getMessage());
            echo "  " . \$e->getFile() . ":" . \$e->getLine() . "\\n";
        }

        echo sprintf("\\nTotal: %.0fms\\n", (microtime(true) - \$_SERVER['__PHP_T0']) * 1000);
        exit(0);
    }
    if (\$diag === 'hooks') {
        // Test each Livewire mount hook individually by iterating EventBus listeners
        require '/app/vendor/autoload.php';
        \$app = require '/app/bootstrap/app.php';
        \$request = \\Illuminate\\Http\\Request::create('/dashboard/login', 'GET');
        \$app->instance('request', \$request);
        \$app->bootstrapWith([
            \\Illuminate\\Foundation\\Bootstrap\\LoadEnvironmentVariables::class,
            \\Illuminate\\Foundation\\Bootstrap\\LoadConfiguration::class,
            \\Illuminate\\Foundation\\Bootstrap\\HandleExceptions::class,
            \\Illuminate\\Foundation\\Bootstrap\\RegisterFacades::class,
            \\Illuminate\\Foundation\\Bootstrap\\RegisterProviders::class,
            \\Illuminate\\Foundation\\Bootstrap\\BootProviders::class,
        ]);
        \$filament = \$app->make(\\Filament\\FilamentManager::class);
        \$filament->setCurrentPanel(\$filament->getPanel('cachet'));
        \$filament->bootCurrentPanel();
        echo sprintf("Bootstrap: %.0fms\\n\\n", (microtime(true) - \$_SERVER['__PHP_T0']) * 1000);

        // Create the component
        \$registry = \$app->make(\\Livewire\\Mechanisms\\ComponentRegistry::class);
        \$component = \$registry->new('filament.auth.pages.login');
        \$component->setId('test-id');

        // Access the EventBus listeners for 'mount'
        \$bus = \$app->make(\\Livewire\\EventBus::class);
        \$ref = new \\ReflectionObject(\$bus);

        \$allListeners = [];
        foreach (['listenersBefore', 'listeners', 'listenersAfter'] as \$queueName) {
            \$prop = \$ref->getProperty(\$queueName);
            \$prop->setAccessible(true);
            \$queue = \$prop->getValue(\$bus);
            if (isset(\$queue['mount'])) {
                foreach (\$queue['mount'] as \$i => \$listener) {
                    \$allListeners[] = ['queue' => \$queueName, 'index' => \$i, 'fn' => \$listener];
                }
            }
        }

        echo sprintf("Total mount listeners: %d\\n\\n", count(\$allListeners));

        // Call each listener one at a time with timing
        foreach (\$allListeners as \$idx => \$entry) {
            \$t = microtime(true);
            try {
                \$result = (\$entry['fn'])(\$component, [], 'test-key', null);
                \$elapsed = (microtime(true) - \$t) * 1000;
                \$type = is_callable(\$result) ? 'has-finisher' : 'no-finisher';
                echo sprintf("Hook #%d (%s[%d]): %.1fms [%s]\\n",
                    \$idx, \$entry['queue'], \$entry['index'], \$elapsed, \$type);
            } catch (\\Throwable \$e) {
                \$elapsed = (microtime(true) - \$t) * 1000;
                echo sprintf("Hook #%d (%s[%d]): FAILED at %.1fms: %s\\n",
                    \$idx, \$entry['queue'], \$entry['index'], \$elapsed,
                    substr(\$e->getMessage(), 0, 80));
            }

            // Flush output to ensure we see results even if next hook hangs
            if (ob_get_level()) ob_flush();
            flush();
        }

        echo sprintf("\\nTotal: %.0fms\\n", (microtime(true) - \$_SERVER['__PHP_T0']) * 1000);
        exit(0);
    }
    // hook-N: call mount listeners 0 through N, stop before N+1
    if (preg_match('/^hook-(\\d+)$/', \$diag, \$m)) {
        \$stopAfter = (int)\$m[1];
        require '/app/vendor/autoload.php';
        \$app = require '/app/bootstrap/app.php';
        \$request = \\Illuminate\\Http\\Request::create('/dashboard/login', 'GET');
        \$app->instance('request', \$request);
        \$app->bootstrapWith([
            \\Illuminate\\Foundation\\Bootstrap\\LoadEnvironmentVariables::class,
            \\Illuminate\\Foundation\\Bootstrap\\LoadConfiguration::class,
            \\Illuminate\\Foundation\\Bootstrap\\HandleExceptions::class,
            \\Illuminate\\Foundation\\Bootstrap\\RegisterFacades::class,
            \\Illuminate\\Foundation\\Bootstrap\\RegisterProviders::class,
            \\Illuminate\\Foundation\\Bootstrap\\BootProviders::class,
        ]);
        \$filament = \$app->make(\\Filament\\FilamentManager::class);
        \$filament->setCurrentPanel(\$filament->getPanel('cachet'));
        \$filament->bootCurrentPanel();

        \$registry = \$app->make(\\Livewire\\Mechanisms\\ComponentRegistry::class);
        \$component = \$registry->new('filament.auth.pages.login');
        \$component->setId('test-id');

        \$bus = \$app->make(\\Livewire\\EventBus::class);
        \$ref = new \\ReflectionObject(\$bus);

        \$allListeners = [];
        foreach (['listenersBefore', 'listeners', 'listenersAfter'] as \$queueName) {
            \$prop = \$ref->getProperty(\$queueName);
            \$prop->setAccessible(true);
            \$queue = \$prop->getValue(\$bus);
            if (isset(\$queue['mount'])) {
                foreach (\$queue['mount'] as \$listener) {
                    \$allListeners[] = \$listener;
                }
            }
        }

        echo sprintf("Total listeners: %d, running 0-%d\\n", count(\$allListeners), \$stopAfter);

        // Also identify hook classes from ComponentHookRegistry
        \$hookRef = new \\ReflectionClass(\\Livewire\\ComponentHookRegistry::class);
        \$hooksProp = \$hookRef->getProperty('componentHooks');
        \$hooksProp->setAccessible(true);
        \$hookClasses = \$hooksProp->getValue();
        echo "Registered hook classes:\\n";
        foreach (\$hookClasses as \$i => \$hClass) {
            echo sprintf("  [%d] %s\\n", \$i, \$hClass);
        }
        echo "\\n";

        for (\$idx = 0; \$idx <= min(\$stopAfter, count(\$allListeners) - 1); \$idx++) {
            \$t = microtime(true);
            try {
                (\$allListeners[\$idx])(\$component, [], 'test-key', null);
                echo sprintf("#%d: %.1fms\\n", \$idx, (microtime(true) - \$t) * 1000);
            } catch (\\Throwable \$e) {
                echo sprintf("#%d: ERR at %.1fms: %s\\n", \$idx, (microtime(true) - \$t) * 1000,
                    substr(\$e->getMessage(), 0, 60));
            }
        }

        echo sprintf("\\nTotal: %.0fms\\n", (microtime(true) - \$_SERVER['__PHP_T0']) * 1000);
        exit(0);
    }
    if (\$diag === 'identify') {
        // Identify each mount listener by its source file and line
        require '/app/vendor/autoload.php';
        \$app = require '/app/bootstrap/app.php';
        \$request = \\Illuminate\\Http\\Request::create('/dashboard/login', 'GET');
        \$app->instance('request', \$request);
        \$app->bootstrapWith([
            \\Illuminate\\Foundation\\Bootstrap\\LoadEnvironmentVariables::class,
            \\Illuminate\\Foundation\\Bootstrap\\LoadConfiguration::class,
            \\Illuminate\\Foundation\\Bootstrap\\HandleExceptions::class,
            \\Illuminate\\Foundation\\Bootstrap\\RegisterFacades::class,
            \\Illuminate\\Foundation\\Bootstrap\\RegisterProviders::class,
            \\Illuminate\\Foundation\\Bootstrap\\BootProviders::class,
        ]);

        \$bus = \$app->make(\\Livewire\\EventBus::class);
        \$ref = new \\ReflectionObject(\$bus);

        \$idx = 0;
        foreach (['listenersBefore', 'listeners', 'listenersAfter'] as \$queueName) {
            \$prop = \$ref->getProperty(\$queueName);
            \$prop->setAccessible(true);
            \$queue = \$prop->getValue(\$bus);
            if (isset(\$queue['mount'])) {
                foreach (\$queue['mount'] as \$listener) {
                    \$closureRef = new \\ReflectionFunction(\$listener);
                    \$file = basename(\$closureRef->getFileName());
                    \$line = \$closureRef->getStartLine();
                    // Try to get the use() variables to identify the hook class
                    \$uses = \$closureRef->getStaticVariables();
                    \$hookClass = '';
                    if (isset(\$uses['hook'])) {
                        \$hookClass = is_string(\$uses['hook']) ? \$uses['hook'] : get_class(\$uses['hook']);
                    }
                    echo sprintf("#%d [%s] %s:%d %s\\n", \$idx, \$queueName, \$file, \$line,
                        \$hookClass ? "hook=" . basename(str_replace('\\\\\\\\', '/', \$hookClass)) : '');
                    \$idx++;
                }
            }
        }

        echo sprintf("\\nTotal: %d mount listeners\\n", \$idx);
        exit(0);
    }
    if (\$diag === 'attrs') {
        // Test attribute collection and boot on Login component
        require '/app/vendor/autoload.php';
        \$app = require '/app/bootstrap/app.php';
        \$request = \\Illuminate\\Http\\Request::create('/dashboard/login', 'GET');
        \$app->instance('request', \$request);
        \$app->bootstrapWith([
            \\Illuminate\\Foundation\\Bootstrap\\LoadEnvironmentVariables::class,
            \\Illuminate\\Foundation\\Bootstrap\\LoadConfiguration::class,
            \\Illuminate\\Foundation\\Bootstrap\\HandleExceptions::class,
            \\Illuminate\\Foundation\\Bootstrap\\RegisterFacades::class,
            \\Illuminate\\Foundation\\Bootstrap\\RegisterProviders::class,
            \\Illuminate\\Foundation\\Bootstrap\\BootProviders::class,
        ]);
        \$filament = \$app->make(\\Filament\\FilamentManager::class);
        \$filament->setCurrentPanel(\$filament->getPanel('cachet'));
        \$filament->bootCurrentPanel();

        \$registry = \$app->make(\\Livewire\\Mechanisms\\ComponentRegistry::class);
        \$component = \$registry->new('filament.auth.pages.login');
        \$component->setId('test-id');

        // Run hooks 0-24 first (they all complete in 0ms)
        \$bus = \$app->make(\\Livewire\\EventBus::class);
        \$ref = new \\ReflectionObject(\$bus);
        \$allListeners = [];
        foreach (['listenersBefore', 'listeners', 'listenersAfter'] as \$q) {
            \$p = \$ref->getProperty(\$q);
            \$p->setAccessible(true);
            \$v = \$p->getValue(\$bus);
            if (isset(\$v['mount'])) foreach (\$v['mount'] as \$l) \$allListeners[] = \$l;
        }
        for (\$i = 0; \$i < 25; \$i++) {
            try { (\$allListeners[\$i])(\$component, [], 'k', null); } catch (\\Throwable \$e) {}
        }
        echo sprintf("Hooks 0-24 done: %.0fms\\n", (microtime(true) - \$_SERVER['__PHP_T0']) * 1000);

        // Now manually replicate what hook #25 (SupportAttributes) does
        \$t = microtime(true);
        \$attrs = \$component->getAttributes();
        echo sprintf("getAttributes(): %.0fms, count=%d\\n", (microtime(true) - \$t) * 1000, \$attrs->count());

        // List all attribute classes
        \$byClass = [];
        foreach (\$attrs as \$attr) {
            \$cls = get_class(\$attr);
            \$byClass[\$cls] = (\$byClass[\$cls] ?? 0) + 1;
        }
        foreach (\$byClass as \$cls => \$cnt) {
            echo sprintf("  %s: %d\\n", basename(str_replace('\\\\', '/', \$cls)), \$cnt);
        }

        // Filter to Livewire Attribute instances (what SupportAttributes does)
        \$t = microtime(true);
        \$lwAttrs = \$attrs->filter(fn(\$a) => \$a instanceof \\Livewire\\Features\\SupportAttributes\\Attribute);
        echo sprintf("\\nLivewire attributes: %d (filter %.0fms)\\n", \$lwAttrs->count(), (microtime(true) - \$t) * 1000);

        // Try calling boot() on each, one at a time
        foreach (\$lwAttrs as \$idx => \$attr) {
            \$t = microtime(true);
            \$cls = get_class(\$attr);
            if (method_exists(\$attr, 'boot')) {
                try {
                    \$attr->boot();
                    echo sprintf("  boot #%d %s: %.1fms\\n", \$idx, basename(str_replace('\\\\', '/', \$cls)), (microtime(true) - \$t) * 1000);
                } catch (\\Throwable \$e) {
                    echo sprintf("  boot #%d %s: ERR %.1fms: %s\\n", \$idx, basename(str_replace('\\\\', '/', \$cls)),
                        (microtime(true) - \$t) * 1000, substr(\$e->getMessage(), 0, 60));
                }
            } else {
                echo sprintf("  #%d %s: no boot()\\n", \$idx, basename(str_replace('\\\\', '/', \$cls)));
            }
        }

        echo sprintf("\\nTotal: %.0fms\\n", (microtime(true) - \$_SERVER['__PHP_T0']) * 1000);
        exit(0);
    }
    if (\$diag === 'attrs2') {
        // Test attribute mount() instead of boot()
        require '/app/vendor/autoload.php';
        \$app = require '/app/bootstrap/app.php';
        \$request = \\Illuminate\\Http\\Request::create('/dashboard/login', 'GET');
        \$app->instance('request', \$request);
        \$app->bootstrapWith([
            \\Illuminate\\Foundation\\Bootstrap\\LoadEnvironmentVariables::class,
            \\Illuminate\\Foundation\\Bootstrap\\LoadConfiguration::class,
            \\Illuminate\\Foundation\\Bootstrap\\HandleExceptions::class,
            \\Illuminate\\Foundation\\Bootstrap\\RegisterFacades::class,
            \\Illuminate\\Foundation\\Bootstrap\\RegisterProviders::class,
            \\Illuminate\\Foundation\\Bootstrap\\BootProviders::class,
        ]);
        \$filament = \$app->make(\\Filament\\FilamentManager::class);
        \$filament->setCurrentPanel(\$filament->getPanel('cachet'));
        \$filament->bootCurrentPanel();

        \$registry = \$app->make(\\Livewire\\Mechanisms\\ComponentRegistry::class);
        \$component = \$registry->new('filament.auth.pages.login');
        \$component->setId('test-id');

        // Run hooks 0-24 first
        \$bus = \$app->make(\\Livewire\\EventBus::class);
        \$ref = new \\ReflectionObject(\$bus);
        \$allListeners = [];
        foreach (['listenersBefore', 'listeners', 'listenersAfter'] as \$q) {
            \$p = \$ref->getProperty(\$q);
            \$p->setAccessible(true);
            \$v = \$p->getValue(\$bus);
            if (isset(\$v['mount'])) foreach (\$v['mount'] as \$l) \$allListeners[] = \$l;
        }
        for (\$i = 0; \$i < 25; \$i++) {
            try { (\$allListeners[\$i])(\$component, [], 'k', null); } catch (\\Throwable \$e) {}
        }
        echo sprintf("Hooks 0-24 done: %.0fms\\n", (microtime(true) - \$_SERVER['__PHP_T0']) * 1000);

        \$t = microtime(true);
        \$attrs = \$component->getAttributes();
        \$lwAttrs = \$attrs->filter(fn(\$a) => \$a instanceof \\Livewire\\Features\\SupportAttributes\\Attribute);
        echo sprintf("Got %d Livewire attrs: %.0fms\\n", \$lwAttrs->count(), (microtime(true) - \$t) * 1000);

        // Test mount() on each attribute individually
        foreach (\$lwAttrs as \$idx => \$attr) {
            \$t = microtime(true);
            \$cls = get_class(\$attr);
            \$short = basename(str_replace('\\\\', '/', \$cls));
            if (method_exists(\$attr, 'mount')) {
                echo sprintf("  mount #%d %s (name=%s)... ", \$idx, \$short, \$attr->getName());
                try {
                    \$attr->mount();
                    echo sprintf("%.1fms\\n", (microtime(true) - \$t) * 1000);
                } catch (\\Throwable \$e) {
                    echo sprintf("ERR %.1fms: %s\\n", (microtime(true) - \$t) * 1000, substr(\$e->getMessage(), 0, 80));
                }
            } else {
                echo sprintf("  #%d %s: no mount()\\n", \$idx, \$short);
            }
        }

        echo sprintf("\\nTotal: %.0fms\\n", (microtime(true) - \$_SERVER['__PHP_T0']) * 1000);
        exit(0);
    }
    if (preg_match('/^amnt-(\\d+)$/', \$diag, \$m)) {
        // Test mount() on a single attribute by index
        \$target = (int)\$m[1];
        require '/app/vendor/autoload.php';
        \$app = require '/app/bootstrap/app.php';
        \$request = \\Illuminate\\Http\\Request::create('/dashboard/login', 'GET');
        \$app->instance('request', \$request);
        \$app->bootstrapWith([
            \\Illuminate\\Foundation\\Bootstrap\\LoadEnvironmentVariables::class,
            \\Illuminate\\Foundation\\Bootstrap\\LoadConfiguration::class,
            \\Illuminate\\Foundation\\Bootstrap\\HandleExceptions::class,
            \\Illuminate\\Foundation\\Bootstrap\\RegisterFacades::class,
            \\Illuminate\\Foundation\\Bootstrap\\RegisterProviders::class,
            \\Illuminate\\Foundation\\Bootstrap\\BootProviders::class,
        ]);
        \$filament = \$app->make(\\Filament\\FilamentManager::class);
        \$filament->setCurrentPanel(\$filament->getPanel('cachet'));
        \$filament->bootCurrentPanel();

        \$registry = \$app->make(\\Livewire\\Mechanisms\\ComponentRegistry::class);
        \$component = \$registry->new('filament.auth.pages.login');
        \$component->setId('test-id');

        // Run hooks 0-24
        \$bus = \$app->make(\\Livewire\\EventBus::class);
        \$ref = new \\ReflectionObject(\$bus);
        \$allListeners = [];
        foreach (['listenersBefore', 'listeners', 'listenersAfter'] as \$q) {
            \$p = \$ref->getProperty(\$q);
            \$p->setAccessible(true);
            \$v = \$p->getValue(\$bus);
            if (isset(\$v['mount'])) foreach (\$v['mount'] as \$l) \$allListeners[] = \$l;
        }
        for (\$i = 0; \$i < 25; \$i++) {
            try { (\$allListeners[\$i])(\$component, [], 'k', null); } catch (\\Throwable \$e) {}
        }

        \$attrs = \$component->getAttributes();
        \$lwAttrs = \$attrs->filter(fn(\$a) => \$a instanceof \\Livewire\\Features\\SupportAttributes\\Attribute)->values();
        echo sprintf("Got %d Livewire attrs, testing mount on #%d\\n", \$lwAttrs->count(), \$target);

        if (\$target >= \$lwAttrs->count()) {
            echo "Index out of range\\n";
            exit(0);
        }

        \$attr = \$lwAttrs[\$target];
        \$cls = get_class(\$attr);
        \$short = basename(str_replace('\\\\', '/', \$cls));
        echo sprintf("Attr #%d: %s (name=%s, level=%s)\\n", \$target, \$cls, \$attr->getName(), \$attr->getLevel()->name ?? 'unknown');
        echo sprintf("Has mount: %s\\n", method_exists(\$attr, 'mount') ? 'yes' : 'no');

        if (method_exists(\$attr, 'mount')) {
            \$t = microtime(true);
            echo "Calling mount()...\\n";
            try {
                \$attr->mount();
                echo sprintf("mount() done: %.1fms\\n", (microtime(true) - \$t) * 1000);
            } catch (\\Throwable \$e) {
                echo sprintf("mount() ERR: %.1fms: %s\\n  %s\\n", (microtime(true) - \$t) * 1000, \$e->getMessage(), \$e->getTraceAsString());
            }
        }

        echo sprintf("Total: %.0fms\\n", (microtime(true) - \$_SERVER['__PHP_T0']) * 1000);
        exit(0);
    }
    if (preg_match('/^h25-(\\d+)$/', \$diag, \$m)) {
        // Step-by-step test of hook #25's listener closure
        \$step = (int)\$m[1];
        require '/app/vendor/autoload.php';
        \$app = require '/app/bootstrap/app.php';
        \$request = \\Illuminate\\Http\\Request::create('/dashboard/login', 'GET');
        \$app->instance('request', \$request);
        \$app->bootstrapWith([
            \\Illuminate\\Foundation\\Bootstrap\\LoadEnvironmentVariables::class,
            \\Illuminate\\Foundation\\Bootstrap\\LoadConfiguration::class,
            \\Illuminate\\Foundation\\Bootstrap\\HandleExceptions::class,
            \\Illuminate\\Foundation\\Bootstrap\\RegisterFacades::class,
            \\Illuminate\\Foundation\\Bootstrap\\RegisterProviders::class,
            \\Illuminate\\Foundation\\Bootstrap\\BootProviders::class,
        ]);
        \$filament = \$app->make(\\Filament\\FilamentManager::class);
        \$filament->setCurrentPanel(\$filament->getPanel('cachet'));
        \$filament->bootCurrentPanel();

        \$registry = \$app->make(\\Livewire\\Mechanisms\\ComponentRegistry::class);
        \$component = \$registry->new('filament.auth.pages.login');
        \$component->setId('test-id');

        // Get mount listeners
        \$bus = \$app->make(\\Livewire\\EventBus::class);
        \$ref = new \\ReflectionObject(\$bus);
        \$allListeners = [];
        foreach (['listenersBefore', 'listeners', 'listenersAfter'] as \$q) {
            \$p = \$ref->getProperty(\$q);
            \$p->setAccessible(true);
            \$v = \$p->getValue(\$bus);
            if (isset(\$v['mount'])) foreach (\$v['mount'] as \$l) \$allListeners[] = \$l;
        }
        echo sprintf("Total mount listeners: %d\\n", count(\$allListeners));

        // Run hooks 0-24
        for (\$i = 0; \$i < 25; \$i++) {
            try { (\$allListeners[\$i])(\$component, [], 'k', null); } catch (\\Throwable \$e) {}
        }
        echo sprintf("Hooks 0-24 done: %.0fms\\n", (microtime(true) - \$_SERVER['__PHP_T0']) * 1000);

        // Inspect hook #25's closure
        \$listener = \$allListeners[25];
        \$closureRef = new \\ReflectionFunction(\$listener);
        \$vars = \$closureRef->getStaticVariables();
        echo sprintf("Hook #25 closure vars: %s\\n", json_encode(array_map(fn(\$v) => is_object(\$v) ? get_class(\$v) : (is_string(\$v) ? \$v : gettype(\$v)), \$vars)));
        echo sprintf("Hook #25 defined in: %s:%d\\n", \$closureRef->getFileName(), \$closureRef->getStartLine());

        if (\$step >= 1) {
            // Step 1: initializeHook
            \$hookClass = \$vars['hook'] ?? null;
            echo sprintf("\\nStep 1: initializeHook(%s)\\n", \$hookClass);
            \$t = microtime(true);
            \$hook = \\Livewire\\ComponentHookRegistry::initializeHook(\$hookClass, \$component);
            echo sprintf("  initializeHook: %.1fms, result=%s\\n", (microtime(true) - \$t) * 1000, \$hook ? get_class(\$hook) : 'null');
        }

        if (\$step >= 2 && \$hook) {
            // Step 2: callBoot
            echo "\\nStep 2: callBoot()\\n";
            \$t = microtime(true);
            \$hook->callBoot();
            echo sprintf("  callBoot: %.1fms\\n", (microtime(true) - \$t) * 1000);
        }

        if (\$step >= 3 && \$hook) {
            // Step 3: callMount
            echo "\\nStep 3: callMount([], null)\\n";
            \$t = microtime(true);
            \$hook->callMount([], null);
            echo sprintf("  callMount: %.1fms\\n", (microtime(true) - \$t) * 1000);
        }

        echo sprintf("\\nTotal: %.0fms\\n", (microtime(true) - \$_SERVER['__PHP_T0']) * 1000);
        exit(0);
    }
    if (\$diag === 'h25-mount') {
        // Exact replication of what SupportAttributes::mount() does via callMount
        require '/app/vendor/autoload.php';
        \$app = require '/app/bootstrap/app.php';
        \$request = \\Illuminate\\Http\\Request::create('/dashboard/login', 'GET');
        \$app->instance('request', \$request);
        \$app->bootstrapWith([
            \\Illuminate\\Foundation\\Bootstrap\\LoadEnvironmentVariables::class,
            \\Illuminate\\Foundation\\Bootstrap\\LoadConfiguration::class,
            \\Illuminate\\Foundation\\Bootstrap\\HandleExceptions::class,
            \\Illuminate\\Foundation\\Bootstrap\\RegisterFacades::class,
            \\Illuminate\\Foundation\\Bootstrap\\RegisterProviders::class,
            \\Illuminate\\Foundation\\Bootstrap\\BootProviders::class,
        ]);
        \$filament = \$app->make(\\Filament\\FilamentManager::class);
        \$filament->setCurrentPanel(\$filament->getPanel('cachet'));
        \$filament->bootCurrentPanel();

        \$registry = \$app->make(\\Livewire\\Mechanisms\\ComponentRegistry::class);
        \$component = \$registry->new('filament.auth.pages.login');
        \$component->setId('test-id');

        // Run hooks 0-24
        \$bus = \$app->make(\\Livewire\\EventBus::class);
        \$ref = new \\ReflectionObject(\$bus);
        \$allListeners = [];
        foreach (['listenersBefore', 'listeners', 'listenersAfter'] as \$q) {
            \$p = \$ref->getProperty(\$q);
            \$p->setAccessible(true);
            \$v = \$p->getValue(\$bus);
            if (isset(\$v['mount'])) foreach (\$v['mount'] as \$l) \$allListeners[] = \$l;
        }
        for (\$i = 0; \$i < 25; \$i++) {
            try { (\$allListeners[\$i])(\$component, [], 'k', null); } catch (\\Throwable \$e) {}
        }
        echo sprintf("Hooks 0-24 done: %.0fms\\n", (microtime(true) - \$_SERVER['__PHP_T0']) * 1000);

        // Initialize hook like ComponentHookRegistry does
        \$hook = \\Livewire\\ComponentHookRegistry::initializeHook(
            \\Livewire\\Features\\SupportAttributes\\SupportAttributes::class, \$component
        );
        \$hook->callBoot();
        echo "initializeHook+callBoot: OK\\n";

        // Now manually replicate SupportAttributes::mount(...$params) with $params = [[], null]
        \$params = [[], null]; // This is what callMount([], null) passes via mount(...$params)

        \$t = microtime(true);
        \$attrs = \$component->getAttributes();
        echo sprintf("getAttributes: %.1fms, count=%d\\n", (microtime(true) - \$t) * 1000, \$attrs->count());

        \$t = microtime(true);
        \$filtered = \$attrs->filter(fn(\$a) => \$a instanceof \\Livewire\\Features\\SupportAttributes\\Attribute);
        echo sprintf("whereInstanceOf filter: %.1fms, count=%d\\n", (microtime(true) - \$t) * 1000, \$filtered->count());

        foreach (\$filtered as \$idx => \$attribute) {
            \$cls = basename(str_replace('\\\\', '/', get_class(\$attribute)));
            if (method_exists(\$attribute, 'mount')) {
                \$t = microtime(true);
                try {
                    \$attribute->mount(...\$params);
                    echo sprintf("  mount #%d %s(name=%s): %.1fms\\n", \$idx, \$cls, \$attribute->getName(), (microtime(true) - \$t) * 1000);
                } catch (\\Throwable \$e) {
                    echo sprintf("  mount #%d %s ERR: %s\\n", \$idx, \$cls, \$e->getMessage());
                }
            } else {
                echo sprintf("  skip #%d %s (no mount)\\n", \$idx, \$cls);
            }
        }

        echo sprintf("\\nDone: %.0fms\\n", (microtime(true) - \$_SERVER['__PHP_T0']) * 1000);
        exit(0);
    }
    if (preg_match('/^h25-m(\\d+)$/', \$diag, \$m)) {
        // Variant tests for SupportAttributes::mount
        // m1=no callBoot, m2=no params, m3=callBoot+all-mount-no-params, m4=callBoot+first-url-only
        \$variant = (int)\$m[1];
        require '/app/vendor/autoload.php';
        \$app = require '/app/bootstrap/app.php';
        \$request = \\Illuminate\\Http\\Request::create('/dashboard/login', 'GET');
        \$app->instance('request', \$request);
        \$app->bootstrapWith([
            \\Illuminate\\Foundation\\Bootstrap\\LoadEnvironmentVariables::class,
            \\Illuminate\\Foundation\\Bootstrap\\LoadConfiguration::class,
            \\Illuminate\\Foundation\\Bootstrap\\HandleExceptions::class,
            \\Illuminate\\Foundation\\Bootstrap\\RegisterFacades::class,
            \\Illuminate\\Foundation\\Bootstrap\\RegisterProviders::class,
            \\Illuminate\\Foundation\\Bootstrap\\BootProviders::class,
        ]);
        \$filament = \$app->make(\\Filament\\FilamentManager::class);
        \$filament->setCurrentPanel(\$filament->getPanel('cachet'));
        \$filament->bootCurrentPanel();

        \$registry = \$app->make(\\Livewire\\Mechanisms\\ComponentRegistry::class);
        \$component = \$registry->new('filament.auth.pages.login');
        \$component->setId('test-id');

        \$bus = \$app->make(\\Livewire\\EventBus::class);
        \$ref = new \\ReflectionObject(\$bus);
        \$allListeners = [];
        foreach (['listenersBefore', 'listeners', 'listenersAfter'] as \$q) {
            \$p = \$ref->getProperty(\$q);
            \$p->setAccessible(true);
            \$v = \$p->getValue(\$bus);
            if (isset(\$v['mount'])) foreach (\$v['mount'] as \$l) \$allListeners[] = \$l;
        }
        for (\$i = 0; \$i < 25; \$i++) {
            try { (\$allListeners[\$i])(\$component, [], 'k', null); } catch (\\Throwable \$e) {}
        }
        echo sprintf("Hooks 0-24: %.0fms\\n", (microtime(true) - \$_SERVER['__PHP_T0']) * 1000);

        \$hook = \\Livewire\\ComponentHookRegistry::initializeHook(
            \\Livewire\\Features\\SupportAttributes\\SupportAttributes::class, \$component
        );

        if (\$variant >= 2) {
            echo "Calling callBoot()...\\n";
            \$hook->callBoot();
            echo "callBoot done\\n";
        } else {
            echo "SKIPPING callBoot\\n";
        }

        \$attrs = \$component->getAttributes();
        \$filtered = \$attrs->filter(fn(\$a) => \$a instanceof \\Livewire\\Features\\SupportAttributes\\Attribute);
        echo sprintf("Livewire attrs: %d\\n", \$filtered->count());

        if (\$variant === 1) {
            // No callBoot, mount all with params
            echo "Mounting all with params [[], null]...\\n";
            foreach (\$filtered as \$idx => \$attr) {
                if (method_exists(\$attr, 'mount')) {
                    \$attr->mount([], null);
                    echo sprintf("  #%d %s: OK\\n", \$idx, \$attr->getName());
                }
            }
        } elseif (\$variant === 2) {
            // With callBoot, mount all with NO params
            echo "Mounting all with NO params...\\n";
            foreach (\$filtered as \$idx => \$attr) {
                if (method_exists(\$attr, 'mount')) {
                    \$attr->mount();
                    echo sprintf("  #%d %s: OK\\n", \$idx, \$attr->getName());
                }
            }
        } elseif (\$variant === 3) {
            // With callBoot, mount all with params [[], null]
            echo "Mounting all with params [[], null]...\\n";
            foreach (\$filtered as \$idx => \$attr) {
                if (method_exists(\$attr, 'mount')) {
                    \$attr->mount([], null);
                    echo sprintf("  #%d %s: OK\\n", \$idx, \$attr->getName());
                }
            }
        } elseif (\$variant === 4) {
            // With callBoot, use actual callMount
            echo "Calling hook->callMount([], null)...\\n";
            \$hook->callMount([], null);
            echo "callMount done\\n";
        }

        echo sprintf("\\nTotal: %.0fms\\n", (microtime(true) - \$_SERVER['__PHP_T0']) * 1000);
        exit(0);
    }
    if (preg_match('/^u(\\d+)$/', \$diag, \$m)) {
        // Call uniqid N times
        \$n = (int)\$m[1];
        for (\$i = 0; \$i < \$n; \$i++) {
            \$val = uniqid('t', true);
        }
        echo "uniqid x" . \$n . " done, last=" . \$val . "\\n";
        exit(0);
    }
    if (\$diag === 'uslp') {
        echo "before usleep\\n";
        usleep(1);
        echo "after usleep\\n";
        exit(0);
    }
    if (preg_match('/^mnt2-(\\d+)$/', \$diag, \$m)) {
        // Mount N Url attributes sequentially on same component
        \$count = (int)\$m[1];
        require '/app/vendor/autoload.php';
        \$app = require '/app/bootstrap/app.php';
        \$request = \\Illuminate\\Http\\Request::create('/dashboard/login', 'GET');
        \$app->instance('request', \$request);
        \$app->bootstrapWith([
            \\Illuminate\\Foundation\\Bootstrap\\LoadEnvironmentVariables::class,
            \\Illuminate\\Foundation\\Bootstrap\\LoadConfiguration::class,
            \\Illuminate\\Foundation\\Bootstrap\\HandleExceptions::class,
            \\Illuminate\\Foundation\\Bootstrap\\RegisterFacades::class,
            \\Illuminate\\Foundation\\Bootstrap\\RegisterProviders::class,
            \\Illuminate\\Foundation\\Bootstrap\\BootProviders::class,
        ]);
        \$filament = \$app->make(\\Filament\\FilamentManager::class);
        \$filament->setCurrentPanel(\$filament->getPanel('cachet'));
        \$filament->bootCurrentPanel();

        \$registry = \$app->make(\\Livewire\\Mechanisms\\ComponentRegistry::class);
        \$component = \$registry->new('filament.auth.pages.login');
        \$component->setId('test-id');

        \$bus = \$app->make(\\Livewire\\EventBus::class);
        \$ref = new \\ReflectionObject(\$bus);
        \$allListeners = [];
        foreach (['listenersBefore', 'listeners', 'listenersAfter'] as \$q) {
            \$p = \$ref->getProperty(\$q);
            \$p->setAccessible(true);
            \$v = \$p->getValue(\$bus);
            if (isset(\$v['mount'])) foreach (\$v['mount'] as \$l) \$allListeners[] = \$l;
        }
        for (\$i = 0; \$i < 25; \$i++) {
            try { (\$allListeners[\$i])(\$component, [], 'k', null); } catch (\\Throwable \$e) {}
        }
        echo sprintf("Hooks 0-24: %.0fms\\n", (microtime(true) - \$_SERVER['__PHP_T0']) * 1000);

        \$attrs = \$component->getAttributes();
        \$urlAttrs = \$attrs->filter(fn(\$a) => \$a instanceof \\Livewire\\Attributes\\Url)->values();
        echo sprintf("Url attrs: %d, mounting first %d\\n", \$urlAttrs->count(), \$count);

        for (\$i = 0; \$i < min(\$count, \$urlAttrs->count()); \$i++) {
            \$attr = \$urlAttrs[\$i];
            \$t = microtime(true);
            echo sprintf("  mount #%d %s... ", \$i, \$attr->getName());
            \$attr->mount();
            echo sprintf("%.1fms\\n", (microtime(true) - \$t) * 1000);
        }

        echo sprintf("\\nTotal: %.0fms\\n", (microtime(true) - \$_SERVER['__PHP_T0']) * 1000);
        exit(0);
    }
    if (preg_match('/^mnt3-(\\d+)$/', \$diag, \$m)) {
        // Ultra-minimal test: mount Url attr #0, then try to mount Url attr #N
        \$second = (int)\$m[1];
        require '/app/vendor/autoload.php';
        \$app = require '/app/bootstrap/app.php';
        \$request = \\Illuminate\\Http\\Request::create('/dashboard/login', 'GET');
        \$app->instance('request', \$request);
        \$app->bootstrapWith([
            \\Illuminate\\Foundation\\Bootstrap\\LoadEnvironmentVariables::class,
            \\Illuminate\\Foundation\\Bootstrap\\LoadConfiguration::class,
            \\Illuminate\\Foundation\\Bootstrap\\HandleExceptions::class,
            \\Illuminate\\Foundation\\Bootstrap\\RegisterFacades::class,
            \\Illuminate\\Foundation\\Bootstrap\\RegisterProviders::class,
            \\Illuminate\\Foundation\\Bootstrap\\BootProviders::class,
        ]);
        \$filament = \$app->make(\\Filament\\FilamentManager::class);
        \$filament->setCurrentPanel(\$filament->getPanel('cachet'));
        \$filament->bootCurrentPanel();

        \$registry = \$app->make(\\Livewire\\Mechanisms\\ComponentRegistry::class);
        \$component = \$registry->new('filament.auth.pages.login');
        \$component->setId('test-id');

        \$bus = \$app->make(\\Livewire\\EventBus::class);
        \$ref = new \\ReflectionObject(\$bus);
        \$allListeners = [];
        foreach (['listenersBefore', 'listeners', 'listenersAfter'] as \$q) {
            \$p = \$ref->getProperty(\$q);
            \$p->setAccessible(true);
            \$v = \$p->getValue(\$bus);
            if (isset(\$v['mount'])) foreach (\$v['mount'] as \$l) \$allListeners[] = \$l;
        }
        for (\$i = 0; \$i < 25; \$i++) {
            try { (\$allListeners[\$i])(\$component, [], 'k', null); } catch (\\Throwable \$e) {}
        }

        \$attrs = \$component->getAttributes();
        \$urlAttrs = \$attrs->filter(fn(\$a) => \$a instanceof \\Livewire\\Attributes\\Url)->values();

        // Mount first Url attr
        echo sprintf("Mounting #0 (%s)... ", \$urlAttrs[0]->getName());
        \$urlAttrs[0]->mount();
        echo "OK\\n";

        if (\$second === 0) {
            echo "Skipping second mount\\n";
        } else {
            // Try mounting second Url attr
            \$idx = min(\$second, \$urlAttrs->count() - 1);
            echo sprintf("Mounting #%d (%s)... ", \$idx, \$urlAttrs[\$idx]->getName());
            \$urlAttrs[\$idx]->mount();
            echo "OK\\n";
        }

        echo sprintf("Total: %.0fms\\n", (microtime(true) - \$_SERVER['__PHP_T0']) * 1000);
        exit(0);
    }
    if (\$diag === 'nomnt') {
        // Just iterate Url attributes without mounting
        require '/app/vendor/autoload.php';
        \$app = require '/app/bootstrap/app.php';
        \$request = \\Illuminate\\Http\\Request::create('/dashboard/login', 'GET');
        \$app->instance('request', \$request);
        \$app->bootstrapWith([
            \\Illuminate\\Foundation\\Bootstrap\\LoadEnvironmentVariables::class,
            \\Illuminate\\Foundation\\Bootstrap\\LoadConfiguration::class,
            \\Illuminate\\Foundation\\Bootstrap\\HandleExceptions::class,
            \\Illuminate\\Foundation\\Bootstrap\\RegisterFacades::class,
            \\Illuminate\\Foundation\\Bootstrap\\RegisterProviders::class,
            \\Illuminate\\Foundation\\Bootstrap\\BootProviders::class,
        ]);
        \$filament = \$app->make(\\Filament\\FilamentManager::class);
        \$filament->setCurrentPanel(\$filament->getPanel('cachet'));
        \$filament->bootCurrentPanel();

        \$registry = \$app->make(\\Livewire\\Mechanisms\\ComponentRegistry::class);
        \$component = \$registry->new('filament.auth.pages.login');
        \$component->setId('test-id');

        \$bus = \$app->make(\\Livewire\\EventBus::class);
        \$ref = new \\ReflectionObject(\$bus);
        \$allListeners = [];
        foreach (['listenersBefore', 'listeners', 'listenersAfter'] as \$q) {
            \$p = \$ref->getProperty(\$q);
            \$p->setAccessible(true);
            \$v = \$p->getValue(\$bus);
            if (isset(\$v['mount'])) foreach (\$v['mount'] as \$l) \$allListeners[] = \$l;
        }
        for (\$i = 0; \$i < 25; \$i++) {
            try { (\$allListeners[\$i])(\$component, [], 'k', null); } catch (\\Throwable \$e) {}
        }

        \$attrs = \$component->getAttributes();
        \$filtered = \$attrs->filter(fn(\$a) => \$a instanceof \\Livewire\\Features\\SupportAttributes\\Attribute);
        echo sprintf("Total attrs: %d\\n", \$filtered->count());
        foreach (\$filtered as \$idx => \$attr) {
            echo sprintf("  #%d %s name=%s has_mount=%s\\n", \$idx, get_class(\$attr), \$attr->getName(), method_exists(\$attr, 'mount') ? 'Y' : 'N');
        }
        echo sprintf("Total: %.0fms\\n", (microtime(true) - \$_SERVER['__PHP_T0']) * 1000);
        exit(0);
    }
    echo "Unknown: \$diag\\n";
    exit(0);
}`);

  // Include class preloader if it exists (generated by laraworker:build)
  stubs.push(`
// Class preloader — eliminates per-class autoloader lookups in WASM
if (file_exists('/app/bootstrap/preload.php')) {
    require_once '/app/bootstrap/preload.php';
}

// Autoloader timing — track how much time is spent loading classes
\$_SERVER['__AUTOLOAD_COUNT'] = 0;
\$_SERVER['__AUTOLOAD_TIME'] = 0.0;
spl_autoload_register(function(\$class) {
    \$t = microtime(true);
    // Let the real autoloader do its thing by returning false
    return;
}, true, true);
// Wrap the existing autoloader to measure class loading time
\$_SERVER['__AUTOLOAD_WRAP'] = function() {
    \$loaders = spl_autoload_functions();
    // Remove our timing loader (it's first due to prepend=true)
    spl_autoload_unregister(\$loaders[0]);
    // Replace the Composer autoloader with a timing wrapper
    if (count(\$loaders) > 1) {
        \$original = \$loaders[1];
        spl_autoload_unregister(\$original);
        spl_autoload_register(function(\$class) use (\$original) {
            \$_SERVER['__AUTOLOAD_COUNT']++;
            \$n = \$_SERVER['__AUTOLOAD_COUNT'];
            \$now = microtime(true);
            \$total = (\$now - \$_SERVER['__PHP_T0']) * 1000;
            // Detect long gaps between class loads (>2 seconds)
            if (\$_SERVER['__PHP_LAST_MILESTONE'] > 0) {
                \$gap = (\$now - \$_SERVER['__PHP_LAST_MILESTONE']) * 1000;
                if (\$gap > 2000) {
                    error_log(sprintf('[php-gap] %.0fms gap before class #%d: %s', \$gap, \$n, \$class));
                }
            }
            \$_SERVER['__PHP_LAST_MILESTONE'] = \$now;
            // After class #650, log BEFORE loading to catch hanging class
            if (\$n > 650) {
                error_log(sprintf('[php-loading] #%d at %.0fms: %s', \$n, \$total, \$class));
            }
            \$t = microtime(true);
            \$original(\$class);
            \$elapsed = microtime(true) - \$t;
            \$_SERVER['__AUTOLOAD_TIME'] += \$elapsed;
            // Log every 25th class
            if (\$n % 25 === 0) {
                \$total = (microtime(true) - \$_SERVER['__PHP_T0']) * 1000;
                error_log(sprintf('[php-autoload] #%d at %.0fms: %s (%.0fms)',
                    \$n, \$total, \$class, \$elapsed * 1000));
            }
            if (\$elapsed > 0.05) {
                error_log(sprintf('[php-slow-class] %s took %.0fms', \$class, \$elapsed * 1000));
            }
        });
    }
};
\$_SERVER['__AUTOLOAD_WRAP']();

register_shutdown_function(function() {
    \$total = (microtime(true) - \$_SERVER['__PHP_T0']) * 1000;
    \$autoload = \$_SERVER['__AUTOLOAD_TIME'] * 1000;
    \$autoloadCount = \$_SERVER['__AUTOLOAD_COUNT'];
    error_log(sprintf('[php-time] total=%.0fms autoload=%.0fms classes=%d uri=%s',
        \$total, \$autoload, \$autoloadCount, \$_SERVER['REQUEST_URI'] ?? '?'));
});`);

  // The WASM PHP tokenizer is broken: token_get_all() treats all code after <?php
  // as a single T_STRING token instead of properly tokenizing. This breaks both:
  // 1. BladeCompiler::hasEvenNumberOfParentheses() — needs string-aware paren counting
  // 2. BladeCompiler::compileString()/parseToken() — needs T_INLINE_HTML for @directives
  //
  // PHP resolves bare function calls to the current namespace first, so defining
  // token_get_all in the Illuminate\View\Compilers namespace shadows the broken
  // global version for all BladeCompiler code.
  const bladeTokenizerFix = `
namespace Illuminate\\View\\Compilers {
    function token_get_all(string $code, int $flags = 0): array {
        $tokens = [];
        $len = strlen($code);
        $pos = 0;
        $line = 1;

        while ($pos < $len) {
            $nextOpen = strpos($code, '<?', $pos);

            if ($nextOpen === false) {
                $html = substr($code, $pos);
                if ($html !== '') {
                    $tokens[] = [T_INLINE_HTML, $html, $line];
                }
                break;
            }

            if ($nextOpen > $pos) {
                $html = substr($code, $pos, $nextOpen - $pos);
                $tokens[] = [T_INLINE_HTML, $html, $line];
                $line += substr_count($html, "\\n");
            }

            if (substr($code, $nextOpen, 5) === '<?php' && ($nextOpen + 5 >= $len || !ctype_alnum($code[$nextOpen + 5]))) {
                $tagEnd = $nextOpen + 5;
                if ($tagEnd < $len && ($code[$tagEnd] === ' ' || $code[$tagEnd] === "\\n" || $code[$tagEnd] === "\\r" || $code[$tagEnd] === "\\t")) {
                    $tagEnd++;
                }
                $openTag = substr($code, $nextOpen, $tagEnd - $nextOpen);
                $tokens[] = [T_OPEN_TAG, $openTag, $line];
                $line += substr_count($openTag, "\\n");
                $pos = $tagEnd;
            } elseif (substr($code, $nextOpen, 3) === '<?=') {
                $tokens[] = [T_OPEN_TAG_WITH_ECHO, '<?= ', $line];
                $pos = $nextOpen + 3;
                if ($pos < $len && $code[$pos] === ' ') $pos++;
            } else {
                $tokens[] = [T_INLINE_HTML, '<?', $line];
                $pos = $nextOpen + 2;
                continue;
            }

            $current = '';
            $inPhp = true;
            while ($pos < $len && $inPhp) {
                $char = $code[$pos];

                if ($char === '?' && $pos + 1 < $len && $code[$pos + 1] === '>') {
                    if ($current !== '') {
                        $tokens[] = [T_STRING, $current, $line];
                        $current = '';
                    }
                    $closeEnd = $pos + 2;
                    if ($closeEnd < $len && $code[$closeEnd] === "\\n") $closeEnd++;
                    $closeTag = substr($code, $pos, $closeEnd - $pos);
                    $tokens[] = [T_CLOSE_TAG, $closeTag, $line];
                    $line += substr_count($closeTag, "\\n");
                    $pos = $closeEnd;
                    $inPhp = false;
                    continue;
                }

                if ($char === '"' || $char === "'") {
                    if ($current !== '') {
                        $tokens[] = [T_STRING, $current, $line];
                        $current = '';
                    }
                    $quote = $char;
                    $str = $char;
                    $pos++;
                    while ($pos < $len && $code[$pos] !== $quote) {
                        if ($code[$pos] === '\\\\' && $pos + 1 < $len) {
                            $str .= $code[$pos] . $code[$pos + 1];
                            $pos += 2;
                            continue;
                        }
                        if ($code[$pos] === "\\n") $line++;
                        $str .= $code[$pos];
                        $pos++;
                    }
                    if ($pos < $len) {
                        $str .= $code[$pos];
                        $pos++;
                    }
                    $tokens[] = [T_CONSTANT_ENCAPSED_STRING, $str, $line];
                    continue;
                }

                if ($char === '(' || $char === ')') {
                    if ($current !== '') {
                        $tokens[] = [T_STRING, $current, $line];
                        $current = '';
                    }
                    $tokens[] = $char;
                    $pos++;
                    continue;
                }

                if ($char === "\\n") $line++;
                $current .= $char;
                $pos++;
            }

            if ($inPhp && $current !== '') {
                $tokens[] = [T_STRING, $current, $line];
            }
        }

        return $tokens;
    }
}
`;

  // uniqid() hangs on the 2nd call within a single WASM process because the native
  // C implementation calls usleep(1) internally and usleep is broken under Emscripten
  // Asyncify. PHP resolves bare function calls to the current namespace first, so we
  // define a safe uniqid() in every namespace that calls it at runtime.
  //
  // The global helper __wasm_safe_uniqid() lives in the global namespace and produces
  // output identical to native uniqid(): prefix + 13 hex chars (+ ".XXXXXXXX" with
  // more_entropy). A static counter ensures uniqueness even when microtime hasn't
  // advanced between calls.
  const uniqidNamespaces = ["Livewire\\Features\\SupportQueryString", "Illuminate\\Cache"];
  const wasmUniqidFix =
    `
namespace {
    function __wasm_safe_uniqid(string $prefix = '', bool $more_entropy = false): string {
        static $counter = 0;
        $counter++;
        $time = microtime(true);
        $sec = (int)$time;
        $usec = (int)(($time - $sec) * 1000000);
        $result = $prefix . sprintf('%08x%05x', $sec, $usec + $counter);
        if ($more_entropy) {
            $result .= sprintf('.%08d', mt_rand(0, 99999999));
        }
        return $result;
    }
}
` +
    uniqidNamespaces
      .map(
        (ns) => `
namespace ${ns} {
    function uniqid(string $prefix = '', bool $more_entropy = false): string {
        return \\__wasm_safe_uniqid($prefix, $more_entropy);
    }
}
`,
      )
      .join("");

  return (
    "<?php\n// Auto-generated PHP stubs for missing extensions\n// Extensions enabled: " +
    JSON.stringify(extensions) +
    "\nnamespace {\n" +
    stubs.join("\n") +
    "\n}\n" +
    bladeTokenizerFix +
    wasmUniqidFix
  );
}

// Cache directory for stripped PHP files — persists between builds
const STRIP_CACHE_DIR = join(import.meta.dirname, ".strip-cache");
// Number of parallel php -w workers
const STRIP_CONCURRENCY = Math.max(4, cpus().length);

/**
 * Run async tasks with a bounded concurrency pool.
 */
async function mapConcurrent(items, fn, concurrency) {
  const results = Array.from({ length: items.length });
  let index = 0;
  async function worker() {
    while (index < items.length) {
      const i = index++;
      results[i] = await fn(items[i], i);
    }
  }
  await Promise.all(Array.from({ length: concurrency }, worker));
  return results;
}

/**
 * Strip whitespace from a single PHP file asynchronously.
 * Uses a content-hash cache to skip unchanged files.
 * Returns stripped Buffer or null on failure.
 */
async function stripPhpFileAsync(filePath, originalContent) {
  const hash = createHash("sha256").update(originalContent).digest("hex");
  const cachePath = join(STRIP_CACHE_DIR, hash);

  // Cache hit — return without spawning a PHP process
  if (existsSync(cachePath)) {
    return { content: readFileSync(cachePath), fromCache: true };
  }

  try {
    const { stdout } = await execFileAsync("php", ["-w", filePath], {
      encoding: "buffer",
      timeout: 30_000,
      maxBuffer: 10 * 1024 * 1024,
    });

    if (stdout && stdout.length > 0) {
      mkdirSync(STRIP_CACHE_DIR, { recursive: true });
      writeFileSync(cachePath, stdout);
      return { content: stdout, fromCache: false };
    }
  } catch {
    // php -w failed — skip this file
  }

  return null;
}

/**
 * Pre-process all PHP files in parallel.
 * Returns a Map of fullPath → stripped Buffer.
 */
async function stripPhpFilesParallel(files) {
  const phpFiles = files.filter(
    (f) =>
      !f.isDir &&
      f.path.endsWith(".php") &&
      !f.path.endsWith(".blade.php") &&
      !f.path.startsWith("php-stubs") &&
      !f.path.startsWith("storage/framework/views/"),
  );

  const startTime = Date.now();
  let cacheHits = 0;
  const strippedMap = new Map();

  await mapConcurrent(
    phpFiles,
    async (file) => {
      const original = readFileSync(file.fullPath);
      const result = await stripPhpFileAsync(file.fullPath, original);

      if (result) {
        const saved = original.length - result.content.length;
        if (saved > 0) {
          strippedMap.set(file.fullPath, result.content);
          if (result.fromCache) {
            cacheHits++;
          }
        }
      }
    },
    STRIP_CONCURRENCY,
  );

  const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
  console.log(
    `    Done in ${elapsed}s (${cacheHits}/${phpFiles.length} cache hits, ${strippedMap.size} files reduced)`,
  );

  return strippedMap;
}

/**
 * Collect all files from a directory recursively.
 */
function collectFiles(dir, basePath = "") {
  const results = [];
  const entries = readdirSync(dir, { withFileTypes: true });

  for (const entry of entries) {
    const fullPath = join(dir, entry.name);
    const relPath = basePath ? `${basePath}/${entry.name}` : entry.name;

    const testPath = "/" + relPath;
    if (EXCLUDE_PATTERNS.some((p) => p.test(testPath))) {
      continue;
    }

    if (entry.isDirectory()) {
      results.push({ path: relPath + "/", isDir: true });
      results.push(...collectFiles(fullPath, relPath));
    } else if (entry.isFile()) {
      results.push({ path: relPath, isDir: false, fullPath });
    }
  }

  return results;
}

/**
 * Create a 512-byte tar header for a file or directory.
 */
function createTarHeader(path, size, isDir) {
  const header = new Uint8Array(512);
  const encoder = new TextEncoder();

  let name = path;
  let ustarPrefix = "";

  if (name.length > 100) {
    const splitAt = name.lastIndexOf("/", 155);
    if (splitAt > 0) {
      ustarPrefix = name.substring(0, splitAt);
      name = name.substring(splitAt + 1);
    }
  }

  header.set(encoder.encode(name.substring(0, 100)), 0);

  const mode = isDir ? "0000755" : "0000644";
  header.set(encoder.encode(mode + "\0"), 100);

  header.set(encoder.encode("0001000\0"), 108);
  header.set(encoder.encode("0001000\0"), 116);

  const sizeStr = size.toString(8).padStart(11, "0");
  header.set(encoder.encode(sizeStr + "\0"), 124);

  const mtime = Math.floor(Date.now() / 1000)
    .toString(8)
    .padStart(11, "0");
  header.set(encoder.encode(mtime + "\0"), 136);

  header.set(encoder.encode("        "), 148);

  header[156] = isDir ? 53 : 48;

  header.set(encoder.encode("ustar\0"), 257);
  header.set(encoder.encode("00"), 263);

  if (ustarPrefix) {
    header.set(encoder.encode(ustarPrefix.substring(0, 155)), 345);
  }

  let checksum = 0;
  for (let i = 0; i < 512; i++) {
    checksum += header[i];
  }
  const checksumStr = checksum.toString(8).padStart(6, "0") + "\0 ";
  header.set(encoder.encode(checksumStr), 148);

  return header;
}

/**
 * Create a tar archive from collected files.
 * When strippedContents is provided, pre-stripped PHP content is used directly.
 */
function createTar(files, { stripWhitespace = false, strippedContents = new Map() } = {}) {
  const chunks = [];
  let strippedCount = 0;
  let bytesSaved = 0;

  for (const file of files) {
    if (file.isDir) {
      chunks.push(createTarHeader(file.path, 0, true));
    } else {
      let content = readFileSync(file.fullPath);

      // Use pre-stripped content if available
      if (
        stripWhitespace &&
        file.path.endsWith(".php") &&
        !file.path.endsWith(".blade.php") &&
        !file.path.startsWith("php-stubs") &&
        !file.path.startsWith("storage/framework/views/")
      ) {
        const stripped = strippedContents.get(file.fullPath);
        if (stripped && stripped.length > 0) {
          const saved = content.length - stripped.length;
          if (saved > 0) {
            bytesSaved += saved;
            strippedCount++;
            content = stripped;
          }
        }
      }

      chunks.push(createTarHeader(file.path, content.length, false));
      chunks.push(new Uint8Array(content));

      const remainder = content.length % 512;
      if (remainder > 0) {
        chunks.push(new Uint8Array(512 - remainder));
      }
    }
  }

  chunks.push(new Uint8Array(1024));

  const totalSize = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
  const result = new Uint8Array(totalSize);
  let offset = 0;
  for (const chunk of chunks) {
    result.set(chunk, offset);
    offset += chunk.length;
  }

  return { tar: result, strippedCount, bytesSaved };
}

const fmt = (bytes) => {
  if (bytes >= 1024 * 1024) return (bytes / 1024 / 1024).toFixed(2) + " MB";
  return (bytes / 1024).toFixed(0) + " KB";
};

// --- Main ---

console.log("  Starting build-app.mjs...");
console.log(`  ROOT: ${ROOT}`);
console.log(`  DIST_DIR: ${DIST_DIR}`);

if (existsSync(DIST_DIR)) {
  console.log("  Cleaning dist directory...");
  rmSync(DIST_DIR, { recursive: true });
}

console.log("Building Laravel app tar...");

const allFiles = [];

for (const dir of INCLUDE_DIRS) {
  const fullDir = join(ROOT, dir);
  if (existsSync(fullDir)) {
    allFiles.push({ path: dir + "/", isDir: true });
    allFiles.push(...collectFiles(fullDir, dir));
  } else {
    console.warn(`  Warning: ${dir} not found, skipping`);
  }
}

for (const file of INCLUDE_FILES) {
  const fullPath = join(ROOT, file);
  if (existsSync(fullPath)) {
    const parts = file.split("/");
    if (parts.length > 1) {
      let dirPath = "";
      for (let i = 0; i < parts.length - 1; i++) {
        dirPath += (dirPath ? "/" : "") + parts[i];
        if (!allFiles.some((f) => f.path === dirPath + "/")) {
          allFiles.push({ path: dirPath + "/", isDir: true });
        }
      }
    }
    allFiles.push({ path: file, isDir: false, fullPath });
  } else {
    console.warn(`  Warning: ${file} not found, skipping`);
  }
}

// Add staging vendor files if available
if (VENDOR_STAGING_DIR && existsSync(VENDOR_STAGING_DIR)) {
  const stagingVendorDir = join(VENDOR_STAGING_DIR, "vendor");
  if (existsSync(stagingVendorDir)) {
    allFiles.push({ path: "vendor/", isDir: true });
    allFiles.push(...collectFiles(stagingVendorDir, "vendor"));
  }
}

// Copy .env.production as .env
const envSource = join(import.meta.dirname, ".env.production");
if (existsSync(envSource)) {
  allFiles.push({ path: ".env", isDir: false, fullPath: envSource });
} else {
  console.warn("  Warning: .laraworker/.env.production not found, no .env will be included");
}

// Add empty storage directory structure
const storageDirs = [
  "storage/",
  "storage/app/",
  "storage/framework/",
  "storage/framework/cache/",
  "storage/framework/cache/data/",
  "storage/framework/sessions/",
  "storage/framework/testing/",
  "storage/framework/views/",
  "storage/logs/",
];

for (const dir of storageDirs) {
  if (!allFiles.some((f) => f.path === dir)) {
    allFiles.push({ path: dir, isDir: true });
  }
}

// Include Vite manifest in the tar so PHP can read it for @vite() Blade directive.
// The actual JS/CSS assets are served by Cloudflare Static Assets (copied later),
// but PHP needs the manifest to generate <link> and <script> tags.
// Vite 7+ puts manifest at public/build/manifest.json; older versions use .vite/ subdir.
const viteManifestBuildDir = join(ROOT, "public", "build");
const viteManifestPaths = [
  {
    dir: join(viteManifestBuildDir, ".vite"),
    file: "manifest.json",
    tarDir: "public/build/.vite/",
  },
  { dir: viteManifestBuildDir, file: "manifest.json", tarDir: "public/build/" },
];

let viteManifestIncluded = false;
for (const { dir, file, tarDir } of viteManifestPaths) {
  const manifestPath = join(dir, file);
  if (existsSync(manifestPath)) {
    if (!allFiles.some((f) => f.path === "public/")) {
      allFiles.push({ path: "public/", isDir: true });
    }
    if (!allFiles.some((f) => f.path === "public/build/")) {
      allFiles.push({ path: "public/build/", isDir: true });
    }
    if (tarDir === "public/build/.vite/" && !allFiles.some((f) => f.path === tarDir)) {
      allFiles.push({ path: tarDir, isDir: true });
    }
    allFiles.push({ path: tarDir + file, isDir: false, fullPath: manifestPath });
    console.log(`  ✓ Vite manifest included in tar (${tarDir}${file})`);
    viteManifestIncluded = true;
    break;
  }
}
if (!viteManifestIncluded) {
  console.warn("  Warning: No Vite manifest found in public/build/");
}

// Include any additional Vite manifests found under public/ (e.g. vendor package assets).
// Package-provided Vite assets have manifests at paths like:
//   public/vendor/<pkg>/build/manifest.json
// PHP needs these manifests to resolve @vite() directives referencing package builds.
function findViteManifests(dir, relativeBase) {
  const found = [];
  if (!existsSync(dir)) return found;
  for (const entry of readdirSync(dir, { withFileTypes: true })) {
    const fullPath = join(dir, entry.name);
    const relPath = relativeBase ? `${relativeBase}/${entry.name}` : entry.name;
    if (entry.isDirectory()) {
      found.push(...findViteManifests(fullPath, relPath));
    } else if (
      entry.name === "manifest.json" &&
      relativeBase !== "build" &&
      !relativeBase?.startsWith("build/")
    ) {
      found.push({ fullPath, tarPath: `public/${relPath}` });
    }
  }
  return found;
}

const extraManifests = findViteManifests(join(ROOT, "public"), "");
for (const { fullPath, tarPath } of extraManifests) {
  // Skip if already included
  if (allFiles.some((f) => f.path === tarPath)) continue;
  // Ensure parent directories exist in the tar
  const parts = tarPath.split("/");
  for (let i = 1; i < parts.length; i++) {
    const dirPath = parts.slice(0, i).join("/") + "/";
    if (!allFiles.some((f) => f.path === dirPath)) {
      allFiles.push({ path: dirPath, isDir: true });
    }
  }
  allFiles.push({ path: tarPath, isDir: false, fullPath });
  console.log(`  ✓ Vite manifest included in tar (${tarPath})`);
}

// ──── Locale stripping ────
// Strip locale/language files from vendor packages, keeping only configured locales.
// This saves significant MEMFS space — e.g. Filament ships ~13 MB of locale files.
const KEEP_LOCALES = config.locales ?? ["en"];

// Carbon locale files: vendor/nesbot/carbon/src/Carbon/Lang/{locale}.php
const carbonLangPrefix = "vendor/nesbot/carbon/src/Carbon/Lang/";
const carbonRemoved = [];
for (let i = allFiles.length - 1; i >= 0; i--) {
  const f = allFiles[i];
  if (!f.path.startsWith(carbonLangPrefix) || f.isDir) continue;
  const filename = f.path.substring(carbonLangPrefix.length);
  // Carbon uses flat files: en.php, fr.php, etc.
  const locale = filename.replace(/\.php$/, "");
  if (!KEEP_LOCALES.includes(locale)) {
    carbonRemoved.push(f.path);
    allFiles.splice(i, 1);
  }
}
if (carbonRemoved.length > 0) {
  console.log(
    `  Stripped ${carbonRemoved.length} Carbon locale files (kept: ${KEEP_LOCALES.join(", ")})`,
  );
}

// Vendor lang directories: vendor/*/*/resources/lang/{locale}/ and vendor/*/resources/lang/{locale}/
// Matches Filament, Cachet, Livewire, and other Laravel packages that use resources/lang/{locale}/ structure.
const vendorLangPattern = /^vendor\/(?:[^/]+\/)?[^/]+\/resources\/lang\/([^/]+)\//;
const vendorLangRemoved = [];
for (let i = allFiles.length - 1; i >= 0; i--) {
  const f = allFiles[i];
  const match = f.path.match(vendorLangPattern);
  if (!match) continue;
  const locale = match[1];
  if (!KEEP_LOCALES.includes(locale)) {
    vendorLangRemoved.push(f.path);
    allFiles.splice(i, 1);
  }
}
if (vendorLangRemoved.length > 0) {
  console.log(
    `  Stripped ${vendorLangRemoved.length} vendor locale files (kept: ${KEEP_LOCALES.join(", ")})`,
  );
}

// ──── Blade icon tree-shaking ────
// Scan all PHP/Blade files for blade-icon references (e.g. heroicon-o-check, heroicon-m-calendar)
// and remove unused SVG files from blade icon packages. Filament ships 1,288 heroicon SVGs (~5 MB)
// but a typical app uses only 20-30 icons.
const BLADE_ICON_SETS = [
  { prefix: "heroicon-", svgDir: "vendor/blade-ui-kit/blade-heroicons/resources/svg/" },
];

for (const iconSet of BLADE_ICON_SETS) {
  const svgPrefix = iconSet.svgDir;
  const svgFiles = allFiles.filter(
    (f) => !f.isDir && f.path.startsWith(svgPrefix) && f.path.endsWith(".svg"),
  );
  if (svgFiles.length === 0) continue;

  // Scan all PHP, Blade, and compiled view files for icon references
  const usedIcons = new Set();
  const iconRefPattern = new RegExp(
    iconSet.prefix.replace(/-/g, "[-.]") + "([a-z0-9][-a-z0-9]*)",
    "g",
  );

  for (const f of allFiles) {
    if (f.isDir || !f.fullPath) continue;
    if (
      !(
        f.path.endsWith(".php") ||
        f.path.endsWith(".blade.php") ||
        f.path.startsWith("storage/framework/views/")
      )
    )
      continue;
    try {
      const content = readFileSync(f.fullPath, "utf8");
      for (const match of content.matchAll(iconRefPattern)) {
        // match[0] = "heroicon-o-check", match[1] = "o-check"
        // SVG filename is the part after the prefix: "o-check.svg"
        usedIcons.add(match[1] + ".svg");
      }
    } catch {}
  }

  if (usedIcons.size === 0) {
    // Could not detect any used icons — keep all to be safe
    console.log(
      `  ⚠ No ${iconSet.prefix}* references detected, keeping all ${svgFiles.length} SVGs`,
    );
    continue;
  }

  const iconsBefore = svgFiles.length;
  let iconsRemoved = 0;
  for (let i = allFiles.length - 1; i >= 0; i--) {
    const f = allFiles[i];
    if (f.isDir || !f.path.startsWith(svgPrefix) || !f.path.endsWith(".svg")) continue;
    const filename = f.path.substring(svgPrefix.length);
    if (!usedIcons.has(filename)) {
      allFiles.splice(i, 1);
      iconsRemoved++;
    }
  }

  if (iconsRemoved > 0) {
    console.log(
      `  Stripped ${iconsRemoved}/${iconsBefore} unused ${iconSet.prefix}* SVGs (kept ${usedIcons.size} used icons)`,
    );
  }
}

// Verify no dev packages in the final bundle
// These are packages that should ONLY be in require-dev, not transitive deps
const DEV_PACKAGE_PATTERNS = [
  /vendor\/fakerphp\/faker/,
  /vendor\/phpunit\/phpunit/,
  /vendor\/pestphp\/pest/,
  /vendor\/mockery\/mockery/,
  /vendor\/laravel\/sail/,
  /vendor\/laravel\/pint/,
  /vendor\/laravel\/dusk/,
  /vendor\/spatie\/laravel-ignition/,
];

const devPackagesFound = [];
for (const file of allFiles) {
  for (const pattern of DEV_PACKAGE_PATTERNS) {
    if (pattern.test(file.path)) {
      devPackagesFound.push(file.path);
      break;
    }
  }
}

if (devPackagesFound.length > 0) {
  console.error("  ERROR: Dev packages found in bundle:");
  for (const pkg of devPackagesFound.slice(0, 10)) {
    console.error(`    - ${pkg}`);
  }
  if (devPackagesFound.length > 10) {
    console.error(`    ... and ${devPackagesFound.length - 10} more`);
  }
  process.exit(1);
} else {
  console.log("  ✓ No dev packages found in bundle");
}

// Override Composer platform check — php-cgi-wasm currently provides PHP 8.3.11
// but Laravel 12 requires >= 8.4.0. Remove this override once a custom PHP 8.4+
// WASM binary is built (see php-wasm-build/.php-wasm-rc).
const platformCheckPath = "vendor/composer/platform_check.php";
const idx = allFiles.findIndex((f) => f.path === platformCheckPath);
if (idx >= 0) {
  const tmpFile = join(DIST_DIR, "__platform_check_noop.php");
  mkdirSync(DIST_DIR, { recursive: true });
  writeFileSync(tmpFile, "<?php\n// Platform check disabled for WASM runtime\n");
  allFiles[idx] = { path: platformCheckPath, isDir: false, fullPath: tmpFile };
  console.log("  Disabled Composer platform check");
}

// Generate PHP stubs for missing extensions
console.log("  Generating PHP stubs for extensions...");
const stubsContent = generatePhpStubs(EXTENSIONS);
const stubsFile = join(DIST_DIR, "__php_stubs.php");
mkdirSync(DIST_DIR, { recursive: true });
writeFileSync(stubsFile, stubsContent);
allFiles.push({ path: "php-stubs.php", isDir: false, fullPath: stubsFile });
console.log(`    iconv: ${EXTENSIONS.iconv ? "enabled (no stubs)" : "disabled (stubs added)"}`);
console.log(
  `    mbstring: ${EXTENSIONS.mbstring ? "enabled (no stubs)" : "disabled (stubs added)"}`,
);
console.log(`    openssl: ${EXTENSIONS.openssl ? "enabled (no stubs)" : "disabled (stubs added)"}`);

// Generate OPcache diagnostic PHP file
console.log("  Generating OPcache diagnostic endpoint...");
const opcacheStatusContent = `<?php
// Auto-generated OPcache diagnostic endpoint
// Access via /__opcache-status when OPCACHE_DEBUG=true
header('Content-Type: application/json');
$status = opcache_get_status(false);
if ($status === false) {
    echo json_encode(['error' => 'OPcache not available']);
    exit;
}
echo json_encode($status, JSON_PRETTY_PRINT);
`;
const opcacheStatusFile = join(DIST_DIR, "__opcache_status.php");
writeFileSync(opcacheStatusFile, opcacheStatusContent);
allFiles.push({ path: "public/__opcache-status.php", isDir: false, fullPath: opcacheStatusFile });
console.log("  ✓ OPcache diagnostic endpoint: /__opcache-status (requires OPCACHE_DEBUG=true)");

// Compute per-category stats before creating tar
let vendorFileCount = 0;
let appFileCount = 0;

for (const f of allFiles) {
  if (f.isDir) continue;
  if (f.path.startsWith("vendor/")) {
    vendorFileCount++;
  } else {
    appFileCount++;
  }
}

console.log(`  Collected ${allFiles.length} entries (${vendorFileCount + appFileCount} files)`);

// Strip PHP whitespace in parallel (with content-hash cache for incremental builds)
let strippedContents = new Map();
if (STRIP_WHITESPACE) {
  console.log(`  Stripping PHP whitespace and comments (${STRIP_CONCURRENCY} parallel workers)...`);
  strippedContents = await stripPhpFilesParallel(allFiles);
}

const { tar, strippedCount, bytesSaved } = createTar(allFiles, {
  stripWhitespace: STRIP_WHITESPACE,
  strippedContents,
});

if (STRIP_WHITESPACE && strippedCount > 0) {
  console.log(
    `  Stripped whitespace from ${strippedCount} PHP files (saved ${fmt(bytesSaved)} uncompressed)`,
  );
}

const gzipped = gzipSync(tar, { level: 9 });

mkdirSync(DIST_DIR, { recursive: true });
writeFileSync(OUTPUT, gzipped);

// Compute compressed sizes per category for report
const vendorOnlyFiles = allFiles.filter((f) => !f.isDir && f.path.startsWith("vendor/"));
const appOnlyFiles = allFiles.filter((f) => !f.isDir && !f.path.startsWith("vendor/"));
const {
  tar: vendorTar,
  strippedCount: _,
  bytesSaved: __,
} = createTar(vendorOnlyFiles, {
  stripWhitespace: STRIP_WHITESPACE,
  strippedContents,
});
const vendorGz = gzipSync(vendorTar, { level: 9 });
const {
  tar: appTar,
  strippedCount: ___,
  bytesSaved: ____,
} = createTar(appOnlyFiles, {
  stripWhitespace: STRIP_WHITESPACE,
  strippedContents,
});
const appGz = gzipSync(appTar, { level: 9 });

const totalCompressed = gzipped.length;
const totalUncompressed = tar.length;
const vendorUncompressed = vendorTar.length;
const appUncompressed = appTar.length;

// PHP 8.5 WASM binary (gzipped). Measured from PHP 8.5.2 build: 3.27 MB gz.
// PHP WASM is loaded as a separate Cloudflare Workers binding (not bundled in script).
const WASM_ESTIMATE_BYTES = 3.4 * 1024 * 1024;
const totalWithWasm = totalCompressed + WASM_ESTIMATE_BYTES;
// App bundle budget: app.tar.gz should fit in Cloudflare Workers KV (25 MB limit).
// WASM is deployed as a separate Workers binding, not counted here.
const appFitsBudget = totalCompressed < 25 * 1024 * 1024;

// MEMFS budget check (uncompressed size is what goes into memory)
const MEMFS_BUDGET_MB = config.memfs_budget_mb ?? 30;
const memfsBudgetBytes = MEMFS_BUDGET_MB * 1024 * 1024;
const memfsFitsBudget = totalUncompressed <= memfsBudgetBytes;

console.log("");
console.log("  ┌──────────────────────────────────────────────────────────────────────┐");
console.log("  │                        Build Report                                 │");
console.log("  ├──────────────────────────┬──────────┬───────────────┬───────────────┤");
console.log("  │ Category                 │ Files    │ Uncompressed  │ Compressed    │");
console.log("  ├──────────────────────────┼──────────┼───────────────┼───────────────┤");
console.log(
  `  │ vendor/                  │ ${String(vendorFileCount).padStart(6)} │ ${fmt(vendorUncompressed).padStart(13)} │ ${fmt(vendorGz.length).padStart(13)} │`,
);
console.log(
  `  │ app (non-vendor)         │ ${String(appFileCount).padStart(6)} │ ${fmt(appUncompressed).padStart(13)} │ ${fmt(appGz.length).padStart(13)} │`,
);
console.log("  ├──────────────────────────┼──────────┼───────────────┼───────────────┤");
console.log(
  `  │ Total tar entries        │ ${String(allFiles.length).padStart(6)} │ ${fmt(totalUncompressed).padStart(13)} │ ${fmt(totalCompressed).padStart(13)} │`,
);
console.log(
  `  │ + WASM (~3.4 MB gz)      │          │               │ ${fmt(totalWithWasm).padStart(13)} │`,
);
console.log("  ├──────────────────────────┴──────────┴───────────────┴───────────────┤");
console.log(
  `  │ App bundle (< 25 MB): ${appFitsBudget ? "✅ FITS" : "❌ EXCEEDS"}${" ".repeat(42)}│`,
);
console.log(
  `  │ MEMFS budget (${MEMFS_BUDGET_MB} MB uncompressed): ${memfsFitsBudget ? "✅ FITS" : "⚠️  EXCEEDS"}${" ".repeat(27)}│`,
);
console.log("  └──────────────────────────────────────────────────────────────────────┘");

// Show prominent warning if MEMFS budget is exceeded
if (!memfsFitsBudget) {
  const excessMB = ((totalUncompressed - memfsBudgetBytes) / 1024 / 1024).toFixed(1);
  console.log("");
  console.log("  ⚠️  WARNING: MEMFS budget exceeded!");
  console.log(`     Uncompressed size: ${fmt(totalUncompressed)} (budget: ${MEMFS_BUDGET_MB} MB)`);
  console.log(`     Excess: ${excessMB} MB over budget`);
  console.log("");
  console.log("     This can cause 'Worker resource exceeded' errors at runtime.");
  console.log("     To reduce size:");
  console.log("       - Add exclude_patterns in config/laraworker.php");
  console.log("       - Enable strip_whitespace for production builds");
  console.log("       - Set show_top_dirs=true to see largest directories");
  console.log("");
}

console.log("");

// Show top 10 directories by uncompressed size for debugging
if (config.show_top_dirs ?? false) {
  const dirSizes = new Map();
  for (const f of allFiles) {
    if (f.isDir) continue;
    const parts = f.path.split("/");
    const dir = parts.length > 1 ? parts[0] + "/" : "(root)";
    const content = readFileSync(f.fullPath);
    dirSizes.set(dir, (dirSizes.get(dir) || 0) + content.length);
  }

  const sortedDirs = Array.from(dirSizes.entries())
    .sort((a, b) => b[1] - a[1])
    .slice(0, 10);

  if (sortedDirs.length > 0) {
    console.log("  Top 10 directories by uncompressed size:");
    for (const [dir, size] of sortedDirs) {
      console.log(`    ${dir.padEnd(25)} ${fmt(size).padStart(10)}`);
    }
    console.log("");
  }
}

// Copy Vite build assets if they exist
const viteBuildDir = join(ROOT, "public", "build");
if (existsSync(viteBuildDir)) {
  console.log("  Copying Vite build assets...");
  copyDirRecursive(viteBuildDir, join(DIST_DIR, "build"));
  console.log("  Done.");
}

// Copy public/ static files to Cloudflare Static Assets.
// These are served directly by CF edge without invoking the PHP WASM worker.
const PUBLIC_ASSETS = config.public_assets ?? true;
if (PUBLIC_ASSETS) {
  const publicDir = join(ROOT, "public");
  if (existsSync(publicDir)) {
    console.log("  Copying public static assets...");
    const copiedFiles = [];
    copyPublicFiles(publicDir, DIST_DIR, "", copiedFiles);
    if (copiedFiles.length > 0) {
      for (const f of copiedFiles) {
        console.log(`    + ${f}`);
      }
      console.log(`  ✓ ${copiedFiles.length} public static file(s) copied to Static Assets`);
    } else {
      console.log("  No public static files to copy.");
    }
  }
}

// Generate _headers file for Cloudflare Static Assets.
// This adds immutable cache headers to Vite build assets without worker invocation.
const headersContent = `/build/assets/*
  Cache-Control: public, max-age=31536000, immutable
`;
writeFileSync(join(DIST_DIR, "_headers"), headersContent);
console.log("  ✓ Generated _headers for immutable asset caching");

// Verify custom PHP 8.5 WASM binary and helper modules are present.
// These are copied into the build directory by the PHP BuildCommand
// (BuildDirectory::copyWasmBinary) before build-app.mjs runs.
console.log("  Verifying custom PHP 8.5 WASM binary...");

const requiredFiles = [
  "php-cgi.mjs",
  "php-cgi.wasm",
  "PhpCgiBase.mjs",
  "breakoutRequest.mjs",
  "parseResponse.mjs",
  "fsOps.mjs",
  "resolveDependencies.mjs",
];
for (const file of requiredFiles) {
  const filePath = join(import.meta.dirname, file);
  if (!existsSync(filePath)) {
    console.error(`  ERROR: ${file} not found in build directory`);
    console.error("  Ensure BuildDirectory::copyWasmBinary() ran successfully.");
    console.error("  To rebuild WASM: bash php-wasm-build/build.sh");
    process.exit(1);
  }
}

const wasmSize = statSync(join(import.meta.dirname, "php-cgi.wasm")).size;
console.log(`  ✓ php-cgi.wasm (${fmt(wasmSize)})`);
console.log(`  ✓ php-cgi.mjs + ${requiredFiles.length - 2} helper modules`);

console.log("Build complete.");

function copyDirRecursive(src, dest) {
  mkdirSync(dest, { recursive: true });
  const entries = readdirSync(src, { withFileTypes: true });
  for (const entry of entries) {
    const srcPath = join(src, entry.name);
    const destPath = join(dest, entry.name);
    if (entry.isDirectory()) {
      copyDirRecursive(srcPath, destPath);
    } else {
      copyFileSync(srcPath, destPath);
    }
  }
}

/**
 * Recursively copy public/ files to Static Assets, skipping index.php and build/.
 */
function copyPublicFiles(srcDir, destDir, relPrefix, copiedFiles) {
  const entries = readdirSync(srcDir, { withFileTypes: true });
  for (const entry of entries) {
    const relPath = relPrefix ? `${relPrefix}/${entry.name}` : entry.name;

    // Skip index.php (handled by PHP routing) and build/ (handled by Vite copy)
    if (relPrefix === "" && (entry.name === "index.php" || entry.name === "build")) {
      continue;
    }

    const srcPath = join(srcDir, entry.name);
    const destPath = join(destDir, relPath);

    if (entry.isDirectory()) {
      copyPublicFiles(srcPath, destDir, relPath, copiedFiles);
    } else if (entry.isFile()) {
      mkdirSync(join(destDir, relPrefix), { recursive: true });
      copyFileSync(srcPath, destPath);
      copiedFiles.push(relPath);
    }
  }
}
