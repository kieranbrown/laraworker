/**
 * Build script: packages Laravel application files into a .tar for Cloudflare Static Assets.
 *
 * Usage: node .laraworker/build-app.mjs
 *
 * Output: .laraworker/dist/assets/app.tar.gz
 *
 * Configuration is read from .laraworker/build-config.json (generated by laraworker:build).
 */

import {
  readdirSync,
  statSync,
  readFileSync,
  mkdirSync,
  writeFileSync,
  copyFileSync,
  existsSync,
  rmSync,
} from "node:fs";
import { gzipSync } from "node:zlib";
import { join, resolve } from "node:path";
import { execFile } from "node:child_process";
import { promisify } from "node:util";
import { createHash } from "node:crypto";
import { cpus } from "node:os";

const execFileAsync = promisify(execFile);

const ROOT = resolve(import.meta.dirname, "..");
const DIST_DIR = resolve(import.meta.dirname, "dist", "assets");
const OUTPUT = join(DIST_DIR, "app.tar.gz");

// Read build config (generated by php artisan laraworker:build)
const configPath = join(import.meta.dirname, "build-config.json");
let config = {};
if (existsSync(configPath)) {
  config = JSON.parse(readFileSync(configPath, "utf8"));
}

const VENDOR_STAGING_DIR = config.vendor_staging_dir;

let INCLUDE_DIRS = config.include_dirs ?? [
  "app",
  "bootstrap",
  "config",
  "database",
  "routes",
  "resources/views",
  "vendor",
];

// Use staging vendor if available (production-only, no-dev)
if (VENDOR_STAGING_DIR && existsSync(VENDOR_STAGING_DIR)) {
  console.log("  Using staging vendor (production-only, no-dev)...");
  // Filter out vendor from include_dirs - we'll add staging vendor separately
  INCLUDE_DIRS = INCLUDE_DIRS.filter((d) => d !== "vendor");
} else {
  console.warn("  Warning: No staging vendor found, using main vendor (may include dev packages)");
}

const INCLUDE_FILES = config.include_files ?? ["public/index.php", "artisan", "composer.json"];

// Default exclude patterns — always applied. User config patterns merge with these.
const DEFAULT_EXCLUDE_PATTERNS = [
  // VCS & CI
  "/\\.git\\//",
  "/\\.github\\//",
  "/\\/node_modules\\//",
  "/\\/\\.DS_Store$/",

  // Vendor tests, examples, benchmarks, fixtures, demos (dev-only)
  "/vendor\\/[^/]+\\/[^/]+\\/tests\\//",
  "/vendor\\/[^/]+\\/[^/]+\\/Tests\\//",
  "/vendor\\/[^/]+\\/[^/]+\\/test\\//",
  "/vendor\\/[^/]+\\/[^/]+\\/examples?\\//",
  "/vendor\\/[^/]+\\/[^/]+\\/benchmarks?\\//",
  "/vendor\\/[^/]+\\/[^/]+\\/fixtures?\\//",
  "/vendor\\/[^/]+\\/[^/]+\\/demo\\//",

  // Vendor docs & metadata
  "/vendor\\/[^/]+\\/[^/]+\\/docs\\//",
  "/vendor\\/[^/]+\\/[^/]+\\/doc\\//",
  "/vendor\\/[^/]+\\/[^/]+\\/documentation\\//",
  "/vendor\\/[^/]+\\/[^/]+\\/[^/]+\\.md$/",
  "/vendor\\/[^/]+\\/[^/]+\\/CHANGELOG/",
  "/vendor\\/[^/]+\\/[^/]+\\/UPGRADE/",

  // Metadata files not needed at runtime
  "/vendor\\/[^/]+\\/[^/]+\\/LICENSE/",
  "/vendor\\/[^/]+\\/[^/]+\\/CREDITS/",
  "/vendor\\/[^/]+\\/[^/]+\\/NOTICE/",
  "/vendor\\/[^/]+\\/[^/]+\\/README/",
  "/vendor\\/[^/]+\\/[^/]+\\/AUTHORS/",
  "/vendor\\/[^/]+\\/[^/]+\\/CONTRIBUTORS/",
  "/vendor\\/[^/]+\\/[^/]+\\/BACKERS/",

  // Vendor tooling configs
  "/vendor\\/[^/]+\\/[^/]+\\/phpunit\\.xml/",
  "/vendor\\/[^/]+\\/[^/]+\\/\\.editorconfig$/",
  "/vendor\\/[^/]+\\/[^/]+\\/\\.gitattributes$/",
  "/vendor\\/[^/]+\\/[^/]+\\/\\.gitignore$/",
  "/vendor\\/[^/]+\\/[^/]+\\/phpstan/",
  "/vendor\\/[^/]+\\/[^/]+\\/psalm/",
  "/vendor\\/[^/]+\\/[^/]+\\/\\.phpcs/",
  "/vendor\\/[^/]+\\/[^/]+\\/\\.php-cs-fixer/",
  "/vendor\\/[^/]+\\/[^/]+\\/\\.php_cs/",
  "/vendor\\/[^/]+\\/[^/]+\\/Makefile$/",
  "/vendor\\/[^/]+\\/[^/]+\\/\\.styleci\\.yml$/",
  "/vendor\\/[^/]+\\/[^/]+\\/docker-compose/",
  "/vendor\\/[^/]+\\/[^/]+\\/Dockerfile$/",
  "/vendor\\/[^/]+\\/[^/]+\\/rector\\.php$/",
  "/vendor\\/[^/]+\\/[^/]+\\/pint\\.json$/",
  "/vendor\\/[^/]+\\/[^/]+\\/infection\\.json/",
  "/vendor\\/[^/]+\\/[^/]+\\/box\\.json/",
  "/vendor\\/[^/]+\\/[^/]+\\/phpbench\\.json/",
  "/vendor\\/[^/]+\\/[^/]+\\/\\.phpunit\\.result\\.cache$/",
  "/vendor\\/[^/]+\\/[^/]+\\/\\.phpunit\\.cache\\//",

  // CI service configs
  "/vendor\\/[^/]+\\/[^/]+\\/\\.scrutinizer\\.yml$/",
  "/vendor\\/[^/]+\\/[^/]+\\/codecov\\.ya?ml$/",
  "/vendor\\/[^/]+\\/[^/]+\\/\\.coveralls\\.yml$/",
  "/vendor\\/[^/]+\\/[^/]+\\/\\.gitlab-ci\\.yml$/",
  "/vendor\\/[^/]+\\/[^/]+\\/crowdin\\.ya?ml$/",

  // Nested vendor directories (e.g. path-repository packages with their own vendor/)
  "/vendor\/.*\/vendor\//",

  // Laraworker package internals — PHP never needs these at runtime (~15 MB savings)
  // Only keep: src/, config/, routes/, resources/, composer.json, LICENSE
  "/vendor\/kieranbrown\/laraworker\/php-wasm-build\//",
  "/vendor\/kieranbrown\/laraworker\/playground\//",
  "/vendor\/kieranbrown\/laraworker\/stubs\//",
  "/vendor\/kieranbrown\/laraworker\/dist\//",
  "/vendor\/kieranbrown\/laraworker\/scripts\//",
  "/vendor\/kieranbrown\/laraworker\/node_modules\//",
  "/vendor\/kieranbrown\/laraworker\/vendor\//",
  "/vendor\/kieranbrown\/laraworker\/\\./",
  "/vendor\/kieranbrown\/laraworker\/composer\.lock$/",
  "/vendor\/kieranbrown\/laraworker\/[^/]+\.wasm$/",
  "/vendor\/kieranbrown\/laraworker\/[^/]+\.mjs$/",

  // NOTE: blade-ui-kit SVG files are NOT excluded. Blade-icons resolves @svg()
  // directives at runtime by reading SVG files from disk via Filesystem::get().
  // view:cache does NOT inline SVG content into compiled views.

  // ──── Vendor frontend assets already served by Cloudflare Static Assets ────
  // Compiled JS/CSS/fonts are published to public/ via vendor:publish and served from
  // CF edge before the Worker is invoked. The vendor source copies waste MEMFS space.
  // PHP references these through Vite manifests and public URLs, not vendor paths.

  // Filament compiled JS/CSS — published to public/vendor/filament/ for edge serving.
  // Filament's asset system resolves URLs via Vite manifests (included in tar separately).
  "/vendor\\/filament\\/[^/]+\\/resources\\/dist\\//",

  // Livewire source maps — development-only, never needed in production.
  // NOTE: Livewire JS files are kept because Livewire serves them via a PHP route
  // handler (FrontendAssets::returnJavaScriptAsFile) that reads from dist/ at runtime.
  "/vendor\\/livewire\\/[^/]+\\/dist\\/.*\\.map$/",

  // Generic vendor compiled frontend assets in resources/dist/ directories.
  // Convention: resources/dist/ contains publishable compiled assets (JS/CSS/fonts)
  // that packages copy to public/ via vendor:publish. PHP reads manifests (JSON) at
  // runtime but never reads JS/CSS/font files directly from vendor.
  "/vendor\\/[^/]+\\/[^/]+\\/resources\\/dist\\/.*\\.(js|css|woff2?|ttf|eot)$/",

  // Source map files in vendor (development-only, never needed at runtime)
  "/vendor\\/.*\\.js\\.map$/",
  "/vendor\\/.*\\.css\\.map$/",

  // Vendor CLI scripts (not useful in Workers)
  "/vendor\\/bin\\//",
  "/vendor\\/[^/]+\\/[^/]+\\/bin\\//",

  // Schema and validation files (not needed at runtime)
  "/vendor\\/.*\\.xsd$/",
  "/vendor\\/.*\\.dtd$/",

  // Composer metadata (autoloader doesn't need installed.json at runtime)
  "/vendor\\/composer\\/installed\\.json$/",

  // Package manager files in vendor (PHP packages don't need these)
  "/vendor\\/[^/]+\\/[^/]+\\/composer\\.lock$/",
  "/vendor\\/.*\\/package-lock\\.json$/",
  "/vendor\\/[^/]+\\/[^/]+\\/package\\.json$/",
  "/vendor\\/[^/]+\\/[^/]+\\/yarn\\.lock$/",
  "/vendor\\/[^/]+\\/[^/]+\\/bun\\.lock$/",

  // Stub/template files (artisan make:* commands don't work in Workers)
  "/vendor\\/.*\\.stub$/",

  // Symfony translation/locale resources (large, unused in typical Workers apps)
  "/vendor\\/symfony\\/[^/]+\\/Resources\\/translations\\//",

  // Symfony Resources not needed at runtime
  "/vendor\\/symfony\\/[^/]+\\/Resources\\/schemas\\//",
  "/vendor\\/symfony\\/[^/]+\\/Resources\\/bin\\//",
  "/vendor\\/symfony\\/http-kernel\\/Resources\\/welcome/",

  // Symfony polyfill stubs for PHP ≤ 8.4 (target runtime is PHP 8.5; native classes exist)
  "/vendor\\/symfony\\/polyfill-php[0-9]+\\/Resources\\/stubs\\//",

  // Laravel framework exception renderer build tooling (not needed at runtime)
  "/vendor\\/laravel\\/framework\\/src\\/Illuminate\\/Foundation\\/resources\\/exceptions\\/renderer\\/package/",
  "/vendor\\/laravel\\/framework\\/src\\/Illuminate\\/Foundation\\/resources\\/exceptions\\/renderer\\/vite/",

  // NOTE: Illuminate/Testing/ is NOT excluded — FoundationServiceProvider
  // unconditionally registers ParallelTestingServiceProvider at boot.

  // Laravel framework fixtures & stubs (dev-only)
  "/vendor\\/laravel\\/framework\\/src\\/Illuminate\\/Foundation\\/Console\\/stubs\\//",

  // Misc dev files in vendor
  "/vendor\\/[^/]+\\/[^/]+\\/\\.github\\//",
  "/vendor\\/[^/]+\\/[^/]+\\/\\.travis\\.yml$/",
  "/vendor\\/[^/]+\\/[^/]+\\/appveyor\\.yml$/",
  "/vendor\\/[^/]+\\/[^/]+\\/CONTRIBUTING/",
  "/vendor\\/[^/]+\\/[^/]+\\/SECURITY\\.md$/",
];

const toRegExp = (p) => new RegExp(p.replace(/^\//, "").replace(/\/$/, ""));
const defaultPatterns = DEFAULT_EXCLUDE_PATTERNS.map(toRegExp);
const userPatterns = (config.exclude_patterns ?? []).map(toRegExp);
const EXCLUDE_PATTERNS = [...defaultPatterns, ...userPatterns];

const EXTENSIONS = config.extensions ?? { mbstring: true, openssl: true };
// Default to false for initial build to avoid timeout - user can enable in build-config.json
const STRIP_WHITESPACE = config.strip_whitespace ?? false;

/**
 * Generate PHP stub functions for missing extensions.
 * These stubs provide minimal implementations when extensions are not enabled.
 */
function generatePhpStubs(extensions) {
  const stubs = [];

  // Enable error reporting so PHP errors appear in Cloudflare logs (stderr).
  // display_errors sends output to stderr in CGI mode, not to the HTTP response body.
  stubs.push(`
// Report PHP errors to stderr (visible in Cloudflare Workers logs)
error_reporting(E_ALL);
ini_set('display_errors', 'stderr');
ini_set('display_startup_errors', '1');`);

  // umask fix for MEMFS - always needed
  stubs.push(`
// Fix for MEMFS umask issue
if (!function_exists('umask')) {
    function umask($mask = null) {
        return 0022;
    }
}`);

  // iconv stubs - only if iconv extension is not enabled
  if (!extensions.iconv) {
    stubs.push(`
// iconv stub functions
if (!function_exists('iconv')) {
    function iconv($from_encoding, $to_encoding, $string) {
        return $string;
    }
}
if (!function_exists('iconv_strlen')) {
    function iconv_strlen($string, $encoding = null) {
        return strlen($string);
    }
}
if (!function_exists('iconv_substr')) {
    function iconv_substr($string, $offset, $length = null, $encoding = null) {
        return substr($string, $offset, $length);
    }
}
if (!function_exists('iconv_strpos')) {
    function iconv_strpos($haystack, $needle, $offset = 0, $encoding = null) {
        return strpos($haystack, $needle, $offset);
    }
}
if (!function_exists('iconv_strrpos')) {
    function iconv_strrpos($haystack, $needle, $encoding = null) {
        return strrpos($haystack, $needle);
    }
}`);
  }

  // mbstring stubs - only if mbstring extension is not enabled
  if (!extensions.mbstring) {
    stubs.push(`
// mbstring stub functions
if (!function_exists('mb_split')) {
    function mb_split($pattern, $string, $limit = -1) {
        return preg_split('/' . $pattern . '/', $string, $limit);
    }
}
if (!function_exists('mb_strlen')) {
    function mb_strlen($string, $encoding = null) {
        return strlen($string);
    }
}
if (!function_exists('mb_substr')) {
    function mb_substr($string, $start, $length = null, $encoding = null) {
        return substr($string, $start, $length);
    }
}
if (!function_exists('mb_strpos')) {
    function mb_strpos($haystack, $needle, $offset = 0, $encoding = null) {
        return strpos($haystack, $needle, $offset);
    }
}`);
  }

  // filter stubs - only if filter extension is not enabled
  if (!extensions.filter) {
    stubs.push(`
// filter extension constants
if (!defined('FILTER_VALIDATE_INT')) {
    define('FILTER_VALIDATE_INT', 257);
    define('FILTER_VALIDATE_BOOLEAN', 258);
    define('FILTER_VALIDATE_FLOAT', 259);
    define('FILTER_VALIDATE_EMAIL', 274);
    define('FILTER_VALIDATE_URL', 273);
    define('FILTER_VALIDATE_IP', 275);
    define('FILTER_VALIDATE_MAC', 281);
    define('FILTER_VALIDATE_DOMAIN', 277);
    define('FILTER_VALIDATE_REGEXP', 272);
    define('FILTER_DEFAULT', 516);
    define('FILTER_UNSAFE_RAW', 516);
    define('FILTER_SANITIZE_STRING', 513);
    define('FILTER_SANITIZE_STRIPPED', 513);
    define('FILTER_SANITIZE_ENCODED', 514);
    define('FILTER_SANITIZE_SPECIAL_CHARS', 515);
    define('FILTER_SANITIZE_NUMBER_INT', 519);
    define('FILTER_SANITIZE_NUMBER_FLOAT', 520);
    define('FILTER_SANITIZE_URL', 518);
    define('FILTER_SANITIZE_EMAIL', 517);
    define('FILTER_SANITIZE_ADD_SLASHES', 523);
    define('FILTER_SANITIZE_FULL_SPECIAL_CHARS', 522);
    define('FILTER_CALLBACK', 1024);
    define('FILTER_FLAG_NONE', 0);
    define('FILTER_FLAG_ALLOW_OCTAL', 1);
    define('FILTER_FLAG_ALLOW_HEX', 2);
    define('FILTER_FLAG_STRIP_LOW', 4);
    define('FILTER_FLAG_STRIP_HIGH', 8);
    define('FILTER_FLAG_ENCODE_LOW', 16);
    define('FILTER_FLAG_ENCODE_HIGH', 32);
    define('FILTER_FLAG_ENCODE_AMP', 64);
    define('FILTER_FLAG_NO_ENCODE_QUOTES', 128);
    define('FILTER_FLAG_EMPTY_STRING_NULL', 256);
    define('FILTER_FLAG_STRIP_BACKTICK', 512);
    define('FILTER_FLAG_ALLOW_FRACTION', 1024);
    define('FILTER_FLAG_ALLOW_THOUSAND', 2048);
    define('FILTER_FLAG_ALLOW_SCIENTIFIC', 4096);
    define('FILTER_FLAG_PATH_REQUIRED', 262144);
    define('FILTER_FLAG_QUERY_REQUIRED', 524288);
    define('FILTER_FLAG_IPV4', 1048576);
    define('FILTER_FLAG_IPV6', 2097152);
    define('FILTER_FLAG_NO_RES_RANGE', 4194304);
    define('FILTER_FLAG_NO_PRIV_RANGE', 8388608);
    define('FILTER_FLAG_HOSTNAME', 1048576);
    define('FILTER_FLAG_EMAIL_UNICODE', 1048576);
    define('FILTER_REQUIRE_SCALAR', 33554432);
    define('FILTER_REQUIRE_ARRAY', 16777216);
    define('FILTER_FORCE_ARRAY', 67108864);
    define('FILTER_NULL_ON_FAILURE', 134217728);
    define('INPUT_GET', 1);
    define('INPUT_POST', 2);
    define('INPUT_COOKIE', 4);
    define('INPUT_SERVER', 5);
    define('INPUT_ENV', 16);
}
if (!function_exists('filter_var')) {
    function filter_var($value, $filter = 516, $options = 0) {
        if (is_array($options)) {
            $flags = $options['flags'] ?? 0;
            $opts = $options['options'] ?? [];
        } else {
            $flags = $options;
            $opts = [];
        }
        switch ($filter) {
            case 257: // FILTER_VALIDATE_INT
                $min = $opts['min_range'] ?? null;
                $max = $opts['max_range'] ?? null;
                if (is_int($value)) { $v = $value; }
                elseif (is_string($value) && preg_match('/^[+-]?\\d+$/', trim($value))) { $v = (int) trim($value); }
                else { return false; }
                if ($min !== null && $v < $min) return false;
                if ($max !== null && $v > $max) return false;
                return $v;
            case 259: // FILTER_VALIDATE_FLOAT
                if (is_float($value) || is_int($value)) return (float) $value;
                if (is_string($value) && is_numeric(trim($value))) return (float) trim($value);
                return false;
            case 258: // FILTER_VALIDATE_BOOLEAN
                if ($value === true || $value === 1 || $value === '1' || strtolower((string)$value) === 'true' || strtolower((string)$value) === 'on' || strtolower((string)$value) === 'yes') return true;
                if ($value === false || $value === 0 || $value === '0' || $value === '' || strtolower((string)$value) === 'false' || strtolower((string)$value) === 'off' || strtolower((string)$value) === 'no') return false;
                if ($flags & 134217728) return null;
                return false;
            case 274: // FILTER_VALIDATE_EMAIL
                return preg_match('/^[^@\\s]+@[^@\\s]+\\.[^@\\s]+$/', (string) $value) ? (string) $value : false;
            case 273: // FILTER_VALIDATE_URL
                return preg_match('/^https?:\\/\\/.+/i', (string) $value) ? (string) $value : false;
            case 275: // FILTER_VALIDATE_IP
                $v = (string) $value;
                if (($flags & 1048576) && filter_var_ipv4($v)) return $v;
                if (($flags & 2097152) && filter_var_ipv6($v)) return $v;
                if (!$flags || ($flags & ~(4194304|8388608|1048576|2097152)) === 0) {
                    if (filter_var_ipv4($v) || filter_var_ipv6($v)) return $v;
                }
                return false;
            case 272: // FILTER_VALIDATE_REGEXP
                $regexp = $opts['regexp'] ?? '';
                return preg_match($regexp, (string) $value) ? (string) $value : false;
            case 519: // FILTER_SANITIZE_NUMBER_INT
                return preg_replace('/[^0-9+\\-]/', '', (string) $value);
            case 520: // FILTER_SANITIZE_NUMBER_FLOAT
                $allow = '';
                if ($flags & 1024) $allow .= '.';
                if ($flags & 2048) $allow .= ',';
                if ($flags & 4096) $allow .= 'eE';
                return preg_replace('/[^0-9+\\-' . preg_quote($allow, '/') . ']/', '', (string) $value);
            case 515: // FILTER_SANITIZE_SPECIAL_CHARS
            case 522: // FILTER_SANITIZE_FULL_SPECIAL_CHARS
                return htmlspecialchars((string) $value, ENT_QUOTES | ENT_SUBSTITUTE, 'UTF-8');
            case 518: // FILTER_SANITIZE_URL
                return (string) $value;
            case 517: // FILTER_SANITIZE_EMAIL
                return (string) $value;
            case 514: // FILTER_SANITIZE_ENCODED
                return rawurlencode((string) $value);
            case 523: // FILTER_SANITIZE_ADD_SLASHES
                return addslashes((string) $value);
            case 513: // FILTER_SANITIZE_STRING
                return strip_tags((string) $value);
            case 1024: // FILTER_CALLBACK
                $callback = is_callable($opts) ? $opts : ($opts['callback'] ?? null);
                return is_callable($callback) ? $callback($value) : $value;
            default: // FILTER_DEFAULT
                return (string) $value;
        }
    }
    function filter_var_ipv4($ip) { return preg_match('/^(\\d{1,3}\\.){3}\\d{1,3}$/', $ip) && !preg_match('/\\d{4,}/', $ip); }
    function filter_var_ipv6($ip) { return strpos($ip, ':') !== false && preg_match('/^[0-9a-fA-F:]+$/', str_replace(['[', ']'], '', $ip)); }
}
if (!function_exists('filter_input')) {
    function filter_input($type, $var_name, $filter = 516, $options = 0) {
        switch ($type) {
            case 1: $source = $_GET ?? []; break;
            case 2: $source = $_POST ?? []; break;
            case 4: $source = $_COOKIE ?? []; break;
            case 5: $source = $_SERVER ?? []; break;
            case 16: $source = $_ENV ?? []; break;
            default: return null;
        }
        if (!isset($source[$var_name])) return null;
        return filter_var($source[$var_name], $filter, $options);
    }
}
if (!function_exists('filter_has_var')) {
    function filter_has_var($type, $var_name) {
        switch ($type) {
            case 1: return isset($_GET[$var_name]);
            case 2: return isset($_POST[$var_name]);
            case 4: return isset($_COOKIE[$var_name]);
            case 5: return isset($_SERVER[$var_name]);
            case 16: return isset($_ENV[$var_name]);
            default: return false;
        }
    }
}
if (!function_exists('filter_input_array')) {
    function filter_input_array($type, $options = null, $add_empty = true) {
        switch ($type) {
            case 1: $source = $_GET ?? []; break;
            case 2: $source = $_POST ?? []; break;
            case 4: $source = $_COOKIE ?? []; break;
            case 5: $source = $_SERVER ?? []; break;
            case 16: $source = $_ENV ?? []; break;
            default: return null;
        }
        if ($options === null || is_int($options)) {
            $result = [];
            foreach ($source as $k => $v) {
                $result[$k] = is_int($options) ? filter_var($v, $options) : $v;
            }
            return $result;
        }
        return $source;
    }
}
if (!function_exists('filter_var_array')) {
    function filter_var_array($array, $options = null, $add_empty = true) {
        if ($options === null || is_int($options)) {
            $result = [];
            foreach ($array as $k => $v) {
                $result[$k] = is_int($options) ? filter_var($v, $options) : $v;
            }
            return $result;
        }
        return $array;
    }
}
if (!function_exists('filter_list')) {
    function filter_list() {
        return ['int', 'boolean', 'float', 'validate_regexp', 'validate_domain', 'validate_url', 'validate_email', 'validate_ip', 'validate_mac', 'string', 'stripped', 'encoded', 'special_chars', 'full_special_chars', 'unsafe_raw', 'email', 'url', 'number_int', 'number_float', 'add_slashes', 'callback'];
    }
}
if (!function_exists('filter_id')) {
    function filter_id($name) {
        $map = ['int' => 257, 'boolean' => 258, 'float' => 259, 'validate_regexp' => 272, 'validate_url' => 273, 'validate_email' => 274, 'validate_ip' => 275, 'string' => 513, 'stripped' => 513, 'encoded' => 514, 'special_chars' => 515, 'unsafe_raw' => 516, 'email' => 517, 'url' => 518, 'number_int' => 519, 'number_float' => 520, 'full_special_chars' => 522, 'add_slashes' => 523, 'callback' => 1024];
        return $map[$name] ?? false;
    }
}`);
  }

  // ctype stubs - only if ctype extension is not enabled
  if (!extensions.ctype) {
    stubs.push(`
// ctype stub functions
if (!function_exists('ctype_alnum')) {
    function ctype_alnum($text) { return is_string($text) && $text !== '' && preg_match('/^[a-zA-Z0-9]+$/', $text); }
    function ctype_alpha($text) { return is_string($text) && $text !== '' && preg_match('/^[a-zA-Z]+$/', $text); }
    function ctype_cntrl($text) { return is_string($text) && $text !== '' && preg_match('/^[\\x00-\\x1f\\x7f]+$/', $text); }
    function ctype_digit($text) { return is_string($text) && $text !== '' && preg_match('/^[0-9]+$/', $text); }
    function ctype_graph($text) { return is_string($text) && $text !== '' && preg_match('/^[\\x21-\\x7e]+$/', $text); }
    function ctype_lower($text) { return is_string($text) && $text !== '' && preg_match('/^[a-z]+$/', $text); }
    function ctype_print($text) { return is_string($text) && $text !== '' && preg_match('/^[\\x20-\\x7e]+$/', $text); }
    function ctype_punct($text) { return is_string($text) && $text !== '' && preg_match('/^[^a-zA-Z0-9\\s]+$/', $text); }
    function ctype_space($text) { return is_string($text) && $text !== '' && preg_match('/^[\\s]+$/', $text); }
    function ctype_upper($text) { return is_string($text) && $text !== '' && preg_match('/^[A-Z]+$/', $text); }
    function ctype_xdigit($text) { return is_string($text) && $text !== '' && preg_match('/^[0-9a-fA-F]+$/', $text); }
}`);
  }

  // tokenizer stubs - only if tokenizer extension is not enabled
  if (!extensions.tokenizer) {
    stubs.push(`
// tokenizer stub constants
if (!defined('T_OPEN_TAG')) {
    define('T_OPEN_TAG', 379);
    define('T_OPEN_TAG_WITH_ECHO', 380);
    define('T_CLOSE_TAG', 381);
    define('T_WHITESPACE', 396);
    define('T_COMMENT', 397);
    define('T_DOC_COMMENT', 398);
    define('T_STRING', 319);
    define('T_VARIABLE', 320);
    define('T_INLINE_HTML', 323);
    define('T_ECHO', 328);
    define('T_CONSTANT_ENCAPSED_STRING', 321);
    define('T_LNUMBER', 311);
    define('T_DNUMBER', 312);
    define('TOKEN_PARSE', 1);
}
if (!function_exists('token_get_all')) {
    /**
     * String-aware PHP tokenizer stub for WASM (tokenizer extension disabled).
     * Properly handles strings, parentheses, and close tags inside strings.
     * Used by Livewire, phpdocumentor, serializable-closure, and other packages
     * that call token_get_all() at runtime.
     */
    function token_get_all($code, $flags = 0) {
        $tokens = [];
        $len = strlen($code);
        $pos = 0;
        $line = 1;

        while ($pos < $len) {
            $nextOpen = strpos($code, '<?', $pos);

            if ($nextOpen === false) {
                $html = substr($code, $pos);
                if ($html !== '') {
                    $tokens[] = [T_INLINE_HTML, $html, $line];
                }
                break;
            }

            if ($nextOpen > $pos) {
                $html = substr($code, $pos, $nextOpen - $pos);
                $tokens[] = [T_INLINE_HTML, $html, $line];
                $line += substr_count($html, "\\n");
            }

            if (substr($code, $nextOpen, 5) === '<?php' && ($nextOpen + 5 >= $len || !ctype_alnum($code[$nextOpen + 5]))) {
                $tagEnd = $nextOpen + 5;
                if ($tagEnd < $len && ($code[$tagEnd] === ' ' || $code[$tagEnd] === "\\n" || $code[$tagEnd] === "\\r" || $code[$tagEnd] === "\\t")) {
                    $tagEnd++;
                }
                $openTag = substr($code, $nextOpen, $tagEnd - $nextOpen);
                $tokens[] = [T_OPEN_TAG, $openTag, $line];
                $line += substr_count($openTag, "\\n");
                $pos = $tagEnd;
            } elseif (substr($code, $nextOpen, 3) === '<?=') {
                $tokens[] = [T_OPEN_TAG_WITH_ECHO, '<?= ', $line];
                $pos = $nextOpen + 3;
                if ($pos < $len && $code[$pos] === ' ') $pos++;
            } else {
                $tokens[] = [T_INLINE_HTML, '<?', $line];
                $pos = $nextOpen + 2;
                continue;
            }

            // Character-by-character PHP block parsing — handles strings and parens
            $current = '';
            $inPhp = true;
            while ($pos < $len && $inPhp) {
                $char = $code[$pos];

                if ($char === '?' && $pos + 1 < $len && $code[$pos + 1] === '>') {
                    if ($current !== '') {
                        $tokens[] = [T_STRING, $current, $line];
                        $current = '';
                    }
                    $closeEnd = $pos + 2;
                    if ($closeEnd < $len && $code[$closeEnd] === "\\n") $closeEnd++;
                    $closeTag = substr($code, $pos, $closeEnd - $pos);
                    $tokens[] = [T_CLOSE_TAG, $closeTag, $line];
                    $line += substr_count($closeTag, "\\n");
                    $pos = $closeEnd;
                    $inPhp = false;
                    continue;
                }

                if ($char === '"' || $char === "'") {
                    if ($current !== '') {
                        $tokens[] = [T_STRING, $current, $line];
                        $current = '';
                    }
                    $quote = $char;
                    $str = $char;
                    $pos++;
                    while ($pos < $len && $code[$pos] !== $quote) {
                        if ($code[$pos] === '\\\\' && $pos + 1 < $len) {
                            $str .= $code[$pos] . $code[$pos + 1];
                            $pos += 2;
                            continue;
                        }
                        if ($code[$pos] === "\\n") $line++;
                        $str .= $code[$pos];
                        $pos++;
                    }
                    if ($pos < $len) {
                        $str .= $code[$pos];
                        $pos++;
                    }
                    $tokens[] = [T_CONSTANT_ENCAPSED_STRING, $str, $line];
                    continue;
                }

                if ($char === '(' || $char === ')') {
                    if ($current !== '') {
                        $tokens[] = [T_STRING, $current, $line];
                        $current = '';
                    }
                    $tokens[] = $char;
                    $pos++;
                    continue;
                }

                if ($char === "\\n") $line++;
                $current .= $char;
                $pos++;
            }

            if ($inPhp && $current !== '') {
                $tokens[] = [T_STRING, $current, $line];
            }
        }

        return $tokens;
    }
}
if (!function_exists('token_name')) {
    function token_name($id) {
        $names = [379 => 'T_OPEN_TAG', 380 => 'T_OPEN_TAG_WITH_ECHO', 381 => 'T_CLOSE_TAG', 396 => 'T_WHITESPACE', 397 => 'T_COMMENT', 398 => 'T_DOC_COMMENT', 319 => 'T_STRING', 320 => 'T_VARIABLE', 321 => 'T_CONSTANT_ENCAPSED_STRING', 323 => 'T_INLINE_HTML', 328 => 'T_ECHO'];
        return $names[$id] ?? 'UNKNOWN';
    }
}`);
  }

  // openssl stubs - only if openssl extension is not enabled
  if (!extensions.openssl) {
    stubs.push(`
// openssl stub functions (NOT SECURE - for development only)
if (!function_exists('openssl_encrypt')) {
    function openssl_encrypt($data, $cipher_algo, $passphrase, $options = 0, $iv = '', &$tag = null, $aad = '', $tag_length = 16) {
        // Simple XOR encryption - NOT secure, only for testing
        $key = substr($passphrase, 0, 32);
        $result = '';
        for ($i = 0; $i < strlen($data); $i++) {
            $result .= $data[$i] ^ $key[$i % strlen($key)];
        }
        return base64_encode($result);
    }
}
if (!function_exists('openssl_decrypt')) {
    function openssl_decrypt($data, $cipher_algo, $passphrase, $options = 0, $iv = '', $tag = null, $aad = '') {
        // Simple XOR decryption - NOT secure, only for testing
        $key = substr($passphrase, 0, 32);
        $decoded = base64_decode($data);
        $result = '';
        for ($i = 0; $i < strlen($decoded); $i++) {
            $result .= $decoded[$i] ^ $key[$i % strlen($key)];
        }
        return $result;
    }
}
if (!function_exists('openssl_random_pseudo_bytes')) {
    function openssl_random_pseudo_bytes($length, &$strong_result = null) {
        $strong_result = false;
        return random_bytes($length);
    }
}
if (!function_exists('openssl_cipher_iv_length')) {
    function openssl_cipher_iv_length($cipher_algo) {
        return 16;
    }
}`);
  }

  // Include class preloader if it exists (generated by laraworker:build)
  stubs.push(`
// Class preloader — eliminates per-class autoloader lookups in WASM
if (file_exists('/app/bootstrap/preload.php')) {
    require_once '/app/bootstrap/preload.php';
}`);

  // The WASM PHP tokenizer is broken: token_get_all() treats all code after <?php
  // as a single T_STRING token instead of properly tokenizing. This breaks both:
  // 1. BladeCompiler::hasEvenNumberOfParentheses() — needs string-aware paren counting
  // 2. BladeCompiler::compileString()/parseToken() — needs T_INLINE_HTML for @directives
  //
  // PHP resolves bare function calls to the current namespace first, so defining
  // token_get_all in the Illuminate\View\Compilers namespace shadows the broken
  // global version for all BladeCompiler code.
  const bladeTokenizerFix = `
namespace Illuminate\\View\\Compilers {
    function token_get_all(string $code, int $flags = 0): array {
        $tokens = [];
        $len = strlen($code);
        $pos = 0;
        $line = 1;

        while ($pos < $len) {
            $nextOpen = strpos($code, '<?', $pos);

            if ($nextOpen === false) {
                $html = substr($code, $pos);
                if ($html !== '') {
                    $tokens[] = [T_INLINE_HTML, $html, $line];
                }
                break;
            }

            if ($nextOpen > $pos) {
                $html = substr($code, $pos, $nextOpen - $pos);
                $tokens[] = [T_INLINE_HTML, $html, $line];
                $line += substr_count($html, "\\n");
            }

            if (substr($code, $nextOpen, 5) === '<?php' && ($nextOpen + 5 >= $len || !ctype_alnum($code[$nextOpen + 5]))) {
                $tagEnd = $nextOpen + 5;
                if ($tagEnd < $len && ($code[$tagEnd] === ' ' || $code[$tagEnd] === "\\n" || $code[$tagEnd] === "\\r" || $code[$tagEnd] === "\\t")) {
                    $tagEnd++;
                }
                $openTag = substr($code, $nextOpen, $tagEnd - $nextOpen);
                $tokens[] = [T_OPEN_TAG, $openTag, $line];
                $line += substr_count($openTag, "\\n");
                $pos = $tagEnd;
            } elseif (substr($code, $nextOpen, 3) === '<?=') {
                $tokens[] = [T_OPEN_TAG_WITH_ECHO, '<?= ', $line];
                $pos = $nextOpen + 3;
                if ($pos < $len && $code[$pos] === ' ') $pos++;
            } else {
                $tokens[] = [T_INLINE_HTML, '<?', $line];
                $pos = $nextOpen + 2;
                continue;
            }

            $current = '';
            $inPhp = true;
            while ($pos < $len && $inPhp) {
                $char = $code[$pos];

                if ($char === '?' && $pos + 1 < $len && $code[$pos + 1] === '>') {
                    if ($current !== '') {
                        $tokens[] = [T_STRING, $current, $line];
                        $current = '';
                    }
                    $closeEnd = $pos + 2;
                    if ($closeEnd < $len && $code[$closeEnd] === "\\n") $closeEnd++;
                    $closeTag = substr($code, $pos, $closeEnd - $pos);
                    $tokens[] = [T_CLOSE_TAG, $closeTag, $line];
                    $line += substr_count($closeTag, "\\n");
                    $pos = $closeEnd;
                    $inPhp = false;
                    continue;
                }

                if ($char === '"' || $char === "'") {
                    if ($current !== '') {
                        $tokens[] = [T_STRING, $current, $line];
                        $current = '';
                    }
                    $quote = $char;
                    $str = $char;
                    $pos++;
                    while ($pos < $len && $code[$pos] !== $quote) {
                        if ($code[$pos] === '\\\\' && $pos + 1 < $len) {
                            $str .= $code[$pos] . $code[$pos + 1];
                            $pos += 2;
                            continue;
                        }
                        if ($code[$pos] === "\\n") $line++;
                        $str .= $code[$pos];
                        $pos++;
                    }
                    if ($pos < $len) {
                        $str .= $code[$pos];
                        $pos++;
                    }
                    $tokens[] = [T_CONSTANT_ENCAPSED_STRING, $str, $line];
                    continue;
                }

                if ($char === '(' || $char === ')') {
                    if ($current !== '') {
                        $tokens[] = [T_STRING, $current, $line];
                        $current = '';
                    }
                    $tokens[] = $char;
                    $pos++;
                    continue;
                }

                if ($char === "\\n") $line++;
                $current .= $char;
                $pos++;
            }

            if ($inPhp && $current !== '') {
                $tokens[] = [T_STRING, $current, $line];
            }
        }

        return $tokens;
    }
}
`;

  // uniqid() hangs on the 2nd call within a single WASM process because the native
  // C implementation calls usleep(1) internally and usleep is broken under Emscripten
  // Asyncify. PHP resolves bare function calls to the current namespace first, so we
  // define a safe uniqid() in every namespace that calls it at runtime.
  //
  // The global helper __wasm_safe_uniqid() lives in the global namespace and produces
  // output identical to native uniqid(): prefix + 13 hex chars (+ ".XXXXXXXX" with
  // more_entropy). A static counter ensures uniqueness even when microtime hasn't
  // advanced between calls.
  const uniqidNamespaces = ["Livewire\\Features\\SupportQueryString", "Illuminate\\Cache"];
  const wasmUniqidFix =
    `
namespace {
    function __wasm_safe_uniqid(string $prefix = '', bool $more_entropy = false): string {
        static $counter = 0;
        $counter++;
        $time = microtime(true);
        $sec = (int)$time;
        $usec = (int)(($time - $sec) * 1000000);
        $result = $prefix . sprintf('%08x%05x', $sec, $usec + $counter);
        if ($more_entropy) {
            $result .= sprintf('.%08d', mt_rand(0, 99999999));
        }
        return $result;
    }
}
` +
    uniqidNamespaces
      .map(
        (ns) => `
namespace ${ns} {
    function uniqid(string $prefix = '', bool $more_entropy = false): string {
        return \\__wasm_safe_uniqid($prefix, $more_entropy);
    }
}
`,
      )
      .join("");

  return (
    "<?php\n// Auto-generated PHP stubs for missing extensions\n// Extensions enabled: " +
    JSON.stringify(extensions) +
    "\nnamespace {\n" +
    stubs.join("\n") +
    "\n}\n" +
    bladeTokenizerFix +
    wasmUniqidFix
  );
}

// Cache directory for stripped PHP files — persists between builds
const STRIP_CACHE_DIR = join(import.meta.dirname, ".strip-cache");
// Number of parallel php -w workers
const STRIP_CONCURRENCY = Math.max(4, cpus().length);

/**
 * Run async tasks with a bounded concurrency pool.
 */
async function mapConcurrent(items, fn, concurrency) {
  const results = Array.from({ length: items.length });
  let index = 0;
  async function worker() {
    while (index < items.length) {
      const i = index++;
      results[i] = await fn(items[i], i);
    }
  }
  await Promise.all(Array.from({ length: concurrency }, worker));
  return results;
}

/**
 * Strip whitespace from a single PHP file asynchronously.
 * Uses a content-hash cache to skip unchanged files.
 * Returns stripped Buffer or null on failure.
 */
async function stripPhpFileAsync(filePath, originalContent) {
  const hash = createHash("sha256").update(originalContent).digest("hex");
  const cachePath = join(STRIP_CACHE_DIR, hash);

  // Cache hit — return without spawning a PHP process
  if (existsSync(cachePath)) {
    return { content: readFileSync(cachePath), fromCache: true };
  }

  try {
    const { stdout } = await execFileAsync("php", ["-w", filePath], {
      encoding: "buffer",
      timeout: 30_000,
      maxBuffer: 10 * 1024 * 1024,
    });

    if (stdout && stdout.length > 0) {
      mkdirSync(STRIP_CACHE_DIR, { recursive: true });
      writeFileSync(cachePath, stdout);
      return { content: stdout, fromCache: false };
    }
  } catch {
    // php -w failed — skip this file
  }

  return null;
}

/**
 * Pre-process all PHP files in parallel.
 * Returns a Map of fullPath → stripped Buffer.
 */
async function stripPhpFilesParallel(files) {
  const phpFiles = files.filter(
    (f) =>
      !f.isDir &&
      f.path.endsWith(".php") &&
      !f.path.endsWith(".blade.php") &&
      !f.path.startsWith("php-stubs") &&
      !f.path.startsWith("storage/framework/views/"),
  );

  const startTime = Date.now();
  let cacheHits = 0;
  const strippedMap = new Map();

  await mapConcurrent(
    phpFiles,
    async (file) => {
      const original = readFileSync(file.fullPath);
      const result = await stripPhpFileAsync(file.fullPath, original);

      if (result) {
        const saved = original.length - result.content.length;
        if (saved > 0) {
          strippedMap.set(file.fullPath, result.content);
          if (result.fromCache) {
            cacheHits++;
          }
        }
      }
    },
    STRIP_CONCURRENCY,
  );

  const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
  console.log(
    `    Done in ${elapsed}s (${cacheHits}/${phpFiles.length} cache hits, ${strippedMap.size} files reduced)`,
  );

  return strippedMap;
}

/**
 * Collect all files from a directory recursively.
 */
function collectFiles(dir, basePath = "") {
  const results = [];
  const entries = readdirSync(dir, { withFileTypes: true });

  for (const entry of entries) {
    const fullPath = join(dir, entry.name);
    const relPath = basePath ? `${basePath}/${entry.name}` : entry.name;

    const testPath = "/" + relPath;
    if (EXCLUDE_PATTERNS.some((p) => p.test(testPath))) {
      continue;
    }

    if (entry.isDirectory()) {
      results.push({ path: relPath + "/", isDir: true });
      results.push(...collectFiles(fullPath, relPath));
    } else if (entry.isFile()) {
      results.push({ path: relPath, isDir: false, fullPath });
    }
  }

  return results;
}

/**
 * Create a 512-byte tar header for a file or directory.
 */
function createTarHeader(path, size, isDir) {
  const header = new Uint8Array(512);
  const encoder = new TextEncoder();

  let name = path;
  let ustarPrefix = "";

  if (name.length > 100) {
    const splitAt = name.lastIndexOf("/", 155);
    if (splitAt > 0) {
      ustarPrefix = name.substring(0, splitAt);
      name = name.substring(splitAt + 1);
    }
  }

  header.set(encoder.encode(name.substring(0, 100)), 0);

  const mode = isDir ? "0000755" : "0000644";
  header.set(encoder.encode(mode + "\0"), 100);

  header.set(encoder.encode("0001000\0"), 108);
  header.set(encoder.encode("0001000\0"), 116);

  const sizeStr = size.toString(8).padStart(11, "0");
  header.set(encoder.encode(sizeStr + "\0"), 124);

  const mtime = Math.floor(Date.now() / 1000)
    .toString(8)
    .padStart(11, "0");
  header.set(encoder.encode(mtime + "\0"), 136);

  header.set(encoder.encode("        "), 148);

  header[156] = isDir ? 53 : 48;

  header.set(encoder.encode("ustar\0"), 257);
  header.set(encoder.encode("00"), 263);

  if (ustarPrefix) {
    header.set(encoder.encode(ustarPrefix.substring(0, 155)), 345);
  }

  let checksum = 0;
  for (let i = 0; i < 512; i++) {
    checksum += header[i];
  }
  const checksumStr = checksum.toString(8).padStart(6, "0") + "\0 ";
  header.set(encoder.encode(checksumStr), 148);

  return header;
}

/**
 * Create a tar archive from collected files.
 * When strippedContents is provided, pre-stripped PHP content is used directly.
 * Tracks vendorBytes and appBytes for the report.
 */
function createTar(files, { stripWhitespace = false, strippedContents = new Map() } = {}) {
  const chunks = [];
  let strippedCount = 0;
  let bytesSaved = 0;
  let vendorBytes = 0;
  let appBytes = 0;

  for (const file of files) {
    if (file.isDir) {
      chunks.push(createTarHeader(file.path, 0, true));
    } else {
      let content = readFileSync(file.fullPath);

      // Use pre-stripped content if available
      if (
        stripWhitespace &&
        file.path.endsWith(".php") &&
        !file.path.endsWith(".blade.php") &&
        !file.path.startsWith("php-stubs") &&
        !file.path.startsWith("storage/framework/views/")
      ) {
        const stripped = strippedContents.get(file.fullPath);
        if (stripped && stripped.length > 0) {
          const saved = content.length - stripped.length;
          if (saved > 0) {
            bytesSaved += saved;
            strippedCount++;
            content = stripped;
          }
        }
      }

      // Track per-category uncompressed content bytes
      if (file.path.startsWith("vendor/")) {
        vendorBytes += content.length;
      } else {
        appBytes += content.length;
      }

      chunks.push(createTarHeader(file.path, content.length, false));
      chunks.push(new Uint8Array(content));

      const remainder = content.length % 512;
      if (remainder > 0) {
        chunks.push(new Uint8Array(512 - remainder));
      }
    }
  }

  chunks.push(new Uint8Array(1024));

  const totalSize = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
  const result = new Uint8Array(totalSize);
  let offset = 0;
  for (const chunk of chunks) {
    result.set(chunk, offset);
    offset += chunk.length;
  }

  return { tar: result, strippedCount, bytesSaved, vendorBytes, appBytes };
}

const fmt = (bytes) => {
  if (bytes >= 1024 * 1024) return (bytes / 1024 / 1024).toFixed(2) + " MB";
  return (bytes / 1024).toFixed(0) + " KB";
};

// --- Main ---

console.log("  Starting build-app.mjs...");
console.log(`  ROOT: ${ROOT}`);
console.log(`  DIST_DIR: ${DIST_DIR}`);

if (existsSync(DIST_DIR)) {
  console.log("  Cleaning dist directory...");
  rmSync(DIST_DIR, { recursive: true });
}

console.log("Building Laravel app tar...");

const allFiles = [];

for (const dir of INCLUDE_DIRS) {
  const fullDir = join(ROOT, dir);
  if (existsSync(fullDir)) {
    allFiles.push({ path: dir + "/", isDir: true });
    allFiles.push(...collectFiles(fullDir, dir));
  } else {
    console.warn(`  Warning: ${dir} not found, skipping`);
  }
}

for (const file of INCLUDE_FILES) {
  const fullPath = join(ROOT, file);
  if (existsSync(fullPath)) {
    const parts = file.split("/");
    if (parts.length > 1) {
      let dirPath = "";
      for (let i = 0; i < parts.length - 1; i++) {
        dirPath += (dirPath ? "/" : "") + parts[i];
        if (!allFiles.some((f) => f.path === dirPath + "/")) {
          allFiles.push({ path: dirPath + "/", isDir: true });
        }
      }
    }
    allFiles.push({ path: file, isDir: false, fullPath });
  } else {
    console.warn(`  Warning: ${file} not found, skipping`);
  }
}

// Add staging vendor files if available
if (VENDOR_STAGING_DIR && existsSync(VENDOR_STAGING_DIR)) {
  const stagingVendorDir = join(VENDOR_STAGING_DIR, "vendor");
  if (existsSync(stagingVendorDir)) {
    allFiles.push({ path: "vendor/", isDir: true });
    allFiles.push(...collectFiles(stagingVendorDir, "vendor"));
  }
}

// Copy .env.production as .env
const envSource = join(import.meta.dirname, ".env.production");
if (existsSync(envSource)) {
  allFiles.push({ path: ".env", isDir: false, fullPath: envSource });
} else {
  console.warn("  Warning: .laraworker/.env.production not found, no .env will be included");
}

// Add empty storage directory structure
const storageDirs = [
  "storage/",
  "storage/app/",
  "storage/framework/",
  "storage/framework/cache/",
  "storage/framework/cache/data/",
  "storage/framework/sessions/",
  "storage/framework/testing/",
  "storage/framework/views/",
  "storage/logs/",
];

for (const dir of storageDirs) {
  if (!allFiles.some((f) => f.path === dir)) {
    allFiles.push({ path: dir, isDir: true });
  }
}

// Include Vite manifest in the tar so PHP can read it for @vite() Blade directive.
// The actual JS/CSS assets are served by Cloudflare Static Assets (copied later),
// but PHP needs the manifest to generate <link> and <script> tags.
// Vite 7+ puts manifest at public/build/manifest.json; older versions use .vite/ subdir.
const viteManifestBuildDir = join(ROOT, "public", "build");
const viteManifestPaths = [
  {
    dir: join(viteManifestBuildDir, ".vite"),
    file: "manifest.json",
    tarDir: "public/build/.vite/",
  },
  { dir: viteManifestBuildDir, file: "manifest.json", tarDir: "public/build/" },
];

let viteManifestIncluded = false;
for (const { dir, file, tarDir } of viteManifestPaths) {
  const manifestPath = join(dir, file);
  if (existsSync(manifestPath)) {
    if (!allFiles.some((f) => f.path === "public/")) {
      allFiles.push({ path: "public/", isDir: true });
    }
    if (!allFiles.some((f) => f.path === "public/build/")) {
      allFiles.push({ path: "public/build/", isDir: true });
    }
    if (tarDir === "public/build/.vite/" && !allFiles.some((f) => f.path === tarDir)) {
      allFiles.push({ path: tarDir, isDir: true });
    }
    allFiles.push({ path: tarDir + file, isDir: false, fullPath: manifestPath });
    console.log(`  ✓ Vite manifest included in tar (${tarDir}${file})`);
    viteManifestIncluded = true;
    break;
  }
}
if (!viteManifestIncluded) {
  console.warn("  Warning: No Vite manifest found in public/build/");
}

// Include any additional Vite manifests found under public/ (e.g. vendor package assets).
// Package-provided Vite assets have manifests at paths like:
//   public/vendor/<pkg>/build/manifest.json
// PHP needs these manifests to resolve @vite() directives referencing package builds.
function findViteManifests(dir, relativeBase) {
  const found = [];
  if (!existsSync(dir)) return found;
  for (const entry of readdirSync(dir, { withFileTypes: true })) {
    const fullPath = join(dir, entry.name);
    const relPath = relativeBase ? `${relativeBase}/${entry.name}` : entry.name;
    if (entry.isDirectory()) {
      found.push(...findViteManifests(fullPath, relPath));
    } else if (
      entry.name === "manifest.json" &&
      relativeBase !== "build" &&
      !relativeBase?.startsWith("build/")
    ) {
      found.push({ fullPath, tarPath: `public/${relPath}` });
    }
  }
  return found;
}

const extraManifests = findViteManifests(join(ROOT, "public"), "");
for (const { fullPath, tarPath } of extraManifests) {
  // Skip if already included
  if (allFiles.some((f) => f.path === tarPath)) continue;
  // Ensure parent directories exist in the tar
  const parts = tarPath.split("/");
  for (let i = 1; i < parts.length; i++) {
    const dirPath = parts.slice(0, i).join("/") + "/";
    if (!allFiles.some((f) => f.path === dirPath)) {
      allFiles.push({ path: dirPath, isDir: true });
    }
  }
  allFiles.push({ path: tarPath, isDir: false, fullPath });
  console.log(`  ✓ Vite manifest included in tar (${tarPath})`);
}

// ──── Locale stripping ────
// Strip locale/language files from vendor packages, keeping only configured locales.
// This saves significant MEMFS space — e.g. Filament ships ~13 MB of locale files.
const KEEP_LOCALES = config.locales ?? ["en"];

// Carbon locale files: vendor/nesbot/carbon/src/Carbon/Lang/{locale}.php
const carbonLangPrefix = "vendor/nesbot/carbon/src/Carbon/Lang/";
const carbonRemoved = [];
for (let i = allFiles.length - 1; i >= 0; i--) {
  const f = allFiles[i];
  if (!f.path.startsWith(carbonLangPrefix) || f.isDir) continue;
  const filename = f.path.substring(carbonLangPrefix.length);
  // Carbon uses flat files: en.php, fr.php, etc.
  const locale = filename.replace(/\.php$/, "");
  if (!KEEP_LOCALES.includes(locale)) {
    carbonRemoved.push(f.path);
    allFiles.splice(i, 1);
  }
}
if (carbonRemoved.length > 0) {
  console.log(
    `  Stripped ${carbonRemoved.length} Carbon locale files (kept: ${KEEP_LOCALES.join(", ")})`,
  );
}

// Vendor lang directories: vendor/*/*/resources/lang/{locale}/ and vendor/*/resources/lang/{locale}/
// Matches Filament, Cachet, Livewire, and other Laravel packages that use resources/lang/{locale}/ structure.
const vendorLangPattern = /^vendor\/(?:[^/]+\/)?[^/]+\/resources\/lang\/([^/]+)\//;
const vendorLangRemoved = [];
for (let i = allFiles.length - 1; i >= 0; i--) {
  const f = allFiles[i];
  const match = f.path.match(vendorLangPattern);
  if (!match) continue;
  const locale = match[1];
  if (!KEEP_LOCALES.includes(locale)) {
    vendorLangRemoved.push(f.path);
    allFiles.splice(i, 1);
  }
}
if (vendorLangRemoved.length > 0) {
  console.log(
    `  Stripped ${vendorLangRemoved.length} vendor locale files (kept: ${KEEP_LOCALES.join(", ")})`,
  );
}

// ──── Blade icon tree-shaking ────
// Scan all PHP/Blade files for blade-icon references (e.g. heroicon-o-check, heroicon-m-calendar)
// and remove unused SVG files from blade icon packages. Filament ships 1,288 heroicon SVGs (~5 MB)
// but a typical app uses only 20-30 icons.
//
// Also handles dynamically-referenced icons via Filament's Heroicon enum — icons referenced as
// Heroicon::Eye are resolved at runtime to heroicon-m-eye / heroicon-s-eye / heroicon-c-eye
// depending on icon size, so we parse the enum and scan for Heroicon:: references in PHP files.
const BLADE_ICON_SETS = [
  {
    prefix: "heroicon-",
    svgDir: "vendor/blade-ui-kit/blade-heroicons/resources/svg/",
    // Filament's Heroicon enum generates icon names dynamically at runtime
    enumFile: "vendor/filament/support/src/Icons/Heroicon.php",
    enumRefPattern: /Heroicon::(\w+)/g,
  },
];

for (const iconSet of BLADE_ICON_SETS) {
  const svgPrefix = iconSet.svgDir;
  const svgFiles = allFiles.filter(
    (f) => !f.isDir && f.path.startsWith(svgPrefix) && f.path.endsWith(".svg"),
  );
  if (svgFiles.length === 0) continue;

  // Scan all PHP, Blade, and compiled view files for icon references
  const usedIcons = new Set();
  const iconRefPattern = new RegExp(
    iconSet.prefix.replace(/-/g, "[-.]") + "([a-z0-9][-a-z0-9]*)",
    "g",
  );

  // Pre-parse enum file if available for dynamic references
  const caseMap = new Map();
  if (iconSet.enumFile) {
    const enumEntry = allFiles.find((f) => !f.isDir && f.path === iconSet.enumFile);
    if (enumEntry?.fullPath) {
      try {
        const enumContent = readFileSync(enumEntry.fullPath, "utf8");
        for (const m of enumContent.matchAll(/case\s+(\w+)\s*=\s*'([^']+)'/g)) {
          caseMap.set(m[1], m[2]);
        }
      } catch {}
    }
  }

  const referencedValues = new Set();

  for (const f of allFiles) {
    if (f.isDir || !f.fullPath) continue;

    // Only process relevant PHP/Blade/view files
    const isPhpFile = f.path.endsWith(".php");
    const isBladeFile = f.path.endsWith(".blade.php");
    const isCompiledView = f.path.startsWith("storage/framework/views/");

    if (!(isPhpFile || isBladeFile || isCompiledView)) continue;

    try {
      const content = readFileSync(f.fullPath, "utf8");

      // Pass 1: Find literal icon references (e.g., heroicon-o-check)
      for (const match of content.matchAll(iconRefPattern)) {
        // match[0] = "heroicon-o-check", match[1] = "o-check"
        // SVG filename is the part after the prefix: "o-check.svg"
        usedIcons.add(match[1] + ".svg");
      }

      // Pass 2: Find dynamic enum references (e.g., Heroicon::Eye)
      // These are resolved at runtime by getIconForSize() to heroicon-{size}-{value}
      if (isPhpFile && caseMap.size > 0 && iconSet.enumRefPattern) {
        for (const m of content.matchAll(iconSet.enumRefPattern)) {
          const value = caseMap.get(m[1]);
          if (value) referencedValues.add(value);
        }
      }
    } catch {}
  }

  // Process referenced enum values into SVG filenames
  // For each referenced enum value, generate all size variant SVG filenames
  let enumIconsAdded = 0;
  for (const value of referencedValues) {
    if (value.startsWith("o-")) {
      // Outlined variants use the value directly
      usedIcons.add(value + ".svg");
      enumIconsAdded++;
    } else {
      // Non-outlined: generate all size variants (m-, s-, c-)
      for (const sizePrefix of ["m-", "s-", "c-"]) {
        usedIcons.add(sizePrefix + value + ".svg");
      }
      enumIconsAdded += 3;
    }
  }

  if (enumIconsAdded > 0) {
    console.log(
      `  Found ${referencedValues.size} Heroicon enum references → ${enumIconsAdded} SVG variants preserved`,
    );
  }

  if (usedIcons.size === 0) {
    // Could not detect any used icons — keep all to be safe
    console.log(
      `  ⚠ No ${iconSet.prefix}* references detected, keeping all ${svgFiles.length} SVGs`,
    );
    continue;
  }

  const iconsBefore = svgFiles.length;
  let iconsRemoved = 0;
  for (let i = allFiles.length - 1; i >= 0; i--) {
    const f = allFiles[i];
    if (f.isDir || !f.path.startsWith(svgPrefix) || !f.path.endsWith(".svg")) continue;
    const filename = f.path.substring(svgPrefix.length);
    if (!usedIcons.has(filename)) {
      allFiles.splice(i, 1);
      iconsRemoved++;
    }
  }

  if (iconsRemoved > 0) {
    console.log(
      `  Stripped ${iconsRemoved}/${iconsBefore} unused ${iconSet.prefix}* SVGs (kept ${usedIcons.size} used icons)`,
    );
  }
}

// Verify no dev packages in the final bundle
// These are packages that should ONLY be in require-dev, not transitive deps
const DEV_PACKAGE_PATTERNS = [
  /vendor\/fakerphp\/faker/,
  /vendor\/phpunit\/phpunit/,
  /vendor\/pestphp\/pest/,
  /vendor\/mockery\/mockery/,
  /vendor\/laravel\/sail/,
  /vendor\/laravel\/pint/,
  /vendor\/laravel\/dusk/,
  /vendor\/spatie\/laravel-ignition/,
];

const devPackagesFound = [];
for (const file of allFiles) {
  for (const pattern of DEV_PACKAGE_PATTERNS) {
    if (pattern.test(file.path)) {
      devPackagesFound.push(file.path);
      break;
    }
  }
}

if (devPackagesFound.length > 0) {
  console.error("  ERROR: Dev packages found in bundle:");
  for (const pkg of devPackagesFound.slice(0, 10)) {
    console.error(`    - ${pkg}`);
  }
  if (devPackagesFound.length > 10) {
    console.error(`    ... and ${devPackagesFound.length - 10} more`);
  }
  process.exit(1);
} else {
  console.log("  ✓ No dev packages found in bundle");
}

// Override Composer platform check — php-cgi-wasm currently provides PHP 8.3.11
// but Laravel 12 requires >= 8.4.0. Remove this override once a custom PHP 8.4+
// WASM binary is built (see php-wasm-build/.php-wasm-rc).
const platformCheckPath = "vendor/composer/platform_check.php";
const idx = allFiles.findIndex((f) => f.path === platformCheckPath);
if (idx >= 0) {
  const tmpFile = join(DIST_DIR, "__platform_check_noop.php");
  mkdirSync(DIST_DIR, { recursive: true });
  writeFileSync(tmpFile, "<?php\n// Platform check disabled for WASM runtime\n");
  allFiles[idx] = { path: platformCheckPath, isDir: false, fullPath: tmpFile };
  console.log("  Disabled Composer platform check");
}

// Generate PHP stubs for missing extensions
console.log("  Generating PHP stubs for extensions...");
const stubsContent = generatePhpStubs(EXTENSIONS);
const stubsFile = join(DIST_DIR, "__php_stubs.php");
mkdirSync(DIST_DIR, { recursive: true });
writeFileSync(stubsFile, stubsContent);
allFiles.push({ path: "php-stubs.php", isDir: false, fullPath: stubsFile });
console.log(`    iconv: ${EXTENSIONS.iconv ? "enabled (no stubs)" : "disabled (stubs added)"}`);
console.log(
  `    mbstring: ${EXTENSIONS.mbstring ? "enabled (no stubs)" : "disabled (stubs added)"}`,
);
console.log(`    openssl: ${EXTENSIONS.openssl ? "enabled (no stubs)" : "disabled (stubs added)"}`);

// Generate OPcache diagnostic PHP file
console.log("  Generating OPcache diagnostic endpoint...");
const opcacheStatusContent = `<?php
// Auto-generated OPcache diagnostic endpoint
// Access via /__opcache-status when OPCACHE_DEBUG=true
header('Content-Type: application/json');
$status = opcache_get_status(false);
if ($status === false) {
    echo json_encode(['error' => 'OPcache not available']);
    exit;
}
echo json_encode($status, JSON_PRETTY_PRINT);
`;
const opcacheStatusFile = join(DIST_DIR, "__opcache_status.php");
writeFileSync(opcacheStatusFile, opcacheStatusContent);
allFiles.push({ path: "public/__opcache-status.php", isDir: false, fullPath: opcacheStatusFile });
console.log("  ✓ OPcache diagnostic endpoint: /__opcache-status (requires OPCACHE_DEBUG=true)");

// Compute per-category stats before creating tar
let vendorFileCount = 0;
let appFileCount = 0;

for (const f of allFiles) {
  if (f.isDir) continue;
  if (f.path.startsWith("vendor/")) {
    vendorFileCount++;
  } else {
    appFileCount++;
  }
}

console.log(`  Collected ${allFiles.length} entries (${vendorFileCount + appFileCount} files)`);

// Strip PHP whitespace in parallel (with content-hash cache for incremental builds)
let strippedContents = new Map();
if (STRIP_WHITESPACE) {
  console.log(`  Stripping PHP whitespace and comments (${STRIP_CONCURRENCY} parallel workers)...`);
  strippedContents = await stripPhpFilesParallel(allFiles);
}

const { tar, strippedCount, bytesSaved, vendorBytes, appBytes } = createTar(allFiles, {
  stripWhitespace: STRIP_WHITESPACE,
  strippedContents,
});

if (STRIP_WHITESPACE && strippedCount > 0) {
  console.log(
    `  Stripped whitespace from ${strippedCount} PHP files (saved ${fmt(bytesSaved)} uncompressed)`,
  );
}

const gzipped = gzipSync(tar, { level: 6 });

mkdirSync(DIST_DIR, { recursive: true });
writeFileSync(OUTPUT, gzipped);

const totalCompressed = gzipped.length;
const totalUncompressed = tar.length;
const totalContentBytes = vendorBytes + appBytes;

// Estimate per-category compressed sizes using the overall compression ratio.
// Individual gzip streams wouldn't sum to total anyway (shared dictionary), so
// ratio-based estimates are equally meaningful and avoid 2 extra tar+gzip passes.
const compressionRatio = totalContentBytes > 0 ? totalCompressed / totalContentBytes : 1;
const vendorCompressedEst = Math.round(vendorBytes * compressionRatio);
const appCompressedEst = Math.round(appBytes * compressionRatio);

// PHP 8.5 WASM binary (gzipped). Measured from PHP 8.5.2 build: 3.27 MB gz.
// PHP WASM is loaded as a separate Cloudflare Workers binding (not bundled in script).
const WASM_ESTIMATE_BYTES = 3.4 * 1024 * 1024;
const totalWithWasm = totalCompressed + WASM_ESTIMATE_BYTES;
// App bundle budget: app.tar.gz should fit in Cloudflare Workers KV (25 MB limit).
// WASM is deployed as a separate Workers binding, not counted here.
const appFitsBudget = totalCompressed < 25 * 1024 * 1024;

// MEMFS budget check (uncompressed size is what goes into memory)
const MEMFS_BUDGET_MB = config.memfs_budget_mb ?? 30;
const memfsBudgetBytes = MEMFS_BUDGET_MB * 1024 * 1024;
const memfsFitsBudget = totalUncompressed <= memfsBudgetBytes;

console.log("");
console.log("  ┌──────────────────────────────────────────────────────────────────────┐");
console.log("  │                        Build Report                                 │");
console.log("  ├──────────────────────────┬──────────┬───────────────┬───────────────┤");
console.log("  │ Category                 │ Files    │ Uncompressed  │ ~Compressed   │");
console.log("  ├──────────────────────────┼──────────┼───────────────┼───────────────┤");
console.log(
  `  │ vendor/                  │ ${String(vendorFileCount).padStart(6)} │ ${fmt(vendorBytes).padStart(13)} │ ${("~" + fmt(vendorCompressedEst)).padStart(13)} │`,
);
console.log(
  `  │ app (non-vendor)         │ ${String(appFileCount).padStart(6)} │ ${fmt(appBytes).padStart(13)} │ ${("~" + fmt(appCompressedEst)).padStart(13)} │`,
);
console.log("  ├──────────────────────────┼──────────┼───────────────┼───────────────┤");
console.log(
  `  │ Total tar entries        │ ${String(allFiles.length).padStart(6)} │ ${fmt(totalUncompressed).padStart(13)} │ ${fmt(totalCompressed).padStart(13)} │`,
);
console.log(
  `  │ + WASM (~3.4 MB gz)      │          │               │ ${fmt(totalWithWasm).padStart(13)} │`,
);
console.log("  ├──────────────────────────┴──────────┴───────────────┴───────────────┤");
console.log(
  `  │ App bundle (< 25 MB): ${appFitsBudget ? "✅ FITS" : "❌ EXCEEDS"}${" ".repeat(42)}│`,
);
console.log(
  `  │ MEMFS budget (${MEMFS_BUDGET_MB} MB uncompressed): ${memfsFitsBudget ? "✅ FITS" : "⚠️  EXCEEDS"}${" ".repeat(27)}│`,
);
console.log("  └──────────────────────────────────────────────────────────────────────┘");

// Show prominent warning if MEMFS budget is exceeded
if (!memfsFitsBudget) {
  const excessMB = ((totalUncompressed - memfsBudgetBytes) / 1024 / 1024).toFixed(1);
  console.log("");
  console.log("  ⚠️  WARNING: MEMFS budget exceeded!");
  console.log(`     Uncompressed size: ${fmt(totalUncompressed)} (budget: ${MEMFS_BUDGET_MB} MB)`);
  console.log(`     Excess: ${excessMB} MB over budget`);
  console.log("");
  console.log("     This can cause 'Worker resource exceeded' errors at runtime.");
  console.log("     To reduce size:");
  console.log("       - Add exclude_patterns in config/laraworker.php");
  console.log("       - Enable strip_whitespace for production builds");
  console.log("       - Set show_top_dirs=true to see largest directories");
  console.log("");
}

console.log("");

// Show top 10 directories by uncompressed size for debugging
if (config.show_top_dirs ?? false) {
  const dirSizes = new Map();
  for (const f of allFiles) {
    if (f.isDir) continue;
    const parts = f.path.split("/");
    const dir = parts.length > 1 ? parts[0] + "/" : "(root)";
    const content = readFileSync(f.fullPath);
    dirSizes.set(dir, (dirSizes.get(dir) || 0) + content.length);
  }

  const sortedDirs = Array.from(dirSizes.entries())
    .sort((a, b) => b[1] - a[1])
    .slice(0, 10);

  if (sortedDirs.length > 0) {
    console.log("  Top 10 directories by uncompressed size:");
    for (const [dir, size] of sortedDirs) {
      console.log(`    ${dir.padEnd(25)} ${fmt(size).padStart(10)}`);
    }
    console.log("");
  }
}

// Copy Vite build assets if they exist
const viteBuildDir = join(ROOT, "public", "build");
if (existsSync(viteBuildDir)) {
  console.log("  Copying Vite build assets...");
  copyDirRecursive(viteBuildDir, join(DIST_DIR, "build"));
  console.log("  Done.");
}

// Copy public/ static files to Cloudflare Static Assets.
// These are served directly by CF edge without invoking the PHP WASM worker.
const PUBLIC_ASSETS = config.public_assets ?? true;
if (PUBLIC_ASSETS) {
  const publicDir = join(ROOT, "public");
  if (existsSync(publicDir)) {
    console.log("  Copying public static assets...");
    const copiedFiles = [];
    copyPublicFiles(publicDir, DIST_DIR, "", copiedFiles);
    if (copiedFiles.length > 0) {
      for (const f of copiedFiles) {
        console.log(`    + ${f}`);
      }
      console.log(`  ✓ ${copiedFiles.length} public static file(s) copied to Static Assets`);
    } else {
      console.log("  No public static files to copy.");
    }
  }
}

// Generate _headers file for Cloudflare Static Assets.
// This adds immutable cache headers to Vite build assets without worker invocation.
const headersContent = `/build/assets/*
  Cache-Control: public, max-age=31536000, immutable
`;
writeFileSync(join(DIST_DIR, "_headers"), headersContent);
console.log("  ✓ Generated _headers for immutable asset caching");

// Verify custom PHP 8.5 WASM binary and helper modules are present.
// These are copied into the build directory by the PHP BuildCommand
// (BuildDirectory::copyWasmBinary) before build-app.mjs runs.
console.log("  Verifying custom PHP 8.5 WASM binary...");

const requiredFiles = [
  "php-cgi.mjs",
  "php-cgi.wasm",
  "PhpCgiBase.mjs",
  "breakoutRequest.mjs",
  "parseResponse.mjs",
  "fsOps.mjs",
  "resolveDependencies.mjs",
];
for (const file of requiredFiles) {
  const filePath = join(import.meta.dirname, file);
  if (!existsSync(filePath)) {
    console.error(`  ERROR: ${file} not found in build directory`);
    console.error("  Ensure BuildDirectory::copyWasmBinary() ran successfully.");
    console.error("  To rebuild WASM: bash php-wasm-build/build.sh");
    process.exit(1);
  }
}

const wasmSize = statSync(join(import.meta.dirname, "php-cgi.wasm")).size;
console.log(`  ✓ php-cgi.wasm (${fmt(wasmSize)})`);
console.log(`  ✓ php-cgi.mjs + ${requiredFiles.length - 2} helper modules`);

console.log("Build complete.");

function copyDirRecursive(src, dest) {
  mkdirSync(dest, { recursive: true });
  const entries = readdirSync(src, { withFileTypes: true });
  for (const entry of entries) {
    const srcPath = join(src, entry.name);
    const destPath = join(dest, entry.name);
    if (entry.isDirectory()) {
      copyDirRecursive(srcPath, destPath);
    } else {
      copyFileSync(srcPath, destPath);
    }
  }
}

/**
 * Recursively copy public/ files to Static Assets, skipping index.php and build/.
 */
function copyPublicFiles(srcDir, destDir, relPrefix, copiedFiles) {
  const entries = readdirSync(srcDir, { withFileTypes: true });
  for (const entry of entries) {
    const relPath = relPrefix ? `${relPrefix}/${entry.name}` : entry.name;

    // Skip index.php (handled by PHP routing) and build/ (handled by Vite copy)
    if (relPrefix === "" && (entry.name === "index.php" || entry.name === "build")) {
      continue;
    }

    const srcPath = join(srcDir, entry.name);
    const destPath = join(destDir, relPath);

    if (entry.isDirectory()) {
      copyPublicFiles(srcPath, destDir, relPath, copiedFiles);
    } else if (entry.isFile()) {
      mkdirSync(join(destDir, relPrefix), { recursive: true });
      copyFileSync(srcPath, destPath);
      copiedFiles.push(relPath);
    }
  }
}
