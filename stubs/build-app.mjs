/**
 * Build script: packages Laravel application files into a .tar for Cloudflare Static Assets.
 *
 * Usage: node .laraworker/build-app.mjs
 *
 * Output: .laraworker/dist/assets/app.tar.gz
 *
 * Configuration is read from .laraworker/build-config.json (generated by laraworker:build).
 */

import { readdirSync, statSync, readFileSync, mkdirSync, writeFileSync, copyFileSync, existsSync, rmSync } from 'node:fs';
import { gzipSync } from 'node:zlib';
import { join, relative, resolve } from 'node:path';
import { execSync, execFile } from 'node:child_process';
import { promisify } from 'node:util';
import { createHash } from 'node:crypto';
import { cpus } from 'node:os';

const execFileAsync = promisify(execFile);

const ROOT = resolve(import.meta.dirname, '..');
const DIST_DIR = resolve(import.meta.dirname, 'dist', 'assets');
const OUTPUT = join(DIST_DIR, 'app.tar.gz');

// Read build config (generated by php artisan laraworker:build)
const configPath = join(import.meta.dirname, 'build-config.json');
let config = {};
if (existsSync(configPath)) {
  config = JSON.parse(readFileSync(configPath, 'utf8'));
}

const VENDOR_STAGING_DIR = config.vendor_staging_dir;

let INCLUDE_DIRS = config.include_dirs ?? [
  'app', 'bootstrap', 'config', 'database',
  'routes', 'resources/views', 'vendor',
];

// Use staging vendor if available (production-only, no-dev)
if (VENDOR_STAGING_DIR && existsSync(VENDOR_STAGING_DIR)) {
  console.log('  Using staging vendor (production-only, no-dev)...');
  // Filter out vendor from include_dirs - we'll add staging vendor separately
  INCLUDE_DIRS = INCLUDE_DIRS.filter(d => d !== 'vendor');
} else {
  console.warn('  Warning: No staging vendor found, using main vendor (may include dev packages)');
}

const INCLUDE_FILES = config.include_files ?? [
  'public/index.php', 'artisan', 'composer.json',
];

// Default exclude patterns — always applied. User config patterns merge with these.
const DEFAULT_EXCLUDE_PATTERNS = [
  // VCS & CI
  '/\\.git\\//',
  '/\\.github\\//',
  '/\\/node_modules\\//',
  '/\\/\\.DS_Store$/',

  // Vendor tests
  '/vendor\\/[^/]+\\/[^/]+\\/tests\\//',
  '/vendor\\/[^/]+\\/[^/]+\\/Tests\\//',
  '/vendor\\/[^/]+\\/[^/]+\\/test\\//',

  // Vendor docs & metadata
  '/vendor\\/[^/]+\\/[^/]+\\/docs\\//',
  '/vendor\\/[^/]+\\/[^/]+\\/[^/]+\\.md$/',
  '/vendor\\/[^/]+\\/[^/]+\\/CHANGELOG/',
  '/vendor\\/[^/]+\\/[^/]+\\/UPGRADE/',

  // LICENSE, README, CREDITS, NOTICE files (not needed at runtime)
  '/vendor\\/[^/]+\\/[^/]+\\/LICENSE/',
  '/vendor\\/[^/]+\\/[^/]+\\/CREDITS/',
  '/vendor\\/[^/]+\\/[^/]+\\/NOTICE/',
  '/vendor\\/[^/]+\\/[^/]+\\/README/',

  // Vendor tooling configs
  '/vendor\\/[^/]+\\/[^/]+\\/phpunit\\.xml/',
  '/vendor\\/[^/]+\\/[^/]+\\/\\.editorconfig$/',
  '/vendor\\/[^/]+\\/[^/]+\\/\\.gitattributes$/',
  '/vendor\\/[^/]+\\/[^/]+\\/\\.gitignore$/',
  '/vendor\\/[^/]+\\/[^/]+\\/phpstan/',
  '/vendor\\/[^/]+\\/[^/]+\\/psalm/',
  '/vendor\\/[^/]+\\/[^/]+\\/\\.php-cs-fixer/',
  '/vendor\\/[^/]+\\/[^/]+\\/\\.php_cs/',
  '/vendor\\/[^/]+\\/[^/]+\\/Makefile$/',
  '/vendor\\/[^/]+\\/[^/]+\\/\\.styleci\\.yml$/',
  '/vendor\\/[^/]+\\/[^/]+\\/docker-compose/',
  '/vendor\\/[^/]+\\/[^/]+\\/Dockerfile$/',
  '/vendor\\/[^/]+\\/[^/]+\\/rector\\.php$/',
  '/vendor\\/[^/]+\\/[^/]+\\/pint\\.json$/',

  // Vendor CLI scripts (not useful in Workers)
  '/vendor\\/bin\\//',
  '/vendor\\/[^/]+\\/[^/]+\\/bin\\//',

  // Schema and validation files (not needed at runtime)
  '/vendor\\/.*\\.xsd$/',
  '/vendor\\/.*\\.dtd$/',

  // Composer metadata (autoloader doesn't need installed.json at runtime)
  '/vendor\\/composer\\/installed\\.json$/',

  // Package manager lock files in vendor
  '/vendor\\/.*\\/package-lock\\.json$/',

  // Stub/template files (artisan make:* commands don't work in Workers)
  '/vendor\\/.*\\.stub$/',

  // Symfony translation/locale resources (large, unused in typical Workers apps)
  '/vendor\\/symfony\\/[^/]+\\/Resources\\/translations\\//',

  // Symfony Resources not needed at runtime
  '/vendor\\/symfony\\/[^/]+\\/Resources\\/schemas\\//',
  '/vendor\\/symfony\\/[^/]+\\/Resources\\/bin\\//',
  '/vendor\\/symfony\\/http-kernel\\/Resources\\/welcome/',

  // Laravel framework exception renderer build artifacts (APP_DEBUG=false in production)
  '/vendor\\/laravel\\/framework\\/src\\/Illuminate\\/Foundation\\/resources\\/exceptions\\/renderer\\/dist\\//',
  '/vendor\\/laravel\\/framework\\/src\\/Illuminate\\/Foundation\\/resources\\/exceptions\\/renderer\\/package/',
  '/vendor\\/laravel\\/framework\\/src\\/Illuminate\\/Foundation\\/resources\\/exceptions\\/renderer\\/vite/',

  // Laravel framework testing utilities (not needed at runtime)
  '/vendor\\/laravel\\/framework\\/src\\/Illuminate\\/Testing\\//',

  // Laravel framework fixtures & stubs (dev-only)
  '/vendor\\/laravel\\/framework\\/src\\/Illuminate\\/Foundation\\/Console\\/stubs\\//',

  // Misc dev files in vendor
  '/vendor\\/[^/]+\\/[^/]+\\/\\.github\\//',
  '/vendor\\/[^/]+\\/[^/]+\\/\\.travis\\.yml$/',
  '/vendor\\/[^/]+\\/[^/]+\\/appveyor\\.yml$/',
  '/vendor\\/[^/]+\\/[^/]+\\/CONTRIBUTING/',
  '/vendor\\/[^/]+\\/[^/]+\\/SECURITY\\.md$/',
];

const toRegExp = p => new RegExp(p.replace(/^\//, '').replace(/\/$/, ''));
const defaultPatterns = DEFAULT_EXCLUDE_PATTERNS.map(toRegExp);
const userPatterns = (config.exclude_patterns ?? []).map(toRegExp);
const EXCLUDE_PATTERNS = [...defaultPatterns, ...userPatterns];

const EXTENSIONS = config.extensions ?? { mbstring: true, openssl: true };
// Default to false for initial build to avoid timeout - user can enable in build-config.json
const STRIP_WHITESPACE = config.strip_whitespace ?? false;
const STRIP_PROVIDERS = config.strip_providers ?? [];

/**
 * Generate PHP stub functions for missing extensions.
 * These stubs provide minimal implementations when extensions are not enabled.
 */
function generatePhpStubs(extensions) {
  const stubs = [];

  // umask fix for MEMFS - always needed
  stubs.push(`
// Fix for MEMFS umask issue
if (!function_exists('umask')) {
    function umask($mask = null) {
        return 0022;
    }
}`);

  // iconv stubs - only if iconv extension is not enabled
  if (!extensions.iconv) {
    stubs.push(`
// iconv stub functions
if (!function_exists('iconv')) {
    function iconv($from_encoding, $to_encoding, $string) {
        return $string;
    }
}
if (!function_exists('iconv_strlen')) {
    function iconv_strlen($string, $encoding = null) {
        return strlen($string);
    }
}
if (!function_exists('iconv_substr')) {
    function iconv_substr($string, $offset, $length = null, $encoding = null) {
        return substr($string, $offset, $length);
    }
}
if (!function_exists('iconv_strpos')) {
    function iconv_strpos($haystack, $needle, $offset = 0, $encoding = null) {
        return strpos($haystack, $needle, $offset);
    }
}`);
  }

  // mbstring stubs - only if mbstring extension is not enabled
  if (!extensions.mbstring) {
    stubs.push(`
// mbstring stub functions
if (!function_exists('mb_split')) {
    function mb_split($pattern, $string, $limit = -1) {
        return preg_split('/' . $pattern . '/', $string, $limit);
    }
}
if (!function_exists('mb_strlen')) {
    function mb_strlen($string, $encoding = null) {
        return strlen($string);
    }
}
if (!function_exists('mb_substr')) {
    function mb_substr($string, $start, $length = null, $encoding = null) {
        return substr($string, $start, $length);
    }
}
if (!function_exists('mb_strpos')) {
    function mb_strpos($haystack, $needle, $offset = 0, $encoding = null) {
        return strpos($haystack, $needle, $offset);
    }
}`);
  }

  // openssl stubs - only if openssl extension is not enabled
  if (!extensions.openssl) {
    stubs.push(`
// openssl stub functions (NOT SECURE - for development only)
if (!function_exists('openssl_encrypt')) {
    function openssl_encrypt($data, $cipher_algo, $passphrase, $options = 0, $iv = '', &$tag = null, $aad = '', $tag_length = 16) {
        // Simple XOR encryption - NOT secure, only for testing
        $key = substr($passphrase, 0, 32);
        $result = '';
        for ($i = 0; $i < strlen($data); $i++) {
            $result .= $data[$i] ^ $key[$i % strlen($key)];
        }
        return base64_encode($result);
    }
}
if (!function_exists('openssl_decrypt')) {
    function openssl_decrypt($data, $cipher_algo, $passphrase, $options = 0, $iv = '', $tag = null, $aad = '') {
        // Simple XOR decryption - NOT secure, only for testing
        $key = substr($passphrase, 0, 32);
        $decoded = base64_decode($data);
        $result = '';
        for ($i = 0; $i < strlen($decoded); $i++) {
            $result .= $decoded[$i] ^ $key[$i % strlen($key)];
        }
        return $result;
    }
}
if (!function_exists('openssl_random_pseudo_bytes')) {
    function openssl_random_pseudo_bytes($length, &$strong_result = null) {
        $strong_result = false;
        return random_bytes($length);
    }
}
if (!function_exists('openssl_cipher_iv_length')) {
    function openssl_cipher_iv_length($cipher_algo) {
        return 16;
    }
}`);
  }

  // Include class preloader if it exists (generated by laraworker:build)
  stubs.push(`
// Class preloader — eliminates per-class autoloader lookups in WASM
if (file_exists('/app/bootstrap/preload.php')) {
    require_once '/app/bootstrap/preload.php';
}`);

  return '<?php\n// Auto-generated PHP stubs for missing extensions\n// Extensions enabled: ' + JSON.stringify(extensions) + '\n' + stubs.join('\n');
}

// Cache directory for stripped PHP files — persists between builds
const STRIP_CACHE_DIR = join(import.meta.dirname, '.strip-cache');
// Number of parallel php -w workers
const STRIP_CONCURRENCY = Math.max(4, cpus().length);

/**
 * Run async tasks with a bounded concurrency pool.
 */
async function mapConcurrent(items, fn, concurrency) {
  const results = new Array(items.length);
  let index = 0;
  async function worker() {
    while (index < items.length) {
      const i = index++;
      results[i] = await fn(items[i], i);
    }
  }
  await Promise.all(Array.from({ length: concurrency }, worker));
  return results;
}

/**
 * Strip whitespace from a single PHP file asynchronously.
 * Uses a content-hash cache to skip unchanged files.
 * Returns stripped Buffer or null on failure.
 */
async function stripPhpFileAsync(filePath, originalContent) {
  const hash = createHash('sha256').update(originalContent).digest('hex');
  const cachePath = join(STRIP_CACHE_DIR, hash);

  // Cache hit — return without spawning a PHP process
  if (existsSync(cachePath)) {
    return { content: readFileSync(cachePath), fromCache: true };
  }

  try {
    const { stdout } = await execFileAsync('php', ['-w', filePath], {
      encoding: 'buffer',
      timeout: 30_000,
      maxBuffer: 10 * 1024 * 1024,
    });

    if (stdout && stdout.length > 0) {
      mkdirSync(STRIP_CACHE_DIR, { recursive: true });
      writeFileSync(cachePath, stdout);
      return { content: stdout, fromCache: false };
    }
  } catch {
    // php -w failed — skip this file
  }

  return null;
}

/**
 * Pre-process all PHP files in parallel.
 * Returns a Map of fullPath → stripped Buffer.
 */
async function stripPhpFilesParallel(files) {
  const phpFiles = files.filter(
    f => !f.isDir && f.path.endsWith('.php') && !f.path.startsWith('php-stubs'),
  );

  const startTime = Date.now();
  let cacheHits = 0;
  const strippedMap = new Map();

  await mapConcurrent(phpFiles, async (file) => {
    const original = readFileSync(file.fullPath);
    const result = await stripPhpFileAsync(file.fullPath, original);

    if (result) {
      const saved = original.length - result.content.length;
      if (saved > 0) {
        strippedMap.set(file.fullPath, result.content);
        if (result.fromCache) {
          cacheHits++;
        }
      }
    }
  }, STRIP_CONCURRENCY);

  const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
  console.log(`    Done in ${elapsed}s (${cacheHits}/${phpFiles.length} cache hits, ${strippedMap.size} files reduced)`);

  return strippedMap;
}

/**
 * Collect all files from a directory recursively.
 */
function collectFiles(dir, basePath = '') {
  const results = [];
  const entries = readdirSync(dir, { withFileTypes: true });

  for (const entry of entries) {
    const fullPath = join(dir, entry.name);
    const relPath = basePath ? `${basePath}/${entry.name}` : entry.name;

    const testPath = '/' + relPath;
    if (EXCLUDE_PATTERNS.some(p => p.test(testPath))) {
      continue;
    }

    if (entry.isDirectory()) {
      results.push({ path: relPath + '/', isDir: true });
      results.push(...collectFiles(fullPath, relPath));
    } else if (entry.isFile()) {
      results.push({ path: relPath, isDir: false, fullPath });
    }
  }

  return results;
}

/**
 * Create a 512-byte tar header for a file or directory.
 */
function createTarHeader(path, size, isDir) {
  const header = new Uint8Array(512);
  const encoder = new TextEncoder();

  let name = path;
  let ustarPrefix = '';

  if (name.length > 100) {
    const splitAt = name.lastIndexOf('/', 155);
    if (splitAt > 0) {
      ustarPrefix = name.substring(0, splitAt);
      name = name.substring(splitAt + 1);
    }
  }

  header.set(encoder.encode(name.substring(0, 100)), 0);

  const mode = isDir ? '0000755' : '0000644';
  header.set(encoder.encode(mode + '\0'), 100);

  header.set(encoder.encode('0001000\0'), 108);
  header.set(encoder.encode('0001000\0'), 116);

  const sizeStr = size.toString(8).padStart(11, '0');
  header.set(encoder.encode(sizeStr + '\0'), 124);

  const mtime = Math.floor(Date.now() / 1000).toString(8).padStart(11, '0');
  header.set(encoder.encode(mtime + '\0'), 136);

  header.set(encoder.encode('        '), 148);

  header[156] = isDir ? 53 : 48;

  header.set(encoder.encode('ustar\0'), 257);
  header.set(encoder.encode('00'), 263);

  if (ustarPrefix) {
    header.set(encoder.encode(ustarPrefix.substring(0, 155)), 345);
  }

  let checksum = 0;
  for (let i = 0; i < 512; i++) {
    checksum += header[i];
  }
  const checksumStr = checksum.toString(8).padStart(6, '0') + '\0 ';
  header.set(encoder.encode(checksumStr), 148);

  return header;
}

/**
 * Create a tar archive from collected files.
 * When strippedContents is provided, pre-stripped PHP content is used directly.
 */
function createTar(files, { stripWhitespace = false, strippedContents = new Map() } = {}) {
  const chunks = [];
  let strippedCount = 0;
  let bytesSaved = 0;

  for (const file of files) {
    if (file.isDir) {
      chunks.push(createTarHeader(file.path, 0, true));
    } else {
      let content = readFileSync(file.fullPath);

      // Use pre-stripped content if available
      if (stripWhitespace && file.path.endsWith('.php') && !file.path.startsWith('php-stubs')) {
        const stripped = strippedContents.get(file.fullPath);
        if (stripped && stripped.length > 0) {
          const saved = content.length - stripped.length;
          if (saved > 0) {
            bytesSaved += saved;
            strippedCount++;
            content = stripped;
          }
        }
      }

      chunks.push(createTarHeader(file.path, content.length, false));
      chunks.push(new Uint8Array(content));

      const remainder = content.length % 512;
      if (remainder > 0) {
        chunks.push(new Uint8Array(512 - remainder));
      }
    }
  }

  chunks.push(new Uint8Array(1024));

  const totalSize = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
  const result = new Uint8Array(totalSize);
  let offset = 0;
  for (const chunk of chunks) {
    result.set(chunk, offset);
    offset += chunk.length;
  }

  return { tar: result, strippedCount, bytesSaved };
}

const fmt = (bytes) => {
  if (bytes >= 1024 * 1024) return (bytes / 1024 / 1024).toFixed(2) + ' MB';
  return (bytes / 1024).toFixed(0) + ' KB';
};

// --- Main ---

console.log('  Starting build-app.mjs...');
console.log(`  ROOT: ${ROOT}`);
console.log(`  DIST_DIR: ${DIST_DIR}`);

if (existsSync(DIST_DIR)) {
  console.log('  Cleaning dist directory...');
  rmSync(DIST_DIR, { recursive: true });
}

console.log('Building Laravel app tar...');

const allFiles = [];

for (const dir of INCLUDE_DIRS) {
  const fullDir = join(ROOT, dir);
  if (existsSync(fullDir)) {
    allFiles.push({ path: dir + '/', isDir: true });
    allFiles.push(...collectFiles(fullDir, dir));
  } else {
    console.warn(`  Warning: ${dir} not found, skipping`);
  }
}

for (const file of INCLUDE_FILES) {
  const fullPath = join(ROOT, file);
  if (existsSync(fullPath)) {
    const parts = file.split('/');
    if (parts.length > 1) {
      let dirPath = '';
      for (let i = 0; i < parts.length - 1; i++) {
        dirPath += (dirPath ? '/' : '') + parts[i];
        if (!allFiles.some(f => f.path === dirPath + '/')) {
          allFiles.push({ path: dirPath + '/', isDir: true });
        }
      }
    }
    allFiles.push({ path: file, isDir: false, fullPath });
  } else {
    console.warn(`  Warning: ${file} not found, skipping`);
  }
}

// Add staging vendor files if available
if (VENDOR_STAGING_DIR && existsSync(VENDOR_STAGING_DIR)) {
  allFiles.push({ path: 'vendor/', isDir: true });
  allFiles.push(...collectFiles(VENDOR_STAGING_DIR, 'vendor'));
}

// Copy .env.production as .env
const envSource = join(import.meta.dirname, '.env.production');
if (existsSync(envSource)) {
  allFiles.push({ path: '.env', isDir: false, fullPath: envSource });
} else {
  console.warn('  Warning: .laraworker/.env.production not found, no .env will be included');
}

// Add empty storage directory structure
const storageDirs = [
  'storage/',
  'storage/app/',
  'storage/framework/',
  'storage/framework/cache/',
  'storage/framework/cache/data/',
  'storage/framework/sessions/',
  'storage/framework/testing/',
  'storage/framework/views/',
  'storage/logs/',
];

for (const dir of storageDirs) {
  if (!allFiles.some(f => f.path === dir)) {
    allFiles.push({ path: dir, isDir: true });
  }
}

// Strip Carbon locale files (keep only en.php — no regional variants like en_AU, en_GB)
const carbonLangPrefix = 'vendor/nesbot/carbon/src/Carbon/Lang/';
const carbonRemoved = [];
for (let i = allFiles.length - 1; i >= 0; i--) {
  const f = allFiles[i];
  if (!f.path.startsWith(carbonLangPrefix) || f.isDir) continue;
  const filename = f.path.substring(carbonLangPrefix.length);
  if (filename !== 'en.php') {
    carbonRemoved.push(f.path);
    allFiles.splice(i, 1);
  }
}
if (carbonRemoved.length > 0) {
  console.log(`  Stripped ${carbonRemoved.length} Carbon locale files (kept en.php only)`);
}

// Verify no dev packages in the final bundle
// These are packages that should ONLY be in require-dev, not transitive deps
const DEV_PACKAGE_PATTERNS = [
  /vendor\/fakerphp\/faker/,
  /vendor\/phpunit\/phpunit/,
  /vendor\/pestphp\/pest/,
  /vendor\/mockery\/mockery/,
  /vendor\/laravel\/sail/,
  /vendor\/laravel\/pint/,
  /vendor\/laravel\/dusk/,
  /vendor\/spatie\/laravel-ignition/,
];

const devPackagesFound = [];
for (const file of allFiles) {
  for (const pattern of DEV_PACKAGE_PATTERNS) {
    if (pattern.test(file.path)) {
      devPackagesFound.push(file.path);
      break;
    }
  }
}

if (devPackagesFound.length > 0) {
  console.error('  ERROR: Dev packages found in bundle:');
  for (const pkg of devPackagesFound.slice(0, 10)) {
    console.error(`    - ${pkg}`);
  }
  if (devPackagesFound.length > 10) {
    console.error(`    ... and ${devPackagesFound.length - 10} more`);
  }
  process.exit(1);
} else {
  console.log('  ✓ No dev packages found in bundle');
}

// Override Composer platform check — php-cgi-wasm currently provides PHP 8.3.11
// but Laravel 12 requires >= 8.4.0. Remove this override once a custom PHP 8.4+
// WASM binary is built (see php-wasm-build/.php-wasm-rc).
const platformCheckPath = 'vendor/composer/platform_check.php';
const idx = allFiles.findIndex(f => f.path === platformCheckPath);
if (idx >= 0) {
  const tmpFile = join(DIST_DIR, '__platform_check_noop.php');
  mkdirSync(DIST_DIR, { recursive: true });
  writeFileSync(tmpFile, '<?php\n// Platform check disabled for WASM runtime\n');
  allFiles[idx] = { path: platformCheckPath, isDir: false, fullPath: tmpFile };
  console.log('  Disabled Composer platform check');
}

// Generate PHP stubs for missing extensions
console.log('  Generating PHP stubs for extensions...');
const stubsContent = generatePhpStubs(EXTENSIONS);
const stubsFile = join(DIST_DIR, '__php_stubs.php');
writeFileSync(stubsFile, stubsContent);
allFiles.push({ path: 'php-stubs.php', isDir: false, fullPath: stubsFile });
console.log(`    iconv: ${EXTENSIONS.iconv ? 'enabled (no stubs)' : 'disabled (stubs added)'}`);
console.log(`    mbstring: ${EXTENSIONS.mbstring ? 'enabled (no stubs)' : 'disabled (stubs added)'}`);
console.log(`    openssl: ${EXTENSIONS.openssl ? 'enabled (no stubs)' : 'disabled (stubs added)'}`);

// Compute per-category stats before creating tar
let vendorFileCount = 0;
let vendorUncompressedSize = 0;
let appFileCount = 0;
let appUncompressedSize = 0;

for (const f of allFiles) {
  if (f.isDir) continue;
  const size = statSync(f.fullPath).size;
  if (f.path.startsWith('vendor/')) {
    vendorFileCount++;
    vendorUncompressedSize += size;
  } else {
    appFileCount++;
    appUncompressedSize += size;
  }
}

console.log(`  Collected ${allFiles.length} entries (${vendorFileCount + appFileCount} files)`);

// Strip PHP whitespace in parallel (with content-hash cache for incremental builds)
let strippedContents = new Map();
if (STRIP_WHITESPACE) {
  console.log(`  Stripping PHP whitespace and comments (${STRIP_CONCURRENCY} parallel workers)...`);
  strippedContents = await stripPhpFilesParallel(allFiles);
}

const { tar, strippedCount, bytesSaved } = createTar(allFiles, { stripWhitespace: STRIP_WHITESPACE, strippedContents });

if (STRIP_WHITESPACE && strippedCount > 0) {
  console.log(`  Stripped whitespace from ${strippedCount} PHP files (saved ${fmt(bytesSaved)} uncompressed)`);
}

const gzipped = gzipSync(tar, { level: 9 });

mkdirSync(DIST_DIR, { recursive: true });
writeFileSync(OUTPUT, gzipped);

// Compute compressed sizes per category for report
const vendorOnlyFiles = allFiles.filter(f => !f.isDir && f.path.startsWith('vendor/'));
const appOnlyFiles = allFiles.filter(f => !f.isDir && !f.path.startsWith('vendor/'));
const { tar: vendorTar } = createTar(vendorOnlyFiles, { stripWhitespace: STRIP_WHITESPACE, strippedContents });
const vendorGz = gzipSync(vendorTar, { level: 9 });
const { tar: appTar } = createTar(appOnlyFiles, { stripWhitespace: STRIP_WHITESPACE, strippedContents });
const appGz = gzipSync(appTar, { level: 9 });

const totalCompressed = gzipped.length;
const WASM_ESTIMATE_BYTES = 2.6 * 1024 * 1024; // ~2.6 MB gzipped WASM
const totalWithWasm = totalCompressed + WASM_ESTIMATE_BYTES;
const fitsFreeTier = totalWithWasm < 3 * 1024 * 1024;

console.log('');
console.log('  ┌─────────────────────────────────────────────────┐');
console.log('  │              Build Report                       │');
console.log('  ├──────────────────────┬──────────┬───────────────┤');
console.log('  │ Category             │ Files    │ Compressed    │');
console.log('  ├──────────────────────┼──────────┼───────────────┤');
console.log(`  │ vendor/              │ ${String(vendorFileCount).padStart(6)} │ ${fmt(vendorGz.length).padStart(13)} │`);
console.log(`  │ app (non-vendor)     │ ${String(appFileCount).padStart(6)} │ ${fmt(appGz.length).padStart(13)} │`);
console.log('  ├──────────────────────┼──────────┼───────────────┤');
console.log(`  │ Total tar entries    │ ${String(allFiles.length).padStart(6)} │ ${fmt(totalCompressed).padStart(13)} │`);
console.log(`  │ + WASM (~2.6 MB gz)  │        │ ${fmt(totalWithWasm).padStart(13)} │`);
console.log('  ├──────────────────────┴──────────┴───────────────┤');
console.log(`  │ Free tier (< 3 MB total):  ${fitsFreeTier ? '✅ FITS' : '❌ EXCEEDS'}${' '.repeat(20)}│`);
console.log('  └─────────────────────────────────────────────────┘');
console.log('');

// Copy Vite build assets if they exist
const viteBuildDir = join(ROOT, 'public', 'build');
if (existsSync(viteBuildDir)) {
  console.log('  Copying Vite build assets...');
  copyDirRecursive(viteBuildDir, join(DIST_DIR, 'build'));
  console.log('  Done.');
}

// Patch the Emscripten PHP module for Cloudflare Workers compatibility.
console.log('  Patching PHP module for Workers compatibility...');
const phpModuleSrc = join(ROOT, 'node_modules', 'php-cgi-wasm', 'php-cgi-web.mjs');
const phpModuleDest = join(import.meta.dirname, 'php-cgi.mjs');
let phpModule = readFileSync(phpModuleSrc, 'utf8');

// Patch 1: Replace `new URL("...wasm", import.meta.url).href` with a try/catch fallback.
phpModule = phpModule.replace(
  /new URL\("([^"]+\.wasm)",\s*import\.meta\.url\)\.href/g,
  '(() => { try { return new URL("$1", import.meta.url).href; } catch { return "$1"; } })()'
);

// Patch 2: Intercept dynamic library loading to use pre-provided WebAssembly.Module objects.
phpModule = phpModule.replace(
  /var readAsync,readBinary;/,
  'var readAsync,readBinary;var __preloadedLibs=Module["_preloadedLibs"]||{};'
);
phpModule = phpModule.replace(
  'var libFile=locateFile(libName);if(flags.loadAsync)',
  'if(__preloadedLibs[libName]){var _m=__preloadedLibs[libName];return flags.loadAsync?Promise.resolve(_m):_m}var libFile=locateFile(libName);if(flags.loadAsync)'
);

// Patch 3: Add error recovery to loadDylibs.
phpModule = phpModule.replace(
  'dynamicLibraries.reduce((chain,lib)=>chain.then(()=>loadDynamicLibrary(lib,{loadAsync:true,global:true,nodelete:true,allowUndefined:true})),Promise.resolve()).then(()=>{reportUndefinedSymbols();removeRunDependency("loadDylibs")})',
  'dynamicLibraries.reduce((chain,lib)=>chain.then(()=>loadDynamicLibrary(lib,{loadAsync:true,global:true,nodelete:true,allowUndefined:true})),Promise.resolve()).then(()=>{reportUndefinedSymbols();removeRunDependency("loadDylibs")}).catch(e=>{console.error("loadDylibs error:",e);removeRunDependency("loadDylibs")})'
);

// Patch 4: Patch reportUndefinedSymbols to catch CompileError from addFunction.
phpModule = phpModule.replace(
  'entry.value=addFunction(value,value.sig)',
  'try{entry.value=addFunction(value,value.sig)}catch(_e){if(!(_e instanceof WebAssembly.CompileError))throw _e}'
);

writeFileSync(phpModuleDest, phpModule);
console.log(`  Patched ${phpModuleDest}`);

// Copy shared library .so files as .wasm so Cloudflare pre-compiles them.
// The set of files depends on which extensions are enabled.
const soFiles = [
  // libxml2 is always required (PHP core dependency)
  { src: join(ROOT, 'node_modules', 'php-cgi-wasm', 'libxml2.so'), dest: 'libxml2.wasm', always: true },
];

if (EXTENSIONS.mbstring) {
  soFiles.push(
    { src: join(ROOT, 'node_modules', 'php-wasm-mbstring', 'libonig.so'), dest: 'libonig.wasm' },
    { src: join(ROOT, 'node_modules', 'php-wasm-mbstring', 'php8.3-mbstring.so'), dest: 'php8.3-mbstring.wasm' },
  );
}

if (EXTENSIONS.openssl) {
  soFiles.push(
    { src: join(ROOT, 'node_modules', 'php-wasm-openssl', 'libcrypto.so'), dest: 'libcrypto.wasm' },
    { src: join(ROOT, 'node_modules', 'php-wasm-openssl', 'libssl.so'), dest: 'libssl.wasm' },
    { src: join(ROOT, 'node_modules', 'php-wasm-openssl', 'php8.3-openssl.so'), dest: 'php8.3-openssl.wasm' },
  );
}

for (const { src, dest } of soFiles) {
  const destPath = join(import.meta.dirname, dest);
  if (existsSync(src)) {
    copyFileSync(src, destPath);
    console.log(`  Copied ${src.split('/').pop()} → ${dest}`);
  } else {
    console.warn(`  Warning: ${src} not found`);
  }
}

// Optimize WASM files with wasm-opt (binaryen) for size reduction.
const wasmOptBin = join(ROOT, 'node_modules', '.bin', 'wasm-opt');
if (existsSync(wasmOptBin)) {
  console.log('Optimizing WASM files with wasm-opt...');
  const wasmFiles = readdirSync(import.meta.dirname).filter(f => f.endsWith('.wasm'));
  console.log(`  Found ${wasmFiles.length} WASM files to optimize`);

  for (const wasmFile of wasmFiles) {
    const wasmPath = join(import.meta.dirname, wasmFile);
    const sizeBefore = statSync(wasmPath).size;
    console.log(`  Optimizing ${wasmFile} (${(sizeBefore / 1024).toFixed(0)} KiB)...`);
    try {
      execSync(`${wasmOptBin} -Oz --strip-debug --all-features -o ${wasmPath} ${wasmPath}`, {
        stdio: 'pipe',
        timeout: 120_000,
      });
      const sizeAfter = statSync(wasmPath).size;
      const savedPct = ((1 - sizeAfter / sizeBefore) * 100).toFixed(1);
      console.log(`    ${wasmFile}: ${(sizeBefore / 1024).toFixed(0)} KiB → ${(sizeAfter / 1024).toFixed(0)} KiB (−${savedPct}%)`);
    } catch (err) {
      console.warn(`    Warning: wasm-opt failed for ${wasmFile}: ${err.message}`);
    }
  }
} else {
  console.log('  Skipping WASM optimization (binaryen not installed). Run: bun add -d binaryen');
}

console.log('Build complete.');

function copyDirRecursive(src, dest) {
  mkdirSync(dest, { recursive: true });
  const entries = readdirSync(src, { withFileTypes: true });
  for (const entry of entries) {
    const srcPath = join(src, entry.name);
    const destPath = join(dest, entry.name);
    if (entry.isDirectory()) {
      copyDirRecursive(srcPath, destPath);
    } else {
      copyFileSync(srcPath, destPath);
    }
  }
}
