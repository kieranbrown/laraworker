/**
 * Build script: packages Laravel application files into a .tar for Cloudflare Static Assets.
 *
 * Usage: node .laraworker/build-app.mjs
 *
 * Output: .laraworker/dist/assets/app.tar.gz
 *
 * Configuration is read from .laraworker/build-config.json (generated by laraworker:build).
 */

import { readdirSync, statSync, readFileSync, mkdirSync, writeFileSync, copyFileSync, existsSync, rmSync } from 'node:fs';
import { createHash } from 'node:crypto';
import { gzipSync } from 'node:zlib';
import { join, relative, resolve, dirname } from 'node:path';
import { execSync } from 'node:child_process';

const ROOT = resolve(import.meta.dirname, '..');
const DIST_DIR = resolve(import.meta.dirname, 'dist', 'assets');
const OUTPUT = join(DIST_DIR, 'app.tar.gz');

// Read build config (generated by php artisan laraworker:build)
const configPath = join(import.meta.dirname, 'build-config.json');
let config = {};
if (existsSync(configPath)) {
  config = JSON.parse(readFileSync(configPath, 'utf8'));
}

const INCLUDE_DIRS = config.include_dirs ?? [
  'app', 'bootstrap', 'config', 'database',
  'routes', 'resources/views', 'vendor',
];

const INCLUDE_FILES = config.include_files ?? [
  'public/index.php', 'artisan', 'composer.json',
];

// Default exclude patterns — always applied. User config patterns merge with these.
const DEFAULT_EXCLUDE_PATTERNS = [
  // VCS & CI
  '/\\.git\\//',
  '/\\.github\\//',
  '/\\/node_modules\\//',
  '/\\/\\.DS_Store$/',

  // Vendor tests
  '/vendor\\/[^/]+\\/[^/]+\\/tests\\//',
  '/vendor\\/[^/]+\\/[^/]+\\/Tests\\//',
  '/vendor\\/[^/]+\\/[^/]+\\/test\\//',

  // Vendor docs & metadata
  '/vendor\\/[^/]+\\/[^/]+\\/docs\\//',
  '/vendor\\/[^/]+\\/[^/]+\\/[^/]+\\.md$/',
  '/vendor\\/[^/]+\\/[^/]+\\/CHANGELOG/',
  '/vendor\\/[^/]+\\/[^/]+\\/UPGRADE/',

  // Vendor tooling configs
  '/vendor\\/[^/]+\\/[^/]+\\/phpunit\\.xml/',
  '/vendor\\/[^/]+\\/[^/]+\\/\\.editorconfig$/',
  '/vendor\\/[^/]+\\/[^/]+\\/\\.gitattributes$/',
  '/vendor\\/[^/]+\\/[^/]+\\/\\.gitignore$/',
  '/vendor\\/[^/]+\\/[^/]+\\/phpstan/',
  '/vendor\\/[^/]+\\/[^/]+\\/psalm/',
  '/vendor\\/[^/]+\\/[^/]+\\/\\.php-cs-fixer/',
  '/vendor\\/[^/]+\\/[^/]+\\/\\.php_cs/',
  '/vendor\\/[^/]+\\/[^/]+\\/Makefile$/',
  '/vendor\\/[^/]+\\/[^/]+\\/\\.styleci\\.yml$/',
  '/vendor\\/[^/]+\\/[^/]+\\/docker-compose/',
  '/vendor\\/[^/]+\\/[^/]+\\/Dockerfile$/',
  '/vendor\\/[^/]+\\/[^/]+\\/rector\\.php$/',

  // Vendor CLI scripts (not useful in Workers)
  '/vendor\\/bin\\//',
  '/vendor\\/[^/]+\\/[^/]+\\/bin\\//',

  // Symfony translation/locale resources (large, unused in typical Workers apps)
  '/vendor\\/symfony\\/[^/]+\\/Resources\\/translations\\//',

  // Laravel framework testing utilities (not needed at runtime)
  '/vendor\\/laravel\\/framework\\/src\\/Illuminate\\/Testing\\//',

  // Laravel framework fixtures & stubs (dev-only)
  '/vendor\\/laravel\\/framework\\/src\\/Illuminate\\/Foundation\\/Console\\/stubs\\//',

  // Misc dev files in vendor
  '/vendor\\/[^/]+\\/[^/]+\\/\\.github\\//',
  '/vendor\\/[^/]+\\/[^/]+\\/\\.travis\\.yml$/',
  '/vendor\\/[^/]+\\/[^/]+\\/appveyor\\.yml$/',
  '/vendor\\/[^/]+\\/[^/]+\\/CONTRIBUTING/',
  '/vendor\\/[^/]+\\/[^/]+\\/SECURITY\\.md$/',

  // Symfony Resources — schemas, CLI binaries, debug assets (not needed at runtime)
  // Note: polyfill Resources/unidata/*.php and Resources/stubs/*.php ARE needed
  '/vendor\\/symfony\\/[^/]+\\/Resources\\/schemas\\//',
  '/vendor\\/symfony\\/[^/]+\\/Resources\\/bin\\//',
  '/vendor\\/symfony\\/error-handler\\/Resources\\/assets\\//',
  '/vendor\\/symfony\\/http-kernel\\/Resources\\/welcome\\.html\\.php$/',
  '/vendor\\/symfony\\/console\\/Resources\\/bin\\//',

  // Doctrine fixtures & ORM test utilities
  '/vendor\\/fakerphp\\/faker\\/src\\/Faker\\/ORM\\//',
  '/vendor\\/doctrine\\/[^/]+\\/docs\\//',

  // LICENSE and README files in vendor (not needed at runtime)
  '/vendor\\/[^/]+\\/[^/]+\\/LICENSE/',
  '/vendor\\/[^/]+\\/[^/]+\\/README/',

  // Schema/validation files (.xsd, .dtd) — not needed at runtime
  '/vendor\\/.*\\.xsd$/',
  '/vendor\\/.*\\.dtd$/',

  // .txt files in vendor (changelogs, license dupes, etc.)
  '/vendor\\/[^/]+\\/[^/]+\\/[^/]+\\.txt$/',

  // Vendor metadata files (not needed at runtime)
  '/vendor\\/[^/]+\\/[^/]+\\/composer\\.lock$/',
  '/vendor\\/composer\\/installed\\.json$/',
  '/vendor\\/.*package-lock\\.json$/',

  // Laravel exception renderer dev resources (package.json, vite config, source files)
  '/vendor\\/laravel\\/framework\\/src\\/Illuminate\\/Foundation\\/resources\\/exceptions\\/renderer\\/package/',
  '/vendor\\/laravel\\/framework\\/src\\/Illuminate\\/Foundation\\/resources\\/exceptions\\/renderer\\/vite\\.config/',
  '/vendor\\/laravel\\/framework\\/src\\/Illuminate\\/Foundation\\/resources\\/exceptions\\/renderer\\/scripts\\.js$/',
  '/vendor\\/laravel\\/framework\\/src\\/Illuminate\\/Foundation\\/resources\\/exceptions\\/renderer\\/styles\\.css$/',

  // Dev packages — these should never be in production builds
  // Using --no-dev should exclude these, but block them explicitly as safety
  '/vendor\\/faker\\//',
  '/vendor\\/phpunit\\//',
  '/vendor\\/pestphp\\//',
  '/vendor\\/psy\\//',
  '/vendor\\/mockery\\//',
  '/vendor\\/phake\\//',
];

const toRegExp = p => new RegExp(p.replace(/^\//, '').replace(/\/$/, ''));
const defaultPatterns = DEFAULT_EXCLUDE_PATTERNS.map(toRegExp);
const userPatterns = (config.exclude_patterns ?? []).map(toRegExp);
const EXCLUDE_PATTERNS = [...defaultPatterns, ...userPatterns];

const EXTENSIONS = config.extensions ?? { mbstring: true, openssl: true };
// Default to false for initial build to avoid timeout - user can enable in build-config.json
const STRIP_WHITESPACE = config.strip_whitespace ?? false;
const STRIP_PROVIDERS = config.strip_providers ?? [];

/**
 * Generate PHP stub functions for missing extensions.
 * These stubs provide minimal implementations when extensions are not enabled.
 */
function generatePhpStubs(extensions) {
  const stubs = [];

  // umask fix for MEMFS - always needed
  stubs.push(`
// Fix for MEMFS umask issue
if (!function_exists('umask')) {
    function umask($mask = null) {
        return 0022;
    }
}`);

  // iconv stubs - only if iconv extension is not enabled
  if (!extensions.iconv) {
    stubs.push(`
// iconv stub functions
if (!function_exists('iconv')) {
    function iconv($from_encoding, $to_encoding, $string) {
        return $string;
    }
}
if (!function_exists('iconv_strlen')) {
    function iconv_strlen($string, $encoding = null) {
        return strlen($string);
    }
}
if (!function_exists('iconv_substr')) {
    function iconv_substr($string, $offset, $length = null, $encoding = null) {
        return substr($string, $offset, $length);
    }
}
if (!function_exists('iconv_strpos')) {
    function iconv_strpos($haystack, $needle, $offset = 0, $encoding = null) {
        return strpos($haystack, $needle, $offset);
    }
}`);
  }

  // mbstring stubs - only if mbstring extension is not enabled
  if (!extensions.mbstring) {
    stubs.push(`
// mbstring stub functions
if (!function_exists('mb_split')) {
    function mb_split($pattern, $string, $limit = -1) {
        return preg_split('/' . $pattern . '/', $string, $limit);
    }
}
if (!function_exists('mb_strlen')) {
    function mb_strlen($string, $encoding = null) {
        return strlen($string);
    }
}
if (!function_exists('mb_substr')) {
    function mb_substr($string, $start, $length = null, $encoding = null) {
        return substr($string, $start, $length);
    }
}
if (!function_exists('mb_strpos')) {
    function mb_strpos($haystack, $needle, $offset = 0, $encoding = null) {
        return strpos($haystack, $needle, $offset);
    }
}`);
  }

  // openssl stubs - only if openssl extension is not enabled
  if (!extensions.openssl) {
    stubs.push(`
// openssl stub functions (NOT SECURE - for development only)
if (!function_exists('openssl_encrypt')) {
    function openssl_encrypt($data, $cipher_algo, $passphrase, $options = 0, $iv = '', &$tag = null, $aad = '', $tag_length = 16) {
        // Simple XOR encryption - NOT secure, only for testing
        $key = substr($passphrase, 0, 32);
        $result = '';
        for ($i = 0; $i < strlen($data); $i++) {
            $result .= $data[$i] ^ $key[$i % strlen($key)];
        }
        return base64_encode($result);
    }
}
if (!function_exists('openssl_decrypt')) {
    function openssl_decrypt($data, $cipher_algo, $passphrase, $options = 0, $iv = '', $tag = null, $aad = '') {
        // Simple XOR decryption - NOT secure, only for testing
        $key = substr($passphrase, 0, 32);
        $decoded = base64_decode($data);
        $result = '';
        for ($i = 0; $i < strlen($decoded); $i++) {
            $result .= $decoded[$i] ^ $key[$i % strlen($key)];
        }
        return $result;
    }
}
if (!function_exists('openssl_random_pseudo_bytes')) {
    function openssl_random_pseudo_bytes($length, &$strong_result = null) {
        $strong_result = false;
        return random_bytes($length);
    }
}
if (!function_exists('openssl_cipher_iv_length')) {
    function openssl_cipher_iv_length($cipher_algo) {
        return 16;
    }
}`);
  }

  // Include class preloader if it exists (generated by laraworker:build)
  stubs.push(`
// Class preloader — eliminates per-class autoloader lookups in WASM
if (file_exists('/app/bootstrap/preload.php')) {
    require_once '/app/bootstrap/preload.php';
}`);

  return '<?php\n// Auto-generated PHP stubs for missing extensions\n// Extensions enabled: ' + JSON.stringify(extensions) + '\n' + stubs.join('\n');
}

/**
 * Strip whitespace and comments from a PHP file using `php -w`.
 * Returns the stripped content as a Buffer, or null on failure.
 */
function stripPhpFile(filePath) {
  try {
    return execSync(`php -w ${JSON.stringify(filePath)}`, {
      stdio: ['pipe', 'pipe', 'pipe'],
      timeout: 10_000,
      maxBuffer: 10 * 1024 * 1024,
    });
  } catch {
    return null;
  }
}

/**
 * Get cache key for a file based on content hash.
 */
function getCacheKey(filePath) {
  try {
    const content = readFileSync(filePath);
    return createHash('sha256').update(content).digest('hex');
  } catch {
    return null;
  }
}

/**
 * Strip whitespace from multiple PHP files in parallel with concurrency limit.
 * Uses a simple cache to avoid re-processing unchanged files.
 */
async function stripPhpFilesParallel(files, cacheDir, { concurrency = 8 } = {}) {
  const cacheFile = join(cacheDir, '.strip-whitespace-cache.json');
  let cache = {};

  // Load existing cache
  if (existsSync(cacheFile)) {
    try {
      cache = JSON.parse(readFileSync(cacheFile, 'utf8'));
    } catch {
      cache = {};
    }
  }

  const results = new Map();
  const toProcess = [];

  // Check cache for each file
  for (const file of files) {
    const cacheKey = getCacheKey(file.fullPath);
    if (cacheKey && cache[file.path] && cache[file.path].hash === cacheKey) {
      // Use cached result (stored as base64)
      results.set(file.path, Buffer.from(cache[file.path].content, 'base64'));
    } else {
      toProcess.push({ file, cacheKey });
    }
  }

  // Process files in parallel batches
  for (let i = 0; i < toProcess.length; i += concurrency) {
    const batch = toProcess.slice(i, i + concurrency);
    await Promise.all(batch.map(async ({ file, cacheKey }) => {
      const stripped = stripPhpFile(file.fullPath);
      if (stripped) {
        results.set(file.path, stripped);
        // Update cache
        if (cacheKey) {
          cache[file.path] = {
            hash: cacheKey,
            content: stripped.toString('base64'),
          };
        }
      }
    }));
  }

  // Save cache
  try {
    mkdirSync(cacheDir, { recursive: true });
    writeFileSync(cacheFile, JSON.stringify(cache, null, 2));
  } catch {
    // Ignore cache write errors
  }

  return results;
}

/**
 * Collect all files from a directory recursively.
 */
function collectFiles(dir, basePath = '') {
  const results = [];
  const entries = readdirSync(dir, { withFileTypes: true });

  for (const entry of entries) {
    const fullPath = join(dir, entry.name);
    const relPath = basePath ? `${basePath}/${entry.name}` : entry.name;

    const testPath = '/' + relPath;
    if (EXCLUDE_PATTERNS.some(p => p.test(testPath))) {
      continue;
    }

    if (entry.isDirectory()) {
      results.push({ path: relPath + '/', isDir: true });
      results.push(...collectFiles(fullPath, relPath));
    } else if (entry.isFile()) {
      results.push({ path: relPath, isDir: false, fullPath });
    }
  }

  return results;
}

/**
 * Create a 512-byte tar header for a file or directory.
 */
function createTarHeader(path, size, isDir) {
  const header = new Uint8Array(512);
  const encoder = new TextEncoder();

  let name = path;
  let ustarPrefix = '';

  if (name.length > 100) {
    const splitAt = name.lastIndexOf('/', 155);
    if (splitAt > 0) {
      ustarPrefix = name.substring(0, splitAt);
      name = name.substring(splitAt + 1);
    }
  }

  header.set(encoder.encode(name.substring(0, 100)), 0);

  const mode = isDir ? '0000755' : '0000644';
  header.set(encoder.encode(mode + '\0'), 100);

  header.set(encoder.encode('0001000\0'), 108);
  header.set(encoder.encode('0001000\0'), 116);

  const sizeStr = size.toString(8).padStart(11, '0');
  header.set(encoder.encode(sizeStr + '\0'), 124);

  const mtime = Math.floor(Date.now() / 1000).toString(8).padStart(11, '0');
  header.set(encoder.encode(mtime + '\0'), 136);

  header.set(encoder.encode('        '), 148);

  header[156] = isDir ? 53 : 48;

  header.set(encoder.encode('ustar\0'), 257);
  header.set(encoder.encode('00'), 263);

  if (ustarPrefix) {
    header.set(encoder.encode(ustarPrefix.substring(0, 155)), 345);
  }

  let checksum = 0;
  for (let i = 0; i < 512; i++) {
    checksum += header[i];
  }
  const checksumStr = checksum.toString(8).padStart(6, '0') + '\0 ';
  header.set(encoder.encode(checksumStr), 148);

  return header;
}

/**
 * Create a tar archive from collected files.
 * When stripWhitespace is true, PHP files are stripped of comments/whitespace.
 */
async function createTar(files, { stripWhitespace = false, cacheDir = null } = {}) {
  const chunks = [];
  let strippedCount = 0;
  let bytesSaved = 0;

  // Pre-process all PHP files in parallel if stripping is enabled
  let strippedContentMap = new Map();
  if (stripWhitespace) {
    const phpFiles = files.filter(f =>
      !f.isDir &&
      f.path.endsWith('.php') &&
      !f.path.startsWith('php-stubs')
    );

    if (phpFiles.length > 0) {
      strippedContentMap = await stripPhpFilesParallel(phpFiles, cacheDir || DIST_DIR);
    }
  }

  for (const file of files) {
    if (file.isDir) {
      chunks.push(createTarHeader(file.path, 0, true));
    } else {
      let content = readFileSync(file.fullPath);

      // Use pre-stripped content if available
      if (stripWhitespace && strippedContentMap.has(file.path)) {
        const stripped = strippedContentMap.get(file.path);
        const saved = content.length - stripped.length;
        if (saved > 0) {
          bytesSaved += saved;
          strippedCount++;
        }
        content = stripped;
      }

      chunks.push(createTarHeader(file.path, content.length, false));
      chunks.push(new Uint8Array(content));

      const remainder = content.length % 512;
      if (remainder > 0) {
        chunks.push(new Uint8Array(512 - remainder));
      }
    }
  }

  chunks.push(new Uint8Array(1024));

  const totalSize = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
  const result = new Uint8Array(totalSize);
  let offset = 0;
  for (const chunk of chunks) {
    result.set(chunk, offset);
    offset += chunk.length;
  }

  return { tar: result, strippedCount, bytesSaved };
}

const fmt = (bytes) => {
  if (bytes >= 1024 * 1024) return (bytes / 1024 / 1024).toFixed(2) + ' MB';
  return (bytes / 1024).toFixed(0) + ' KB';
};

// --- Main ---

(async () => {

console.log('  Starting build-app.mjs...');
console.log(`  ROOT: ${ROOT}`);
console.log(`  DIST_DIR: ${DIST_DIR}`);

if (existsSync(DIST_DIR)) {
  console.log('  Cleaning dist directory...');
  rmSync(DIST_DIR, { recursive: true });
}

console.log('Building Laravel app tar...');

const allFiles = [];

for (const dir of INCLUDE_DIRS) {
  const fullDir = join(ROOT, dir);
  if (existsSync(fullDir)) {
    allFiles.push({ path: dir + '/', isDir: true });
    allFiles.push(...collectFiles(fullDir, dir));
  } else {
    console.warn(`  Warning: ${dir} not found, skipping`);
  }
}

for (const file of INCLUDE_FILES) {
  const fullPath = join(ROOT, file);
  if (existsSync(fullPath)) {
    const parts = file.split('/');
    if (parts.length > 1) {
      let dirPath = '';
      for (let i = 0; i < parts.length - 1; i++) {
        dirPath += (dirPath ? '/' : '') + parts[i];
        if (!allFiles.some(f => f.path === dirPath + '/')) {
          allFiles.push({ path: dirPath + '/', isDir: true });
        }
      }
    }
    allFiles.push({ path: file, isDir: false, fullPath });
  } else {
    console.warn(`  Warning: ${file} not found, skipping`);
  }
}

// Copy .env.production as .env
const envSource = join(import.meta.dirname, '.env.production');
if (existsSync(envSource)) {
  allFiles.push({ path: '.env', isDir: false, fullPath: envSource });
} else {
  console.warn('  Warning: .laraworker/.env.production not found, no .env will be included');
}

// Add empty storage directory structure
const storageDirs = [
  'storage/',
  'storage/app/',
  'storage/framework/',
  'storage/framework/cache/',
  'storage/framework/cache/data/',
  'storage/framework/sessions/',
  'storage/framework/testing/',
  'storage/framework/views/',
  'storage/logs/',
];

for (const dir of storageDirs) {
  if (!allFiles.some(f => f.path === dir)) {
    allFiles.push({ path: dir, isDir: true });
  }
}

// Strip Carbon locale files (keep only en.php and en_US.php)
const carbonLangPrefix = 'vendor/nesbot/carbon/src/Carbon/Lang/';
const CARBON_KEEP = new Set(['en.php', 'en_US.php']);
const carbonRemoved = [];
for (let i = allFiles.length - 1; i >= 0; i--) {
  const f = allFiles[i];
  if (!f.path.startsWith(carbonLangPrefix) || f.isDir) continue;
  const filename = f.path.substring(carbonLangPrefix.length);
  if (!CARBON_KEEP.has(filename)) {
    carbonRemoved.push(f.path);
    allFiles.splice(i, 1);
  }
}
if (carbonRemoved.length > 0) {
  console.log(`  Stripped ${carbonRemoved.length} Carbon locale files (kept en + en_US only)`);
}

// Run composer dump-autoload --optimize if composer.json exists
const composerJson = join(ROOT, 'composer.json');
if (existsSync(composerJson)) {
  try {
    console.log('  Optimizing Composer autoloader...');
    // --classmap-authoritative skips filesystem checks for classes not in classmap
    // Critical for WASM where filesystem operations are expensive
    execSync('composer dump-autoload --no-dev --optimize --classmap-authoritative --no-scripts', {
      cwd: ROOT,
      stdio: 'inherit',
      timeout: 60_000,
      env: { ...process.env, COMPOSER_NO_INTERACTION: '1' },
    });
    console.log('  Composer autoloader optimized (no-dev, classmap-authoritative)');
  } catch (err) {
    console.warn(`  Warning: composer dump-autoload failed: ${err.message}`);
  }
}

// Override Composer platform check — php-cgi-wasm provides PHP 8.3.11 but
// Laravel 12 requires >= 8.4.0.
const platformCheckPath = 'vendor/composer/platform_check.php';
const idx = allFiles.findIndex(f => f.path === platformCheckPath);
if (idx >= 0) {
  const tmpFile = join(DIST_DIR, '__platform_check_noop.php');
  mkdirSync(DIST_DIR, { recursive: true });
  writeFileSync(tmpFile, '<?php\n// Platform check disabled for WASM runtime\n');
  allFiles[idx] = { path: platformCheckPath, isDir: false, fullPath: tmpFile };
  console.log('  Disabled Composer platform check');
}

// Generate PHP stubs for missing extensions
console.log('  Generating PHP stubs for extensions...');
const stubsContent = generatePhpStubs(EXTENSIONS);
const stubsFile = join(DIST_DIR, '__php_stubs.php');
writeFileSync(stubsFile, stubsContent);
allFiles.push({ path: 'php-stubs.php', isDir: false, fullPath: stubsFile });
console.log(`    iconv: ${EXTENSIONS.iconv ? 'enabled (no stubs)' : 'disabled (stubs added)'}`);
console.log(`    mbstring: ${EXTENSIONS.mbstring ? 'enabled (no stubs)' : 'disabled (stubs added)'}`);
console.log(`    openssl: ${EXTENSIONS.openssl ? 'enabled (no stubs)' : 'disabled (stubs added)'}`);

// Compute per-category stats before creating tar
let vendorFileCount = 0;
let vendorUncompressedSize = 0;
let appFileCount = 0;
let appUncompressedSize = 0;

for (const f of allFiles) {
  if (f.isDir) continue;
  const size = statSync(f.fullPath).size;
  if (f.path.startsWith('vendor/')) {
    vendorFileCount++;
    vendorUncompressedSize += size;
  } else {
    appFileCount++;
    appUncompressedSize += size;
  }
}

console.log(`  Collected ${allFiles.length} entries (${vendorFileCount + appFileCount} files)`);

if (STRIP_WHITESPACE) {
  console.log('  Stripping PHP whitespace and comments...');
}

const { tar, strippedCount, bytesSaved } = await createTar(allFiles, { stripWhitespace: STRIP_WHITESPACE, cacheDir: DIST_DIR });

if (STRIP_WHITESPACE && strippedCount > 0) {
  console.log(`  Stripped whitespace from ${strippedCount} PHP files (saved ${fmt(bytesSaved)} uncompressed)`);
}

const gzipped = gzipSync(tar, { level: 9 });

mkdirSync(DIST_DIR, { recursive: true });
writeFileSync(OUTPUT, gzipped);

// Compute compressed sizes per category for report
const vendorOnlyFiles = allFiles.filter(f => !f.isDir && f.path.startsWith('vendor/'));
const appOnlyFiles = allFiles.filter(f => !f.isDir && !f.path.startsWith('vendor/'));
const { tar: vendorTar } = await createTar(vendorOnlyFiles, { stripWhitespace: STRIP_WHITESPACE });
const vendorGz = gzipSync(vendorTar, { level: 9 });
const { tar: appTar } = await createTar(appOnlyFiles, { stripWhitespace: STRIP_WHITESPACE });
const appGz = gzipSync(appTar, { level: 9 });

const totalCompressed = gzipped.length;
// PHP 8.5 WASM binary (gzipped). Measured from PHP 8.5.2 build: 3.27 MB gz.
// PHP WASM is loaded as a separate Cloudflare Workers binding (not bundled in script).
const WASM_ESTIMATE_BYTES = 3.4 * 1024 * 1024;
const totalWithWasm = totalCompressed + WASM_ESTIMATE_BYTES;
// App bundle budget: app.tar.gz should fit in Cloudflare Workers KV (25 MB limit).
// WASM is deployed as a separate Workers binding, not counted here.
const appFitsBudget = totalCompressed < 25 * 1024 * 1024;

console.log('');
console.log('  ┌─────────────────────────────────────────────────┐');
console.log('  │              Build Report                       │');
console.log('  ├──────────────────────┬──────────┬───────────────┤');
console.log('  │ Category             │ Files    │ Compressed    │');
console.log('  ├──────────────────────┼──────────┼───────────────┤');
console.log(`  │ vendor/              │ ${String(vendorFileCount).padStart(6)} │ ${fmt(vendorGz.length).padStart(13)} │`);
console.log(`  │ app (non-vendor)     │ ${String(appFileCount).padStart(6)} │ ${fmt(appGz.length).padStart(13)} │`);
console.log('  ├──────────────────────┼──────────┼───────────────┤');
console.log(`  │ Total tar entries    │ ${String(allFiles.length).padStart(6)} │ ${fmt(totalCompressed).padStart(13)} │`);
console.log(`  │ + WASM (~3.4 MB gz)  │        │ ${fmt(totalWithWasm).padStart(13)} │`);
console.log('  ├──────────────────────┴──────────┴───────────────┤');
console.log(`  │ App bundle (< 25 MB): ${appFitsBudget ? '✅ FITS' : '❌ EXCEEDS'}${' '.repeat(24)}│`);
console.log('  └─────────────────────────────────────────────────┘');
console.log('');

// Copy Vite build assets if they exist
const viteBuildDir = join(ROOT, 'public', 'build');
if (existsSync(viteBuildDir)) {
  console.log('  Copying Vite build assets...');
  copyDirRecursive(viteBuildDir, join(DIST_DIR, 'build'));
  console.log('  Done.');
}

// Patch the Emscripten PHP module for Cloudflare Workers compatibility.
console.log('  Patching PHP module for Workers compatibility...');
const phpModuleSrc = join(ROOT, 'node_modules', 'php-cgi-wasm', 'php-cgi-web.mjs');
const phpModuleDest = join(import.meta.dirname, 'php-cgi.mjs');
let phpModule = readFileSync(phpModuleSrc, 'utf8');

// Patch 1: Replace `new URL("...wasm", import.meta.url).href` with a try/catch fallback.
phpModule = phpModule.replace(
  /new URL\("([^"]+\.wasm)",\s*import\.meta\.url\)\.href/g,
  '(() => { try { return new URL("$1", import.meta.url).href; } catch { return "$1"; } })()'
);

// Patch 2: Intercept dynamic library loading to use pre-provided WebAssembly.Module objects.
phpModule = phpModule.replace(
  /var readAsync,readBinary;/,
  'var readAsync,readBinary;var __preloadedLibs=Module["_preloadedLibs"]||{};'
);
phpModule = phpModule.replace(
  'var libFile=locateFile(libName);if(flags.loadAsync)',
  'if(__preloadedLibs[libName]){var _m=__preloadedLibs[libName];return flags.loadAsync?Promise.resolve(_m):_m}var libFile=locateFile(libName);if(flags.loadAsync)'
);

// Patch 3: Add error recovery to loadDylibs.
phpModule = phpModule.replace(
  'dynamicLibraries.reduce((chain,lib)=>chain.then(()=>loadDynamicLibrary(lib,{loadAsync:true,global:true,nodelete:true,allowUndefined:true})),Promise.resolve()).then(()=>{reportUndefinedSymbols();removeRunDependency("loadDylibs")})',
  'dynamicLibraries.reduce((chain,lib)=>chain.then(()=>loadDynamicLibrary(lib,{loadAsync:true,global:true,nodelete:true,allowUndefined:true})),Promise.resolve()).then(()=>{reportUndefinedSymbols();removeRunDependency("loadDylibs")}).catch(e=>{console.error("loadDylibs error:",e);removeRunDependency("loadDylibs")})'
);

// Patch 4: Patch reportUndefinedSymbols to catch CompileError from addFunction.
phpModule = phpModule.replace(
  'entry.value=addFunction(value,value.sig)',
  'try{entry.value=addFunction(value,value.sig)}catch(_e){if(!(_e instanceof WebAssembly.CompileError))throw _e}'
);

writeFileSync(phpModuleDest, phpModule);
console.log(`  Patched ${phpModuleDest}`);

// Copy shared library .so files as .wasm so Cloudflare pre-compiles them.
// The set of files depends on which extensions are enabled.
const soFiles = [
  // libxml2 is always required (PHP core dependency)
  { src: join(ROOT, 'node_modules', 'php-cgi-wasm', 'libxml2.so'), dest: 'libxml2.wasm', always: true },
];

if (EXTENSIONS.mbstring) {
  soFiles.push(
    { src: join(ROOT, 'node_modules', 'php-wasm-mbstring', 'libonig.so'), dest: 'libonig.wasm' },
    { src: join(ROOT, 'node_modules', 'php-wasm-mbstring', 'php8.3-mbstring.so'), dest: 'php8.3-mbstring.wasm' },
  );
}

if (EXTENSIONS.openssl) {
  soFiles.push(
    { src: join(ROOT, 'node_modules', 'php-wasm-openssl', 'libcrypto.so'), dest: 'libcrypto.wasm' },
    { src: join(ROOT, 'node_modules', 'php-wasm-openssl', 'libssl.so'), dest: 'libssl.wasm' },
    { src: join(ROOT, 'node_modules', 'php-wasm-openssl', 'php8.3-openssl.so'), dest: 'php8.3-openssl.wasm' },
  );
}

for (const { src, dest } of soFiles) {
  const destPath = join(import.meta.dirname, dest);
  if (existsSync(src)) {
    copyFileSync(src, destPath);
    console.log(`  Copied ${src.split('/').pop()} → ${dest}`);
  } else {
    console.warn(`  Warning: ${src} not found`);
  }
}

// Optimize WASM files with wasm-opt (binaryen) for size reduction.
const wasmOptBin = join(ROOT, 'node_modules', '.bin', 'wasm-opt');
if (existsSync(wasmOptBin)) {
  console.log('Optimizing WASM files with wasm-opt...');
  const wasmFiles = readdirSync(import.meta.dirname).filter(f => f.endsWith('.wasm'));
  console.log(`  Found ${wasmFiles.length} WASM files to optimize`);

  for (const wasmFile of wasmFiles) {
    const wasmPath = join(import.meta.dirname, wasmFile);
    const sizeBefore = statSync(wasmPath).size;
    console.log(`  Optimizing ${wasmFile} (${(sizeBefore / 1024).toFixed(0)} KiB)...`);
    try {
      execSync(`${wasmOptBin} -Oz --strip-debug --all-features -o ${wasmPath} ${wasmPath}`, {
        stdio: 'pipe',
        timeout: 120_000,
      });
      const sizeAfter = statSync(wasmPath).size;
      const savedPct = ((1 - sizeAfter / sizeBefore) * 100).toFixed(1);
      console.log(`    ${wasmFile}: ${(sizeBefore / 1024).toFixed(0)} KiB → ${(sizeAfter / 1024).toFixed(0)} KiB (−${savedPct}%)`);
    } catch (err) {
      console.warn(`    Warning: wasm-opt failed for ${wasmFile}: ${err.message}`);
    }
  }
} else {
  console.log('  Skipping WASM optimization (binaryen not installed). Run: bun add -d binaryen');
}

console.log('Build complete.');

})(); // End async IIFE

function copyDirRecursive(src, dest) {
  mkdirSync(dest, { recursive: true });
  const entries = readdirSync(src, { withFileTypes: true });
  for (const entry of entries) {
    const srcPath = join(src, entry.name);
    const destPath = join(dest, entry.name);
    if (entry.isDirectory()) {
      copyDirRecursive(srcPath, destPath);
    } else {
      copyFileSync(srcPath, destPath);
    }
  }
}
