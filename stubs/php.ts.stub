/**
 * Custom PhpCgiBase subclass for Cloudflare Workers.
 *
 * - Extends PhpCgiBase directly (no navigator.locks from PhpCgiWebBase)
 * - Uses the simple FIFO queue from PhpCgiBase._enqueue()
 * - Disables IDBFS persistence (autoTransaction: false)
 * - Provides WASM binary via instantiateWasm for Workers compatibility
 * - Uses custom PHP 8.5 WASM with OPcache statically linked
 *
 * Generated by: php artisan laraworker:install
 */

// Custom PhpCgiBase from php-wasm-build (no navigator.locks dependency)
// @ts-expect-error — no type declarations
import { PhpCgiBase } from './PhpCgiBase.mjs';
// @ts-expect-error — custom Emscripten module (copied from php-wasm-build)
import PHP from './php-cgi.mjs';

// Import WASM binary directly — Cloudflare Workers supports .wasm imports
// which produce a compiled WebAssembly.Module (no fetch needed)
// @ts-expect-error — wasm import
import phpWasm from './php-cgi.wasm';

interface PhpCgiCloudflareOptions {
  docroot?: string;
  prefix?: string;
  entrypoint?: string;
  rewrite?: (path: string) => string | { scriptName: string; path: string };
  env?: Record<string, string>;
  ini?: string;
  /** Cloudflare D1 database bindings — passed through to Module.cfd1 for pdo-cfd1 */
  cfd1?: Record<string, unknown>;
}

export class PhpCgiCloudflare extends PhpCgiBase {
  private _pendingHeaders: Headers | null = null;
  private _previousHeaderEnvKeys: string[] = [];
  private _refreshCount = 0;
  private _refreshCallCount = 0;
  private _initialized = false;

  // Static readonly Set to skip headers already handled by PhpCgiBase — avoid per-request allocation
  private static readonly SKIP_HEADERS = new Set(['host', 'cookie', 'content-type', 'content-length']);

  // Pre-computed HTTP header env name conversions for common headers (memoization for frequent headers)
  private static readonly HEADER_ENV_CACHE: Map<string, string> = new Map([
    ['accept', 'HTTP_ACCEPT'],
    ['accept-encoding', 'HTTP_ACCEPT_ENCODING'],
    ['accept-language', 'HTTP_ACCEPT_LANGUAGE'],
    ['authorization', 'HTTP_AUTHORIZATION'],
    ['connection', 'HTTP_CONNECTION'],
    ['referer', 'HTTP_REFERER'],
    ['user-agent', 'HTTP_USER_AGENT'],
    ['x-requested-with', 'HTTP_X_REQUESTED_WITH'],
    ['x-forwarded-for', 'HTTP_X_FORWARDED_FOR'],
    ['x-forwarded-proto', 'HTTP_X_FORWARDED_PROTO'],
  ]);

  constructor(options: PhpCgiCloudflareOptions = {}) {
    const {
      docroot = '/app/public',
      prefix = '/',
      entrypoint = 'index.php',
      rewrite,
      env = {},
      ini = '',
      cfd1,
    } = options;

    // PhpCgiBase expects a "binLoader" — a Promise resolving to {default: PHP}.
    // Wrap the statically imported PHP module as a resolved Promise.
    super(Promise.resolve({ default: PHP }), {
      docroot,
      prefix,
      entrypoint,
      rewrite:
        rewrite ??
        ((path: string) => {
          // Laravel-style rewrite: all non-file requests go through index.php
          return { scriptName: '/index.php', path };
        }),
      autoTransaction: false,
      env: {
        ...env,
      },
      ini,
      // D1 bindings — spread into Emscripten module as Module.cfd1
      // The pdo-cfd1 extension reads Module.cfd1[bindingName] via EM_ASM
      ...(cfd1 ? { cfd1 } : {}),
      // Provide the WASM binary directly via instantiateWasm.
      instantiateWasm(
        info: WebAssembly.Imports,
        receiveInstance: (instance: WebAssembly.Instance, module?: WebAssembly.Module) => unknown,
      ) {
        const instance = new WebAssembly.Instance(phpWasm, info);
        return receiveInstance(instance, phpWasm);
      },
    });
  }

  /**
   * Override PhpCgiBase.refresh() to prevent unnecessary module rebuilds.
   *
   * PhpCgiBase calls refresh() on ANY non-zero exit code, destroying the
   * WASM module and OPcache SHM. Most non-zero exits are recoverable PHP
   * errors (fatals, uncaught exceptions) that don't corrupt the module —
   * only WASM RuntimeErrors indicate genuine corruption.
   *
   * CRITICAL: PhpCgiBase's constructor calls this.refresh() to initialize
   * this.binary. We MUST delegate to super.refresh() on that first call,
   * otherwise the Emscripten module is never created and getFS() fails
   * with "Cannot read properties of undefined (reading 'FS')".
   *
   * Detection: PhpCgiBase calls refresh() from two places:
   * - catch block (~L691): after catching a JS error (RuntimeError, etc.)
   * - finally block (~L701): when exitCode !== 0
   *
   * A WASM crash triggers BOTH calls (count >= 2).
   * A PHP application error triggers ONLY the finally call (count === 1).
   *
   * We intercept post-init calls (no-op) and expose `needsRestart` so the
   * worker can recycle the module only when genuinely corrupted.
   */
  refresh(): void {
    if (!this._initialized) {
      this._initialized = true;
      super.refresh();
      return;
    }
    this._refreshCount++;
    this._refreshCallCount++;
  }

  /**
   * Total number of times PhpCgiBase requested a refresh (for diagnostics).
   */
  get refreshCount(): number {
    return this._refreshCount;
  }

  /**
   * True when the last request caused a WASM RuntimeError (module corruption).
   * The caller should discard this instance and create a fresh one.
   */
  get needsRestart(): boolean {
    return this._refreshCallCount >= 2;
  }

  /**
   * Forward incoming request headers to PHP CGI env vars.
   * Resets the per-request refresh counter so needsRestart reflects only
   * the current request.
   */
  async request(request: Request): Promise<Response> {
    this._pendingHeaders = request.headers;
    this._refreshCallCount = 0;
    return super.request(request);
  }

  /**
   * Called by PhpCgiBase after `this.binary` resolves but before env vars are set.
   * Sets HTTP_<NAME> env vars for each request header not already handled by PhpCgiBase.
   *
   * Critically, this also populates the CookieJar from the incoming request's
   * Cookie header. PhpCgiBase sets HTTP_COOKIE from cookieJar.toEnv() AFTER
   * this hook runs — so we must inject browser cookies into the CookieJar here.
   * Without this, sessions (and CSRF tokens) are lost on Worker cold starts
   * because the CookieJar only persists within a single isolate lifetime.
   */
  async _beforeRequest(): Promise<void> {
    const headers = this._pendingHeaders;
    if (!headers) return;

    // @ts-expect-error — untyped base class property
    const php = await this.binary;
    const putEnv = (key: string, value: string) =>
      php.ccall('wasm_sapi_cgi_putenv', 'number', ['string', 'string'], [key, value]);

    // Clear stale headers from previous request (WASM instance is reused)
    for (const key of this._previousHeaderEnvKeys) {
      putEnv(key, '');
    }
    this._previousHeaderEnvKeys = [];

    // Populate cookieJar from the incoming Cookie header so PhpCgiBase
    // includes browser cookies when it sets HTTP_COOKIE. Clear first to
    // prevent stale cookies from a previous request leaking across users.
    // @ts-expect-error — untyped base class property
    const cookieJar = this.cookieJar;
    cookieJar.cookies.clear();

    const cookieHeader = headers.get('cookie');
    if (cookieHeader) {
      for (const pair of cookieHeader.split(';')) {
        const trimmed = pair.trim();
        if (trimmed) {
          cookieJar.store(trimmed);
        }
      }
    }

    // Headers already set by PhpCgiBase — skip to avoid double-setting (use static readonly Set)
    for (const [name, value] of headers.entries()) {
      if (PhpCgiCloudflare.SKIP_HEADERS.has(name)) continue;
      // Check memoized common headers, otherwise compute + cache
      let envName = PhpCgiCloudflare.HEADER_ENV_CACHE.get(name);
      if (envName === undefined) {
        envName = 'HTTP_' + name.toUpperCase().replace(/-/g, '_');
        // Cache for reuse on subsequent requests with same header
        PhpCgiCloudflare.HEADER_ENV_CACHE.set(name, envName);
      }
      putEnv(envName, value);
      this._previousHeaderEnvKeys.push(envName);
    }

    this._pendingHeaders = null;
  }

  /**
   * Get the Emscripten FS module once the PHP binary is ready.
   */
  async getFS() {
    const php = await this.binary;
    return php.FS;
  }
}
